*BEGIN WORDS VERSION=430/320 ENCODING=7BIT
<Applix Words>
<asc @(#)% parag 32                 
>
<Globals levelIndent:500 hyphMethod:0 headerMargin:250 footerMargin:250 changeB\
 arPos:0>
<start_styles>
<style "Normal" no-pageBreak no-keepWith no-block justifyLeft indentToLevel spe\
 llcheck firstIndent:0 leftIndent:0 rightIndent:0 lineSpacing:0 preParaSpacing:\
 0 postParaSpacing:100 level:0 hyphZone:250 hyphMinFrag:2  no-bold no-italic no\
 -strikethru no-hidden no-caps no-underline hyphenate color:"Black" face:"Palat\
 ino" size:12 position:0 tag:""  lB:0:0:"" rB:0:0:"" tB:0:0:"" bB:0:0:"" hB:0:0\
 :"" vB:0:0:"" shading:18:"":"":"" horizontalMargin:0 verticalMargin:0 dropShad\
 ow:0  localTabs  noFrame  >
<style "Cell" parent "Normal" postParaSpacing:0  >
<style "Footnote" parent "Normal" >
<style "HdrFtr" parent "Normal" preParaSpacing:250 postParaSpacing:250  italic \
 face:"Avant Garde" size:10  localTabs cT:3500 rT:7000 rT:9500  noFrame  >
<style "TOC" parent "Normal" nextStyle "TOC" firstIndent:0 leftIndent:0 rightIn\
 dent:500 preParaSpacing:0 postParaSpacing:0  >
<style "TOC-html_h1" parent "TOC" nextStyle "TOC-html_h1" preParaSpacing:100 po\
 stParaSpacing:0  bold  localTabs lT:0 rT:6000:". "  >
<style "TOC-html_h2" parent "TOC" nextStyle "TOC-html_h2" firstIndent:250  loca\
 lTabs lT:0 rT:8000:". "  >
<style "TOC-html_h3" parent "TOC" nextStyle "TOC-html_h3" firstIndent:500  loca\
 lTabs lT:0 rT:8000:". "  >
<style "TOC-html_h4" parent "TOC" nextStyle "TOC-html_h4" firstIndent:500  loca\
 lTabs lT:0 rT:7000:". "  >
<style "html_address" parent "Normal" nextStyle "Normal" italic  >
<style "html_blockquote" parent "Normal" nextStyle "Normal" firstIndent:500 lef\
 tIndent:500 rightIndent:500  >
<style "html_bullet_list" parent "Normal" glossary "html_bullet" firstIndent:17\
 5 leftIndent:500 lineSpacing:0 preParaSpacing:0 postParaSpacing:0  localTabs  \
 >
<style "html_cell" parent "Normal" postParaSpacing:0  >
<style "html_cell_header" parent "html_cell" bold  >
<style "html_citation_text" parent "Normal" nextStyle "Normal" italic  >
<style "html_code_text" parent "Normal" nextStyle "Normal" face:"Courier"  >
<style "html_definition_text" parent "Normal" nextStyle "Normal" italic  >
<style "html_description" parent "Normal" nextStyle "html_description_title" fi\
 rstIndent:500 leftIndent:500 rightIndent:500 lineSpacing:0 preParaSpacing:0 po\
 stParaSpacing:0  >
<style "html_description_title" parent "Normal" nextStyle "html_description" li\
 neSpacing:0 preParaSpacing:0 postParaSpacing:0  >
<style "html_dir_list" parent "Normal" glossary "html_dir" firstIndent:175 left\
 Indent:500 preParaSpacing:0 postParaSpacing:0  localTabs  >
<style "html_emphasis_text" parent "Normal" nextStyle "Normal" italic  >
<style "html_h1" parent "Normal" nextStyle "html_h2" keepWith justifyRight preP\
 araSpacing:300 postParaSpacing:300  bold face:"Avant Garde" size:24  noFrame  \
 >
<style "html_h2" parent "Normal" nextStyle "Normal" keepWith preParaSpacing:300\
  postParaSpacing:200  bold face:"Avant Garde" size:18  tB:4:0:"Black" dropShad\
 ow:0  noFrame  >
<style "html_h3" parent "Normal" nextStyle "Normal" keepWith preParaSpacing:200\
  postParaSpacing:200  bold face:"Avant Garde" size:14  >
<style "html_h4" parent "Normal" nextStyle "Normal" keepWith preParaSpacing:200\
  postParaSpacing:200  bold face:"Avant Garde" size:12  >
<style "html_h5" parent "Normal" nextStyle "Normal" preParaSpacing:200  bold si\
 ze:10  >
<style "html_h6" parent "Normal" nextStyle "Normal" preParaSpacing:200  bold si\
 ze:8  >
<style "html_hr" parent "Normal" nextStyle "Normal" justifyCenter  size:6  bB:4\
 :0:"Black" dropShadow:0  noFrame  >
<style "html_hyperlink_text" parent "Normal" nextStyle "html_hyperlink_text" un\
 derline color:"HtmlLinkDefault@"  >
<style "html_hyperlink_wp_text" parent "html_hyperlink_text" underline color:"R\
 ed"  >
<style "html_kbd_text" parent "Normal" nextStyle "Normal" face:"Courier"  >
<style "html_menu_list" parent "Normal" glossary "html_menu" firstIndent:175 le\
 ftIndent:500 preParaSpacing:0 postParaSpacing:0  localTabs  >
<style "html_num_list" parent "Normal" glossary "html_numlist" firstIndent:0 le\
 ftIndent:500 lineSpacing:0 preParaSpacing:0 postParaSpacing:0  localTabs dT:27\
 5:"."  >
<style "html_num_list_start" parent "html_num_list" glossary "html_numliststart\
 " nextStyle "html_num_list" lineSpacing:0 preParaSpacing:0 postParaSpacing:0  \
 >
<style "html_preformatted" parent "Normal" firstIndent:300 leftIndent:300 lineS\
 pacing:30  face:"Courier" size:12  >
<style "html_sample_text" parent "Normal" nextStyle "Normal" face:"Courier"  >
<style "html_strong_text" parent "Normal" nextStyle "Normal" bold  >
<style "html_table_caption" parent "Normal" justifyCenter  bold  >
<style "html_unknown_text" parent "Normal" nextStyle "Normal" bold face:"Courie\
 r"  >
<style "html_variable_text" parent "Normal" nextStyle "Normal" italic  >
<series "main" 0 1 3 2 4 0 0 0 0 0 trailer:". ">
<series "Footnote$" 0 0 0 0 0 0 0 0 0 0>
<series "Endnote$" 0 0 0 0 0 0 0 0 0 0>
<series "numberStyle" 0 1 2 3 4 0 0 0 0 0 trailer:". ">
<S_G "FootnoteBar@" live>
<T "_________________________">
<P "Normal">
<E_G>
<S_G "FootnoteContBar@" live>
<T "__________________________________________________">
<P "Normal">
<E_G>
<S_G "EndnoteBar@" live>
<T "_________________________">
<P "Normal">
<E_G>
<S_G "TableContinuation@" live>
<T "(cont.)">
<E_G>
<S_G "numberGlossary" live>
<S_F fieldType:3>
<T "series \"numberStyle\"">
<FV>
<T "1. ">
<E_F>
<E_G>
<S_G "bulletGlossary" live>
<T "^lh^aj" face:"Symbol" >
<E_G>
<color "White":0:0:0:0>
<color "Black":0:0:0:255>
<color "Grey 95":0:0:0:13>
<color "Grey 87":0:0:0:33>
<color "Grey 75":0:0:0:64>
<color "Grey 50":0:0:0:128>
<color "Red":0:255:255:0>
<color "Red 95":13:255:255:0>
<color "Red 87":33:255:255:0>
<color "Red 75":64:255:255:0>
<color "Red 50":128:255:255:0>
<color "Green":255:0:255:0>
<color "Green 95":255:13:255:0>
<color "Green 87":255:33:255:0>
<color "Green 75":255:64:255:0>
<color "Green 50":255:128:255:0>
<color "Blue":255:255:0:0>
<color "Blue 95":255:255:13:0>
<color "Blue 87":255:255:33:0>
<color "Blue 75":255:255:64:0>
<color "Blue 50":255:255:128:0>
<color "Yellow":0:0:255:0>
<color "Yellow 95":0:0:255:13>
<color "Yellow 87":0:0:255:33>
<color "Yellow 75":0:0:255:64>
<color "Yellow 50":0:0:255:128>
<color "Magenta":0:255:0:0>
<color "Magenta 95":0:255:0:13>
<color "Magenta 87":0:255:0:33>
<color "Magenta 75":0:255:0:64>
<color "Magenta 50":0:255:0:128>
<color "Cyan":255:0:0:0>
<color "Cyan 95":255:0:0:13>
<color "Cyan 87":255:0:0:33>
<color "Cyan 75":255:0:0:64>
<color "Cyan 50":255:0:0:128>
<color "Tan":0:57:131:0>
<color "Clay":0:74:74:57>
<color "Brown":30:100:220:30>
<color "Dark Brown":60:135:190:65>
<color "Olive":90:65:190:65>
<color "Light Orange":0:33:255:0>
<color "Orange":0:90:255:0>
<color "Dark Orange":0:132:255:0>
<color "Light Purple":31:153:0:0>
<color "Purple":80:208:0:15>
<color "Dark Purple":25:126:0:44>
<color "HtmlLinkDefault@":255:255:0:0>
<series "NumList" 0 0 0 0 0 0 0 0 0 0 trailer:".">
<S_G "html_numliststart" live>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\" -set 1">
<FV>
<T "1.">
<E_F>
<T "^aj">
<E_G>
<S_G "html_numlist" live>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "1.">
<E_F>
<T "^aj">
<E_G>
<color "Silver":0:0:0:63>
<color "Gray":0:0:0:127>
<color "Maroon":0:128:128:127>
<color "Fuchsia":0:255:0:0>
<color "Lime":255:0:255:0>
<color "Navy":128:128:0:127>
<color "Teal":128:0:0:127>
<color "Aqua":255:0:0:0>
<color "HtmlBackground@":0:0:0:25>
<S_G "html_bullet" live>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_G>
<S_G "html_menu" live>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_G>
<S_G "html_dir" live>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_G>
<end_styles>
<start_flow>
<WP400 "This file must be filtered to be read in WP 3.11">
<P "Normal">
<P "Normal">
<P "Normal">
<S_F fieldType:6 date:893335256 docType:66 appType:2>
*LINK CodeGen.gif
<T "link \"CodeGen.gif\" -docType \"66\" -appType \"Graphics_\" -picture">
<FV>
<picture "/u/cgt/src/bin/of/docs/CodeGen.gif" appId:2 proportional clipMode:1 w\
 idth:1440 height:1307>
<E_F>
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<T "Smart" bold no-italic size:36 >
<T "Firmware" bold italic size:36 >
<T "TM" no-italic size:10 position:20 >
<P "Normal" justifyCenter level:1 >
<P "Normal">
<P "Normal">
<page_break>
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<P "Normal">
<T "Copyright ^kj 1996-2000 by CodeGen, Inc. All Rights Reserved.">
<P "Normal" justifyCenter >
<P "Normal">
<P "Normal">
<T "http://www.codegen.com">
<P "Normal" justifyCenter >
<T "mailto: info@codegen.com">
<P "Normal" justifyCenter >
<P "Normal">
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:None oddFooter:None sectNumFmt:-1 sectPageSep:"-" pageNumFmt:4 p\
 ageNumCtl:0>
<S_F fieldType:14>
<T "make_TOC -styles \"html_h1,html_h2,html_h3\" -dotTab">
<FV>
<T "1. Introduction^aj 1">
<P "TOC-html_h1">
<T "Features^aj 1">
<P "TOC-html_h3">
<T "2. Basics^aj 3">
<P "TOC-html_h1">
<T "Files^aj 3">
<P "TOC-html_h2">
<T "Headers^aj 7">
<P "TOC-html_h2">
<T "Commands^aj 8">
<P "TOC-html_h2">
<T "Stacks^aj 9">
<P "TOC-html_h2">
<T "Memory^aj 11">
<P "TOC-html_h2">
<T "Strings^aj 12">
<P "TOC-html_h2">
<T "Fcodes^aj 13">
<P "TOC-html_h2">
<T "3. Machine dependencies^aj 15">
<P "TOC-html_h1">
<T "machdep.h^aj 15">
<P "TOC-html_h2">
<T "machdep.c^aj 16">
<P "TOC-html_h2">
<T "4. Creating new words^aj 21">
<P "TOC-html_h1">
<T "Words^aj 21">
<P "TOC-html_h2">
<T "Packages^aj 23">
<P "TOC-html_h2">
<T "5. Compiling, Running, Etc.^aj 27">
<P "TOC-html_h1">
<T "Building^aj 27">
<P "TOC-html_h2">
<T "Running^aj 28">
<P "TOC-html_h2">
<T "Tokenizing^aj 28">
<P "TOC-html_h2">
<T "Detokenizing^aj 29">
<P "TOC-html_h2">
<T "6. Plug-in executable images^aj 31">
<P "TOC-html_h1">
<T "Interface^aj 31">
<P "TOC-html_h2">
<T "Supplied image formats^aj 33">
<P "TOC-html_h2">
<T "Sample Forth image format^aj 33">
<P "TOC-html_h2">
<T "7. Plug-in filesystem^aj 37">
<P "TOC-html_h1">
<T "How it works^aj 37">
<P "TOC-html_h2">
<T "Interface^aj 39">
<P "TOC-html_h2">
<T "8. PCI-bus interface^aj 41">
<P "TOC-html_h1">
<T "Machine-dependent bus interface^aj 41">
<P "TOC-html_h2">
<T "pci_num_host_bridges^aj 42">
<P "TOC-html_h3">
<T "pci_config_read pci_config_write^aj 42">
<P "TOC-html_h3">
<T "pci_intr_ack pci_special_cycle^aj 42">
<P "TOC-html_h3">
<T "pci_mem_read pci_mem_write^aj 42">
<P "TOC-html_h3">
<T "pci_mem_read64 pci_mem_write64^aj 42">
<P "TOC-html_h3">
<T "pci_io_read pci_io_write^aj 42">
<P "TOC-html_h3">
<T "pci_map_in pci_map_out^aj 43">
<P "TOC-html_h3">
<T "pci_dma_alloc pci_dma_free^aj 43">
<P "TOC-html_h3">
<T "pci_dma_map_in pci_dma_map_out^aj 43">
<P "TOC-html_h3">
<T "pci_dma_sync^aj 43">
<P "TOC-html_h3">
<T "pci_init_addresses^aj 43">
<P "TOC-html_h3">
<T "pci_bus_package^aj 44">
<P "TOC-html_h3">
<T "Driver interface^aj 44">
<P "TOC-html_h2">
<T "Pci_driver structure^aj 44">
<P "TOC-html_h3">
<T "Install PCI driver^aj 45">
<P "TOC-html_h3">
<T "machdep.c interface^aj 46">
<P "TOC-html_h2">
<T "9. ISA-bus interface^aj 49">
<P "TOC-html_h1">
<T "Machine-dependent bus interface^aj 49">
<P "TOC-html_h2">
<T "isa_mem_read isa_mem_write^aj 49">
<P "TOC-html_h3">
<T "isa_io_read isa_io_write^aj 50">
<P "TOC-html_h3">
<T "isa_map_in isa_map_out^aj 50">
<P "TOC-html_h3">
<T "isa_dma_alloc isa_dma_free^aj 50">
<P "TOC-html_h3">
<T "isa_dma_map_in isa_dma_map_out^aj 50">
<P "TOC-html_h3">
<T "isa_dma_sync^aj 50">
<P "TOC-html_h3">
<T "Driver interface^aj 50">
<P "TOC-html_h2">
<T "machdep.c interface^aj 51">
<P "TOC-html_h2">
<T "10. Client interface^aj 53">
<P "TOC-html_h1">
<T "IEEE-1275 client API^aj 53">
<P "TOC-html_h2">
<T "SmartFirmware C API^aj 55">
<P "TOC-html_h2">
<T "C functions^aj 55">
<P "TOC-html_h3">
<T "Initialization^aj 60">
<P "TOC-html_h3">
<T "Example^aj 60">
<P "TOC-html_h3">
<T "Appendix A:\nSmartFirmware User Manual^aj 63">
<P "TOC-html_h1">
<T "Basics^aj 63">
<P "TOC-html_h2">
<T "Devices^aj 63">
<P "TOC-html_h2">
<T "Parameter settings^aj 65">
<P "TOC-html_h2">
<T "Parameter variables^aj 67">
<P "TOC-html_h2">
<T "Booting^aj 69">
<P "TOC-html_h2">
<T "Net-booting^aj 70">
<P "TOC-html_h3">
<T "Testing^aj 71">
<P "TOC-html_h2">
<T "Changing the console^aj 72">
<P "TOC-html_h2">
<T "Forth variables^aj 73">
<P "TOC-html_h2">
<E_F>
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_41" evenHeader:Normal "_AX_HF_40" firstHeader:Nor\
 mal "_AX_HF_39" oddFooter:Normal "_AX_HF_43" evenFooter:Normal "_AX_HF_42" sec\
 tNumFmt:-1 sectPageSep:"-" pageNumFmt:4 pageNumCtl:1 pageNumVal:1>
<P "Normal">
<S_F fieldType:3>
<T "series \"main\"">
<FV>
<T "1. ">
<E_F>
<S_F fieldType:6 date:909441127 docType:200 appType:1 outDated
<start_eval_value>
<S_F fieldType:17
<start_eval_value>
<T "--field--">
<end_eval_value>
>
<T "hyper_target \"Introduction\"">
<FV>
<E_F>
<T "Introduction" face:"Avant Garde" >
<P "html_h1" level:0  face:"Palatino" >
<S_F fieldType:29 editable
<start_eval_value>
<T "Welcome" bold >
<end_eval_value>
>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "Welcome" bold face:"Avant Garde" >
<E_F>
<P "html_h4" level:0  face:"Palatino" >
<T "SmartFirmware is an implementation of the OpenFirmware standard (IEEE Std 1\
 275-1994 plus errata) designed for embedded systems. A more than passing famil\
 iarity with the standard and ANSI Forth is assumed in this document. We make n\
 o attempt to teach " face:"Palatino" >
<S_F fieldType:16 editable
<start_eval_value>
<T "OpenFirmware">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"http://playground.sun.com/pub/1\
 275/home.html\" -text \"OpenFirmware\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "OpenFirmware" underline color:"HtmlLinkDefault@" face:"Palatino" >
<E_F>
<T ", " face:"Palatino" >
<S_F fieldType:16 editable
<start_eval_value>
<T "Forth">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"http://www.taygeta.com/forth.ht\
 ml\" -text \"Forth\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "Forth" underline color:"HtmlLinkDefault@" face:"Palatino" >
<E_F>
<T ", or C here. Please follow the links for more information." face:"Palatino"\
  >
<P "Normal" level:0  face:"Palatino" >
<S_F fieldType:17 editable>
<T "hyper_target \"Features\"">
<FV>
<E_F>
<T "Features" face:"Avant Garde" >
<P "html_h3" face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Written entirely in ANSI C to be simple, maintainable, portable, and very e\
 asy to customize." face:"Palatino" >
<P "html_bullet_list" level:0  face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Additional code may be written in a mixture of ANSI C, Forth, or Fcode as d\
 esired." face:"Palatino" >
<P "html_bullet_list" level:0  face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Modular design allows selecting specific functions and packages to be burne\
 d into a ROM." face:"Palatino" >
<P "html_bullet_list" level:0  face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Includes an OpenFirmware-compliant interpreter, user interface, application\
  interface, client interface, and tokenizer" face:"Palatino" >
<P "html_bullet_list" level:0  face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Detokenizer included to aid debugging embedded Fcode" face:"Palatino" >
<P "html_bullet_list" level:0  face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Unix hosted configuration for debugging and testing as well as embedded con\
 figuration for burning into a ROM." face:"Palatino" >
<P "html_bullet_list" level:0  face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "BOOTP/DHCP/RARP/TFTP support module for booting from networks." face:"Palat\
 ino" >
<P "html_bullet_list" level:0  face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Display package for simple frame buffers and a terminal emulator." face:"Pa\
 latino" >
<P "html_bullet_list" level:0  face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Drivers are available for several common PCI and ISA devices including Digi\
 tal ethernet chips, Symbios SCSI chips, various PCI-ISA bridge chips, and ISA \
 serial chips, among others." face:"Palatino" >
<P "html_bullet_list" level:0  face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Custom ANSI C-to-Fcode/Forth compiler is available" face:"Palatino" >
<P "html_bullet_list" level:0  face:"Palatino" >
<P "Normal" face:"Palatino" >
<T "Please " face:"Palatino" >
<S_F fieldType:16 editable
<start_eval_value>
<T "contact us">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"mailto:info@cgt.com\" -text \"c\
 ontact us\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "contact us" underline color:"HtmlLinkDefault@" face:"Palatino" >
<E_F>
<T " for pricing and availability or generation of additional drivers and modul\
 es, or about our C compiler." face:"Palatino" >
<P "Normal" level:0  face:"Palatino" >
<end_eval_value>
>
*LINK /cgt/src/bin/of/docs/SFChapter1.aw
<T "link \"/cgt/src/bin/of/docs/SFChapter1.aw\" -docType \"200\" -appType \"Wor\
 ds_\"">
<FV>
<S_F fieldType:17
<start_eval_value>
<T "--field--">
<end_eval_value>
>
<T "hyper_target \"Introduction\"">
<FV>
<E_F>
<T "Introduction">
<P "html_h1" face:"Palatino" >
<S_F fieldType:29 editable
<start_eval_value>
<T "Welcome" bold >
<end_eval_value>
>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "Welcome" bold >
<E_F>
<P "html_h4" face:"Palatino" >
<T "SmartFirmware is an implementation of the OpenFirmware standard (IEEE Std 1\
 275-1994 plus errata) designed for embedded systems. A more than passing famil\
 iarity with the standard and ANSI Forth is assumed in this document. We make n\
 o attempt to teach ">
<S_F fieldType:16 editable
<start_eval_value>
<T "OpenFirmware">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"http://playground.sun.com/pub/1\
 275/home.html\" -text \"OpenFirmware\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "OpenFirmware" underline color:"HtmlLinkDefault@" >
<E_F>
<T ", ">
<S_F fieldType:16 editable
<start_eval_value>
<T "Forth">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"http://www.taygeta.com/forth.ht\
 ml\" -text \"Forth\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "Forth" underline color:"HtmlLinkDefault@" >
<E_F>
<T ", or C here.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Features\"">
<FV>
<E_F>
<T "Features">
<P "html_h3" face:"Palatino" >
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Written entirely in ANSI C to be simple, maintainable, portable, and very e\
 asy to customize.">
<P "html_bullet_list">
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Additional code may be written in a mixture of ANSI C, Forth, or Fcode as d\
 esired.">
<P "html_bullet_list">
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Modular design allows selecting specific functions and packages to be burne\
 d into a ROM.">
<P "html_bullet_list">
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Includes an OpenFirmware-compliant interpreter, user interface, application\
  interface, client interface, and tokenizer">
<P "html_bullet_list">
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Detokenizer included to aid debugging embedded Fcode">
<P "html_bullet_list">
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Unix hosted configuration for debugging and testing as well as embedded con\
 figuration for burning into a ROM.">
<P "html_bullet_list">
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "BOOTP/DHCP/RARP/TFTP support module for booting from networks.">
<P "html_bullet_list">
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Display package for simple frame buffers and a terminal emulator.">
<P "html_bullet_list">
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Drivers are available for several common PCI and ISA devices including Digi\
 tal ethernet chips, Symbios SCSI chips, various PCI-ISA bridge chips, and ISA \
 serial chips, among others.">
<P "html_bullet_list">
<S_F fieldType:9
<start_eval_value>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<end_eval_value>
>
<T "glossary \"html_bullet\"">
<FV>
<T "^lh" face:"Symbol" >
<T "^aj" face:"Times" >
<E_F>
<T "Custom ANSI C-to-Fcode/Forth compiler is available">
<P "html_bullet_list">
<P "Normal">
<T "Please ">
<S_F fieldType:16 editable
<start_eval_value>
<T "contact us">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"mailto:info@cgt.com\" -text \"c\
 ontact us\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "contact us" underline color:"HtmlLinkDefault@" >
<E_F>
<T " for pricing and availability or generation of additional drivers and modul\
 es, or about our C compiler.">
<P "Normal">
<E_F>
<P "Normal">
<P "Normal">
<P "Normal">
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_33" evenHeader:Inherit firstHeader:Inherit evenFo\
 oter:Inherit sectNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:1 pageNumVa\
 l:1>
<S_F fieldType:3>
<T "series \"main\"">
<FV>
<T "2. ">
<E_F>
<S_F fieldType:6 date:908505734 docType:200 appType:1 outDated
<start_eval_value>
<S_F fieldType:27 editable>
<T "html_tag -text \"<!-- This file created 5/30/98 10:36 PM by Claris Home Pag\
 e version 2.0-->\" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<META NAME=GENERATOR CONTENT=\\\"Claris Home Page 2.0\\\">\
 \" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<X-SAS-WINDOW TOP=42 BOTTOM=477 LEFT=4 RIGHT=534>\" -textS\
 tyle \"html_unknown_text\"">
<FV>
<E_F>
<T "Basics">
<P "html_h1" level:0 >
<T "This describes the design of SmartFirmware, to set a base for the customiza\
 tion descriptions in following chapters.">
<P "Normal" level:0 >
<T "Files">
<P "html_h2">
<T "The source files are separated into several directories. The upper level co\
 ntains files common to most platforms. Subdirectories are used for bus-specifi\
 c code, such as \"pci\", \"isa\", and \"scsi\", or for specific platform build\
  directories, such as \"unix\", \"i386\", and \"bebox\".">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Main-files\"">
<FV>
<E_F>
<T "Main files">
<P "html_h4" level:0 >
<T "Makefile       # Unix makefile for various builds\ncour8x16.font  # default\
  font for machdep.c below\ncour16x23.font # optional larger font\ncour32x44.fo\
 nt # optional really huge font\n8x16.font      # another 8x16 font\n^ka\ndefs.\
 h         # essential definitions and types\nerrs.h         # error codes go h\
 ere\nlogo.h         # default 64x64x8 logo for CodeGen, Inc.\n^ka\nctype.h    \
     # simple versions of these files for \nstdlib.h       #    embedded use wh\
 en building ROM\nstring.h       #    images of SmartFirmware\n^ka\nadmin.c    \
     # OpenFirmware Administration commands\nclient.c       # OpenFirmware Clie\
 nt Interface\ncmdio.c        # command-line I/O & editing routines\ncontrol.c \
      # Forth and Fcode control flow words\ncpu.c          # template for build\
 ing /cpu node\ndeblock.c      # disk deblocking package\ndebug.c        # Fort\
 h debugging command group\ndevice.c       # device-path manipulation Forth wor\
 ds\ndisklbl.c      # disk label package\ndisplay.c      # display package and \
 terminal emulator\nerrs.c         # strings for error numbers go here\nexec.c \
         # Forth and fcode execution & parsing\nfailsafe.c     # failsafe I/O d\
 river for debugging\nfb.c           # frame-buffer package for display\nforth.\
 c        # Forth words that are not fcodes\nfuncs.c        # basic words that \
 are also fcodes\nfuncs64.c      # words to support 64-bit extensions\nmain.c  \
        # main() - perform OpenFirmware bootup\nmemory.c       # template for b\
 uilding /memory node\nnvedit.c       # on-screen script editor\nobptftp.c     \
  # BOOTP/TFTP package\nother.c        # other misc. OpenFirmware words\npackag\
 es.c     # basic package manipulation words\nroot.c         # template for bui\
 lding / node\nstdlib.c       # simple versions of standard C routines\nstlb.c \
         # software TLB to aid 32<->64-bit translations\nsun.c          # Forth\
  words compatible with Sun's OBP\ntable.c        # low-level data-structure ma\
 nipulation\ntoken.c        # OpenFirmware tokenizer & detokenizer\ntest-*     \
     # various regression test command files">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Executable-loader-files\"">
<FV>
<E_F>
<T "Executable loader files">
<P "html_h4" level:0 >
<T "The contents of subdirectory \"exe\" are as follows. It supports plug-in bi\
 nary image loaders.">
<P "Normal" level:0 >
<T "coff.c         # COFF/ECOFF binary image loader \ndumpcoff.c     # test pro\
 gram to display COFF files\ndumpelf.c      # test program to display ELF files\
 \nelf.c          # ELF binary image loader\nelf64.c        # ELF (64-bit) bina\
 ry image loader\nexe.c          # plug-in binary image loader manager\nexe.h  \
         # header for plug-in binary image loaders\ngzip.c         # gunzip \"l\
 oader\" - needs freeware zlib\nloadfc.c       # Forth and Fcode loader">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Filesystem-files\"">
<FV>
<E_F>
<T "Filesystem files">
<P "html_h4" level:0 >
<T "The contents of subdirectory \"fs\" are as follows. It supports plug-in fil\
 esystem readers.">
<P "Normal" level:0 >
<T "bsdpart.c      # BSD partition map loader\nbsdufs.c       # BSD FFS/UFS fil\
 esystem loader\ndos.h          # DOS FAT headers\ndosfat.c       # DOS FAT fil\
 esystem loader\ndospart.c      # DOS partition loader\nfs.c           # plug-i\
 n filesystem loader manager\nfs.h           # header for plug-in filesystem lo\
 aders\niso9660.c      # ISO-9660 CD-ROM filesystem loader">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"ISA-files\"">
<FV>
<E_F>
<T "ISA files">
<P "html_h4" level:0 >
<T "The contents of subdirectory \"isa\" are as follows. This adds basic suppor\
 t for the PC-compatible ISA bus.">
<P "Normal" level:0 >
<T "isa.c          # basic ISA bus driver package\nisa.h          # headers for\
  ISA devices\nkbd.c          # PC keyboard driver\nne2000.c       # NE2000-com\
 patible Ethernet card driver\nns16550.c      # serial port driver\nvga.c      \
     # VGA-compatible display driver">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"PCI-files\"">
<FV>
<E_F>
<T "PCI files">
<P "html_h4" level:0 >
<T "The contents of subdirectory \"pci\" are as follows. This adds support for \
 the PCI bus.">
<P "Normal" level:0 >
<T "dc21140.c      # dummy DEChip 21140 driver for testing\ndecether.c     # DE\
 Chip 21x4x ethernet driver\nfakepci.c      # dummy PCI driver for unix host\nf\
 akepci.h      # externs for dummy PCI routines\nncrscsi.c      # Symbios 53C8x\
 x SCSI driver\npci.c          # basic PCI bus driver package\npci.h          #\
  definitions specific to the PCI bus\npcialloc.c     # internal PCI allocation\
  routines\npcicode.c      # current list of PCI vendor/device IDs\npcidisp.c  \
     # generic PCI display driver\npciisa.c       # driver for various PCI-ISA \
 bridges">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"SCSI-files\"">
<FV>
<E_F>
<T "SCSI files">
<P "html_h4" level:0 >
<T "The contents of subdirectory \"scsi\" are as follows, adding support for SC\
 SI buses.">
<P "Normal" level:0 >
<T "scsi.c         # common routines useful for SCSI drivers\nscsi.h         # \
 headers of common SCSI routines\nscsidisk.c     # generic SCSI disk driver">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Unix-files\"">
<FV>
<E_F>
<T "Unix files">
<P "html_h4" level:0 >
<T "The contents of subdirectory \"unix\" are as follows. These files allow run\
 ning SmartFirmware under a standard Unix environment for testing and debugging\
 .">
<P "Normal" level:0 >
<T "be-predefs.h   # pre-include definitions for BeOS\nbeapp.cc       # C++ fil\
 e to replace main.c for BeOS\nBeOS.proj      # MetroWerks project to build on \
 BeOS\nBeOS.rsrc      # resources for building under BeOS\nfakedisk.c     # fak\
 e disk driver - maps to Unix files\nmac.c          # Macintosh-specific code\n\
 machdep.h      # machine-dependent definitions\nmachdep.c      # machine-depen\
 dent code goes here\nMakefile       # build on Unix\nmw-predefs.h   # Metrower\
 ks prefix header file\nmw-project.hqx # Metrowerks project + other Mac files">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"i386-files\"">
<FV>
<E_F>
<T "i386 files">
<P "html_h4" level:0 >
<T "The contents of subdirectory \"i386\" are as follows. This supports SmartFi\
 rmware on standard i386-compatible PCs using the FreeBSD boot-loader. The boot\
 -loader provides a standard 32-bit environment for SmartFirmware to run under.\
  SmartFirmware takes over the hardware in place of the FreeBSD kernel and can \
 be booted directly off of a FreeBSD filesystem or floppy.">
<P "Normal" level:0 >
<T "divdi3.c       # math runtime function from BSD\nisabase.c      # low-level\
  ISA support routines\nmachdep.c      # i386-specific code\nmachdep.h      # i\
 386-specific definitions\nMakefile       # i386 build on Unix\nmoddi3.c       \
 # math runtime function from BSD\npcibase.c      # low-level PCI support routi\
 nes\nqdivrem.c      # math runtime function from BSD\nquad.h         # math ru\
 ntime function from BSD\nstart.S        # i386 startup assembly for launching\\
 nudivdi3.c      # math runtime function from BSD\numoddi3.c      # math runtim\
 e function from BSD">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"BeBox-files\"">
<FV>
<E_F>
<T "BeBox files">
<P "html_h4" level:0 >
<T "The contents of subdirectory \"bebox\" are as follows. This supports SmartF\
 irmware running on the dual-PowerPC 603e BeBox platform. It is booted in place\
  of the BeOS kernel off of a floppy and takes over the hardware.">
<P "Normal" level:0 >
<T "be-predefs.h   # pre-include definitions for BeBox\nbebox.h        # BeBox-\
 specific definitions\nBeBox.proj     # MetroWerks project for BeBox\nmachdep.c\
       # BeBox-specific code\nmachdep.h      # more BeBox-specific definitions\\
 npcibase.c      # low-level PCI support routines">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<T "SmartFirmware is designed so that it is easy to add or remove packages from\
  a particular build, simply by modifying the lists of desired packages and wor\
 d-sets in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " and then ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Makefile" italic >
<E_F>
<T " to compile and link the desired files. It is a good idea to create custom \
 ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " files by copying another project's versions for a new project, then editin\
 g them for the new platform.">
<P "Normal" level:0 >
<T "Each OpenFirmware package may be implemented as Forth code or as C code. Sm\
 artFirmware implements almost everything in C, with the exception of the defau\
 lt boot script and a few Forth words for ease of tokenizing.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<T "Headers">
<P "html_h2">
<T "All the major data structures and types are defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " , with some machine dependent definitions going in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h " italic >
<E_F>
<T ". The comments in the files should be reasonably self-explanatory. Addition\
 al bus or subsystem-specific code is under various subdirectories, such as ">
<T "fs/fs.h" italic >
<T " or ">
<T "isa/isa.h" italic >
<T ".">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Word-sizes\"">
<FV>
<E_F>
<T "Word sizes">
<P "html_h4" level:0 >
<T "The sizes of various type names must be specified in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h" italic >
<E_F>
<T " . They are typically 8, 16, and 32 bits signed and unsigned values. Howeve\
 r SmartFirmware can support 64-bit integer operations and Forth words only if \
 the C compiler supports them, such as some versions of the Gnu C compiler gcc.\
 ">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<T "A ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " is typically the standard word size of a platform. It must be large enough\
  to hold a pointer such as \"">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "ch" italic >
<E_F>
<T "ar">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "*" italic >
<E_F>
<T " \". However it may be larger than a pointer for those compilers that suppo\
 rt, say, 32-bit pointers but 64-bit integers.">
<P "Normal" level:0 >
<T "It is possible to build SmartFirmware with 32-bit ">
<T "Cells" italic >
<T " but with some 64-bit integer support.some 64-bit support is turned on if t\
 he macro ">
<T "__LONGLONG" italic >
<T " is defined to be the type of the 64-bit integer, such as \"">
<T "long long" italic >
<T "\" for gcc. 64-bit ">
<T "Cells" italic >
<T " are turned on if the macro ">
<T "SF_64BIT" italic >
<T " is defined.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<T "Commands">
<P "html_h2">
<T "Commands are simply C functions linked into the Forth environment. They are\
  designed to allow using them in both ways with fairly little effort.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Declaring\"">
<FV>
<E_F>
<T "Declaring">
<P "html_h4" level:0 >
<T "A C function that implements a Forth word is defined as follows;">
<P "Normal" level:0 >
<T "Retcode cfunc(Environ *e) { ... }">
<P "html_preformatted" level:0 >
<T "A set of macros in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " make declaring this somewhat easier for large numbers of ">
<T "Commands" italic >
<T ":">
<P "Normal" level:0 >
<T "C(name) {..}  # define a local static Command\nEC(name);     # declare an e\
 xtern for a Command\nCC(name){..}  # define a globally visible Command">
<P "html_preformatted" level:0 >
<T "These macros declare and define routines such as ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "cfunc" italic >
<E_F>
<T " taking one argument, and ">
<T "Environ*" italic >
<T " which is named ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "e" italic >
<E_F>
<T " . A typedef for ">
<T "Command" italic >
<T " is also declared to handle pointers to these functions.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Calling\"">
<FV>
<E_F>
<T "Calling">
<P "html_h4" level:0 >
<T "An ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Environ" italic >
<E_F>
<T " is passed by pointer to all C functions to keep from cluttering up the cod\
 e with a lot global variables. It also makes it much easier to support a threa\
 d-safe implementation in the future. Static global variables and data should o\
 nly be used for initialization.">
<P "Normal" level:0 >
<T "All C functions must return either ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "NO_ERROR" italic >
<E_F>
<T " or a specific error listed in the enum ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Retcode" italic >
<E_F>
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " . This mechanism is used to handle Forth exceptions without using">
<T "setjmp/longjmp" italic >
<T ". A C function that calls other C routines must check the return codes for \
 any error to either handle the error itself or to propagate that error to its \
 caller.">
<P "Normal" level:0 >
<T "The Retcode errors are translated to strings by the routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "err2str" italic >
<E_F>
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "exec.c" italic >
<E_F>
<T " when any error must be reported to the user. It may be easier to directly \
 use the routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "cprintf" italic >
<E_F>
<T " to display error messages, but this is only useful if the console has been\
  probed and installed. The error codes themselves are defined in ">
<T "errs.h" italic >
<T ", and ">
<T "errs.c" italic >
<T " must be kept synchronized with it.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<P "Normal">
<T "Stacks">
<P "html_h2">
<T "The Forth data and return stacks are manipulated using macros defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " . The stack elements are of the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " type declared in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h" italic >
<E_F>
<T " , which is usually 32 or 64 bits wide. These stacks are maintained as simp\
 le arrays within the ">
<T "Environ" italic >
<T " struct with pointers to the current top of each stack.">
<P "Normal" level:0 >
<T "The data stack is used to pass arguments and perform all the standard Forth\
  functions. The return stack is used to maintain a call-chain of Forth words a\
 s they are executed at runtime. It is also used to maintain loop variables for\
  the looping control words. This can get messy to manage the return stack for \
 certain words, but this sort of code is well-commented.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Range-checks\"">
<FV>
<E_F>
<T "Range checks">
<P "html_h4" level:0 >
<T "The following four macros are used to check the stack ranges. The first two\
  are intended for use in your own ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "if" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "while" italic >
<E_F>
<T " statements. The last two are more generally used throughout the code to ch\
 eck the ranges and return an appropriate ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Retcode." italic >
<E_F>
<P "Normal" level:0 >
<T "CKSP(e, min, max)       # check data stack\nCKRETSP(e, min, max)    # check\
  return stack\nIFCKSP(e, min, max)     # check & return error\nIFCKRETSP(e, mi\
 n, max)  # check & return error">
<P "html_preformatted" level:0 >
<T "These are used to increment and decrement the respective stack pointers. Ra\
 nges are not checked. They are used by the other macros and are generally not \
 used directly.">
<P "Normal" level:0 >
<T "BUMPSP(e)      # increment data stack ptr by one\nDROPSP(e)      # decremen\
 t data stack ptr by one\nBUMP_RETSP(e)  # increment return stack ptr\nDROP_RET\
 SP(e)  # decrement return stack ptr">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Push-and-Pop\"">
<FV>
<E_F>
<T "Push & Pop">
<P "html_h4" level:0 >
<T "These are used to access the top element of the stacks (a ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " ). Ranges are not checked.">
<P "Normal" level:0 >
<T "TOP(e)   # get Cell currently on top of data stack\nRTOP(e)  # get Cell on \
 top of return stack">
<P "html_preformatted" level:0 >
<T "These are used to get to a specific (nth) element on the stack without chec\
 king to see if it is in range. The topmost element on the stack is numbered ze\
 ro (0), the element below it is one (1), and so on.">
<P "Normal" level:0 >
<T "STACK(e, n)   # get nth element on data stack">
<P "html_preformatted" level:0 >
<T "These push a value on top of the data stack without checking for a range er\
 ror. The second form is used to cast a pointer value into a pointer-sized inte\
 ger before pushing it on the stack. It is generally used to eliminate warnings\
  from some compilers.">
<P "Normal" level:0 >
<T "PUSH(e, val)   # push val on top of data stack\nPUSHP(e, val)  # push val a\
 fter casting it from a pointer">
<P "html_preformatted" level:0 >
<T "These simply drop the stack, either by one element, or by a count (n). Rang\
 es are not checked.">
<P "Normal" level:0 >
<T "DROP(e)       # drop the top element on the data stack\nDROPN(e, n)   # dro\
 p the top n elements on the stack">
<P "html_preformatted" level:0 >
<T "These pop the top of the stack into the specified variable. The second form\
  allows inserting a typecast to cast the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " to a pointer such as a ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Byte*" italic >
<E_F>
<T " . The first assumes the variable is of type ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " . The last allows casting to any integer type. The first two may be overri\
 dden by custom macros to handle 64-bit to 32-bit (and 32 to 64) pointer transl\
 ations.">
<P "Normal" level:0 >
<T "POP(e, var)               # var = TOP(e); DROP(e);\nPOPT(e, var, ptrtype)  \
    # var = (ptrtype)TOP(e); DROP(e);\nPOPTYPE(e, var, inttype)  # var = (intty\
 pe)TOP(e); DROP(e);">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Return-stack\"">
<FV>
<E_F>
<T "Return stack">
<P "html_h4" level:0 >
<T "These do everything the above five macros do, only they operate on the retu\
 rn stack.">
<P "Normal" level:0 >
<T "RSTACK(e, n)\nRPUSH(e, val)\nRDROP(e)\nRDROPN(e, n)\nRPOP(e, var)">
<P "html_preformatted" level:0 >
<T "^ka">
<P "Normal" level:0 >
<T "Memory">
<P "html_h2">
<T "Memory is handled in as much a C fashion as possible. That is, except to mi\
 mic certain Forth behaviors, SmartFirmware uses ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "free" italic >
<E_F>
<T " to manage memory. Simple versions of these routines are provided in ">
<T "stdlib.c" italic >
<T " that allocate and free from a large fixed-size chunk of memory. An additio\
 nal routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_malloc" italic >
<E_F>
<T " is used to initialize the memory pool used by ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "free" italic >
<E_F>
<T " . This version of ">
<T "malloc" italic >
<T " may be used if there is no suitable ">
<T "malloc" italic >
<T " available in the runtime environment of a target or compiler.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Initializing\"">
<FV>
<E_F>
<T "Initializing">
<P "html_h4" level:0 >
<T "At start-up, the routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_initialize" italic >
<E_F>
<T " is called to do any machine-dependent setup. This routine, once it has set\
 up and initialized any appropriate hardware, calls ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_malloc" italic >
<E_F>
<T " with a chunk of memory to be used for the malloc pool, the size of which w\
 as defined by the macro ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MALLOC_POOL" italic >
<E_F>
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "<defs.h" italic >
<E_F>
<T " >.">
<P "Normal" level:0 >
<T "Once ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " is ready, then an ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Environ" italic >
<E_F>
<T " is created for the Forth world. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_environ" italic >
<E_F>
<T " is used to initialize an ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Environ" italic >
<E_F>
<T " , which in turn calls ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " to allocate a pool of ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MEM_SIZE" italic >
<E_F>
<T " bytes for the Forth world. This macro is defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "<defs.h>" italic >
<E_F>
<T " , and the call to ">
<T "init_environ" italic >
<T " is in ">
<T "main.c" italic >
<T ".">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Allocating\"">
<FV>
<E_F>
<T "Allocating">
<P "html_h4" level:0 >
<T "All the basic data structures (">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Entry, Table, Package, Instance, and Environ" italic >
<E_F>
<T " ) are allocated and freed by appropriately named routines in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "table.c" italic >
<E_F>
<T " . The externs for these routines are also in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " . Objects are always allocated from the heap and not the stack to keep thi\
 ngs simple, must always be created with ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "new_object" italic >
<E_F>
<T " , and freed with ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "delete_object" italic >
<E_F>
<T " .">
<P "Normal" level:0 >
<T "Temporary string buffers are frequently placed on the stack for convenience\
 . Other objects are simply ">
<T "malloc" italic >
<T "-ed and ">
<T "free" italic >
<T "-d as needed.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Debugging\"">
<FV>
<E_F>
<T "Debugging">
<P "html_h4" level:0 >
<T "If the macro DEBUG_MALLOC is defined, the malloc code will switch on additi\
 onal memory debugging code which does simple checks to catch overruning the he\
 ad or tail of ">
<T "malloc" italic >
<T "-ed objects, and verifying that ">
<T "free" italic >
<T "-d blocks are not used and that ">
<T "malloc" italic >
<T "-ed objects are initialized before use.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<T "Strings">
<P "html_h2">
<T "The OpenFirmware specification requires handling at least the Pascal and Fo\
 rth style strings. Implementing SmartFirmware in C also requires handling C st\
 rings in a reasonably seamless fashion.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"String-types\"">
<FV>
<E_F>
<T "String types">
<P "html_h4" level:0 >
<T "There are three sorts of strings managed within the SmartFirmware software.\
  There are C strings, Pascal strings, and Forth strings. C strings (">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Byte*" italic >
<E_F>
<T " ) are null-terminated arrays of characters. Pascal strings (">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "uByte*" italic >
<E_F>
<T " ) use the first byte of the string array to store the length and are thus \
 limited to 255 bytes in most implementations. Forth strings are two separate a\
 rray and length values (">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Byte*, Int" italic >
<E_F>
<T " ) and are managed as such.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Pascal-strings\"">
<FV>
<E_F>
<T "Pascal strings">
<P "html_h4" level:0 >
<T "SmartFirmware uses the Pascal string as its internal canonical form when st\
 oring a string in a data structure. When using a string in a function, it is c\
 onverted to a Forth string using the routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "setstrlen" italic >
<E_F>
<T " defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "table.c" italic >
<E_F>
<T " , which takes a string in any of the three forms and returns a string adju\
 sted to be in Forth style, with the actual length returned in another paramete\
 r.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Forth-strings\"">
<FV>
<E_F>
<T "Forth strings">
<P "html_h4" level:0 >
<T "Forth strings are then passed to most other C routines. If it takes both a \
 ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Byte*" italic >
<E_F>
<T " and an ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Int" italic >
<E_F>
<T " parameter, it usually expects a Forth string. Routines taking both argumen\
 ts always call ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "setstrlen" italic >
<E_F>
<T " in case the strings are in C or Pascal form.">
<P "Normal" level:0 >
<T "This makes it very easy to pass in C strings or Pascal strings by using the\
  length field set to one of two magic negative values, as defined by the macro\
 s ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "CSTR" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "PSTR" italic >
<E_F>
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " . Anytime a C string is passed to a routine, simply pass in a length of">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "CSTR" italic >
<E_F>
<T " and ">
<T "setstrlen" italic >
<T " takes it from there.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Copying-strings\"">
<FV>
<E_F>
<T "Copying strings">
<P "html_h4" level:0 >
<T "The routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "lstrdup" italic >
<E_F>
<T " , (also defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "table.c" italic >
<E_F>
<T " ) with its associated macros ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "cstrdup" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "pstrdup" italic >
<E_F>
<T " , allow creating and copying any form of string using ">
<T "malloc" italic >
<T ". ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "lstrdup" italic >
<E_F>
<T " is used when the type of string is unknown but a length parameter is avail\
 able. Otherwise, the type of string determines the right macro to use: ">
<T "cstrdup" italic >
<T " to copy C strings, and ">
<T "pstrdup" italic >
<T " to copy Pascal strings. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "lstrdup" italic >
<E_F>
<T " always returns a null-terminated Pascal string allocated using ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " , so it may be freed by passing the pointer to ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "free" italic >
<E_F>
<T " . The returned pointer plus one is always a null-terminated C string.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Fcodes\"">
<FV>
<E_F>
<T "Fcodes">
<P "html_h2">
<T "The predefined fcode values from the OpenFirmware specification are also us\
 ed as the internal \"compiled\" form within SmartFirmware. This eliminates any\
  machine-dependent compilers, debuggers, and so forth, and also uses less memo\
 ry but at some cost in performance. However, since this code is intended only \
 to boot machines, and most commonly RISC machines, it is extremely unlikely th\
 at any performance loss will be a serious problem.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Execution-tokens\"">
<FV>
<E_F>
<T "Execution tokens">
<P "html_h4" level:0 >
<T "The internal execution token of a Forth word is usually the same as the fco\
 des generated by an OpenFirmware tokenizer. Unfortunately, there is no provisi\
 on made in the OpenFirmware specification to generate Fcodes on-the-fly for an\
 y newly created words. The vendor-specific fcode range is too small and has to\
  be reset whenever a new Fcode program is loaded from a device.">
<P "Normal" level:0 >
<T "SmartFirmware allocates Fcodes that are well outside the fcode range specif\
 ied by OpenFirmware, specifically values 0x1000 and greater. These are then en\
 coded into the compiled form in a manner which allows easy decoding while rema\
 ining compliant to the OpenFirmware specification by using the vendor-specific\
  0x60 range as an \"escape\" value.">
<P "Normal" level:0 >
<T "The array ">
<T "xtoks" italic >
<T " in the ">
<T "Environ" italic >
<T " struct maintains the list of currently defined execution tokens. Each elem\
 ent points to an ">
<T "Entry" italic >
<T " defining a Forth word or method. The index of that element in ">
<T "xtoks" italic >
<T " is also its execution-token value minus 0x1000. Each ">
<T "Entry" italic >
<T " also stores its own execution token value.">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Initial-values\"">
<FV>
<E_F>
<T "Initial values">
<P "html_h4" level:0 >
<T "None of this is generally visible to the programmer except when initializin\
 g Forth words using arrays of the ">
<T "Initentry" italic >
<T " struct. If an fcode is explicitly specified in an ">
<T "Initentry" italic >
<T " for a word, that value is used as the execution token of that word. Otherw\
 ise">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "INVALID_FCODE" italic >
<E_F>
<T " must be specified and a new execution token greater than or equal to 0x100\
 0 is automatically generated (and never reused).">
<P "Normal" level:0 >
<T "^ka">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Tokenizing\"">
<FV>
<E_F>
<T "Tokenizing">
<P "html_h4" level:0 >
<T "The vendor-specific 0x60 and 0x70 fcode ranges are used internally to mark \
 certain control words for tokenizing. These are generally no-ops at runtime, b\
 ut are needed as place-holders to calculate offsets and ranges when tokenizing\
 .">
<P "Normal" level:0 >
<T "All vendor-specific ranges are only used internally in memory and are never\
  written out by the tokenizer. Fcode programs generated by the SmartFirmware t\
 okenizer are completely compatible with other vendors' implementations of Open\
 Firmware.">
<P "Normal" level:0 >
<end_eval_value>
>
*LINK /cgt/src/bin/of/docs/SFChapter2.aw
<T "link \"/cgt/src/bin/of/docs/SFChapter2.aw\" -docType \"200\" -appType \"Wor\
 ds_\"">
<FV>
<S_F fieldType:17>
<T "hyper_target \"Basics\"">
<FV>
<E_F>
<T "Basics">
<P "html_h1">
<T "This describes the design of SmartFirmware, to set a base for the customiza\
 tion descriptions in following chapters.">
<P "Normal">
<S_F fieldType:17>
<T "hyper_target \"Files\"">
<FV>
<E_F>
<T "Files">
<P "html_h2">
<T "The source files are separated into several directories. The upper level co\
 ntains files common to most platforms. Subdirectories are used for bus-specifi\
 c code, such as \"pci\", \"isa\", and \"scsi\", or for specific platform build\
  directories, such as \"unix\", \"i386\", and \"bebox\".">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Main-files\"">
<FV>
<E_F>
<T "Main files">
<P "html_h4">
<T "Makefile       # Unix makefile for various builds\ncour8x16.font  # default\
  font for machdep.c below\ncour16x23.font # optional larger font\ncour32x44.fo\
 nt # optional really huge font\n8x16.font      # another 8x16 font\n^ka\ndefs.\
 h         # essential definitions and types\nerrs.h         # error codes go h\
 ere\nlogo.h         # default 64x64x8 logo for CodeGen, Inc.\n^ka\nctype.h    \
     # simple versions of these files for \nstdlib.h       #    embedded use wh\
 en building ROM\nstring.h       #    images of SmartFirmware\n^ka\nadmin.c    \
     # OpenFirmware Administration commands\nclient.c       # OpenFirmware Clie\
 nt Interface\ncmdio.c        # command-line I/O & editing routines\ncontrol.c \
      # Forth and Fcode control flow words\ncpu.c          # template for build\
 ing /cpu node\ndeblock.c      # disk deblocking package\ndebug.c        # Fort\
 h debugging command group\ndevice.c       # device-path manipulation Forth wor\
 ds\ndisklbl.c      # disk label package\ndisplay.c      # display package and \
 terminal emulator\nerrs.c         # strings for error numbers go here\nexec.c \
         # Forth and fcode execution & parsing\nfailsafe.c     # failsafe I/O d\
 river for debugging\nfb.c           # frame-buffer package for display\nforth.\
 c        # Forth words that are not fcodes\nfuncs.c        # basic words that \
 are also fcodes\nfuncs64.c      # words to support 64-bit extensions\nmain.c  \
        # main() - perform OpenFirmware bootup\nmemory.c       # template for b\
 uilding /memory node\nnvedit.c       # on-screen script editor\nobptftp.c     \
  # BOOTP/TFTP package\nother.c        # other misc. OpenFirmware words\npackag\
 es.c     # basic package manipulation words\nroot.c         # template for bui\
 lding / node\nstdlib.c       # simple versions of standard C routines\nstlb.c \
         # software TLB to aid 32<->64-bit translations\nsun.c          # Forth\
  words compatible with Sun's OBP\ntable.c        # low-level data-structure ma\
 nipulation\ntoken.c        # OpenFirmware tokenizer & detokenizer\ntest-*     \
     # various regression test command files">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"Executable-loader-files\"">
<FV>
<E_F>
<T "Executable loader files">
<P "html_h4">
<T "The contents of subdirectory \"exe\" are as follows. It supports plug-in bi\
 nary image loaders.">
<P "Normal">
<T "coff.c         # COFF/ECOFF binary image loader \ndumpcoff.c     # test pro\
 gram to display COFF files\ndumpelf.c      # test program to display ELF files\
 \nelf.c          # ELF binary image loader\nelf64.c        # ELF (64-bit) bina\
 ry image loader\nexe.c          # plug-in binary image loader manager\nexe.h  \
         # header for plug-in binary image loaders\ngzip.c         # gunzip \"l\
 oader\" - needs freeware zlib\nloadfc.c       # Forth and Fcode loader">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"Filesystem-files\"">
<FV>
<E_F>
<T "Filesystem files">
<P "html_h4">
<T "The contents of subdirectory \"fs\" are as follows. It supports plug-in fil\
 esystem readers.">
<P "Normal">
<T "bsdpart.c      # BSD partition map loader\nbsdufs.c       # BSD FFS/UFS fil\
 esystem loader\ndos.h          # DOS FAT headers\ndosfat.c       # DOS FAT fil\
 esystem loader\ndospart.c      # DOS partition loader\nfs.c           # plug-i\
 n filesystem loader manager\nfs.h           # header for plug-in filesystem lo\
 aders\niso9660.c      # ISO-9660 CD-ROM filesystem loader">
<P "html_preformatted">
<T "ISA files">
<P "html_h4">
<T "The contents of subdirectory \"isa\" are as follows. This adds basic suppor\
 t for the PC-compatible ISA bus.">
<P "Normal">
<T "isa.c          # basic ISA bus driver package\nisa.h          # headers for\
  ISA devices\nkbd.c          # PC keyboard driver\nne2000.c       # NE2000-com\
 patible Ethernet card driver\nns16550.c      # serial port driver\nvga.c      \
     # VGA-compatible display driver">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"PCI-files\"">
<FV>
<E_F>
<T "PCI files">
<P "html_h4">
<T "The contents of subdirectory \"pci\" are as follows. This adds support for \
 the PCI bus.">
<P "Normal">
<T "dc21140.c      # dummy DEChip 21140 driver for testing\ndecether.c     # DE\
 Chip 21x4x ethernet driver\nfakepci.c      # dummy PCI driver for unix host\nf\
 akepci.h      # externs for dummy PCI routines\nncrscsi.c      # Symbios 53C8x\
 x SCSI driver\npci.c          # basic PCI bus driver package\npci.h          #\
  definitions specific to the PCI bus\npcialloc.c     # internal PCI allocation\
  routines\npcicode.c      # current list of PCI vendor/device IDs\npcidisp.c  \
     # generic PCI display driver\npciisa.c       # driver for various PCI-ISA \
 bridges">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"SCSI-files\"">
<FV>
<E_F>
<T "SCSI files">
<P "html_h4">
<T "The contents of subdirectory \"scsi\" are as follows, adding support for SC\
 SI buses.">
<P "Normal">
<T "scsi.c         # common routines useful for SCSI drivers\nscsi.h         # \
 headers of common SCSI routines\nscsidisk.c     # generic SCSI disk driver">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"Unix-files\"">
<FV>
<E_F>
<T "Unix files">
<P "html_h4">
<T "The contents of subdirectory \"unix\" are as follows. These files allow run\
 ning SmartFirmware under a standard Unix environment for testing and debugging\
 .">
<P "Normal">
<T "be-predefs.h   # pre-include definitions for BeOS\nbeapp.cc       # C++ fil\
 e to replace main.c for BeOS\nBeOS.proj      # MetroWerks project to build on \
 BeOS\nBeOS.rsrc      # resources for building under BeOS\nfakedisk.c     # fak\
 e disk driver - maps to Unix files\nmac.c          # Macintosh-specific code\n\
 machdep.h      # machine-dependent definitions\nmachdep.c      # machine-depen\
 dent code goes here\nMakefile       # build on Unix\nmw-predefs.h   # Metrower\
 ks prefix header file\nmw-project.hqx # Metrowerks project + other Mac files">
<P "html_preformatted">
<T "^ka">
<T "i" no-bold face:"Palatino" >
<T "386 files">
<P "html_h4">
<T "The contents of subdirectory \"i386\" are as follows. This supports SmartFi\
 rmware on standard i386-compatible PCs using the FreeBSD boot-loader. The boot\
 -loader provides a standard 32-bit environment for SmartFirmware to run under.\
  SmartFirmware takes over the hardware in place of the FreeBSD kernel and can \
 be booted directly off of a FreeBSD filesystem or floppy.">
<P "Normal">
<T "divdi3.c       # math runtime function from BSD\nisabase.c      # low-level\
  ISA support routines\nmachdep.c      # i386-specific code\nmachdep.h      # i\
 386-specific definitions\nMakefile       # i386 build on Unix\nmoddi3.c       \
 # math runtime function from BSD\npcibase.c      # low-level PCI support routi\
 nes\nqdivrem.c      # math runtime function from BSD\nquad.h         # math ru\
 ntime function from BSD\nstart.S        # i386 startup assembly for launching\\
 nudivdi3.c      # math runtime function from BSD\numoddi3.c      # math runtim\
 e function from BSD">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"BeBox-files\"">
<FV>
<E_F>
<T "BeBox files">
<P "html_h4">
<T "The contents of subdirectory \"bebox\" are as follows. This supports SmartF\
 irmware running on the dual-PowerPC 603e BeBox platform. It is booted in place\
  of the BeOS kernel off of a floppy and takes over the hardware.">
<P "Normal">
<T "be-predefs.h   # pre-include definitions for BeBox\nbebox.h        # BeBox-\
 specific definitions\nBeBox.proj     # MetroWerks project for BeBox\nmachdep.c\
       # BeBox-specific code\nmachdep.h      # more BeBox-specific definitions\\
 npcibase.c      # low-level PCI support routines">
<P "html_preformatted">
<T "SmartFirmware is designed so that it is easy to add or remove packages from\
  a particular build, simply by modifying the lists of desired packages and wor\
 d-sets in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " and then ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Makefile" italic >
<E_F>
<T " to compile and link the desired files. It is a good idea to create custom \
 ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " files by copying another project's versions for a new project, then editin\
 g them for the new platform.">
<P "Normal">
<T "Each OpenFirmware package may be implemented as Forth code or as C code. Sm\
 artFirmware implements almost everything in C, with the exception of the defau\
 lt boot script and a few Forth words for ease of tokenizing.">
<P "Normal">
<T "Headers">
<P "html_h2">
<T "All the major data structures and types are defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " , with some machine dependent definitions going in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h " italic >
<E_F>
<T ". The comments in the files should be reasonably self-explanatory. Addition\
 al bus or subsystem-specific code is under various subdirectories, such as ">
<T "fs/fs.h" italic >
<T " or ">
<T "isa/isa.h" italic >
<T ".">
<P "Normal">
<T "^ka">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Word-sizes\"">
<FV>
<E_F>
<T "Word sizes">
<P "html_h4">
<T "The sizes of various type names must be specified in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h" italic >
<E_F>
<T " . They are typically 8, 16, and 32 bits signed and unsigned values. Howeve\
 r SmartFirmware can support 64-bit integer operations and Forth words only if \
 the C compiler supports them, such as some versions of the Gnu C compiler gcc.\
 ">
<P "Normal">
<T "^ka">
<P "Normal">
<T "A ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " is typically the standard word size of a platform. It must be large enough\
  to hold a pointer such as \"">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "ch" italic >
<E_F>
<T "ar">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "*" italic >
<E_F>
<T " \". However it may be larger than a pointer for those compilers that suppo\
 rt, say, 32-bit pointers but 64-bit integers.">
<P "Normal">
<T "It is possible to build SmartFirmware with 32-bit ">
<T "Cells" italic >
<T " but with some 64-bit integer support.some 64-bit support is turned on if t\
 he macro ">
<T "__LONGLONG" italic >
<T " is defined to be the type of the 64-bit integer, such as \"">
<T "long long" italic >
<T "\" for gcc. 64-bit ">
<T "Cells" italic >
<T " are turned on if the macro ">
<T "SF_64BIT" italic >
<T " is defined.">
<P "Normal">
<T "Commands">
<P "html_h2">
<T "Commands are simply C functions linked into the Forth environment. They are\
  designed to allow using them in both ways with fairly little effort.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Declaring\"">
<FV>
<E_F>
<T "Declaring">
<P "html_h4">
<T "A C function that implements a Forth word is defined as follows;">
<P "Normal">
<T "Retcode cfunc(Environ *e) { ... }">
<P "html_preformatted">
<T "A set of macros in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " make declaring this somewhat easier for large numbers of ">
<T "Commands" italic >
<T ":">
<P "Normal">
<T "C(name) {..}  # define a local static Command\nEC(name);     # declare an e\
 xtern for a Command\nCC(name){..}  # define a globally visible Command">
<P "html_preformatted">
<T "These macros declare and define routines such as ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "cfunc" italic >
<E_F>
<T " taking one argument, and ">
<T "Environ*" italic >
<T " which is named ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "e" italic >
<E_F>
<T ". A typedef for ">
<T "Command" italic >
<T " is also declared to handle pointers to these functions.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Calling\"">
<FV>
<E_F>
<T "Calling">
<P "html_h4">
<T "An ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Environ" italic >
<E_F>
<T " is passed by pointer to all C functions to keep from cluttering up the cod\
 e with a lot global variables. It also makes it much easier to support a threa\
 d-safe implementation in the future. Static global variables and data should o\
 nly be used for initialization.">
<P "Normal">
<T "All C functions must return either ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "NO_ERROR" italic >
<E_F>
<T " or a specific error listed in the enum ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Retcode" italic >
<E_F>
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " . This mechanism is used to handle Forth exceptions without using">
<T "setjmp/longjmp" italic >
<T ". A C function that calls other C routines must check the return codes for \
 any error to either handle the error itself or to propagate that error to its \
 caller.">
<P "Normal">
<T "The Retcode errors are translated to strings by the routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "err2str" italic >
<E_F>
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "exec.c" italic >
<E_F>
<T " when any error must be reported to the user. It may be easier to directly \
 use the routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "cprintf" italic >
<E_F>
<T " to display error messages, but this is only useful if the console has been\
  probed and installed. The error codes themselves are defined in ">
<T "errs.h" italic >
<T ", and ">
<T "errs.c" italic >
<T " must be kept synchronized with it.">
<P "Normal">
<T "Stacks">
<P "html_h2">
<T "The Forth data and return stacks are manipulated using macros defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " . The stack elements are of the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " type declared in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h" italic >
<E_F>
<T " , which is usually 32 or 64 bits wide. These stacks are maintained as simp\
 le arrays within the ">
<T "Environ" italic >
<T " struct with pointers to the current top of each stack.">
<P "Normal">
<T "The data stack is used to pass arguments and perform all the standard Forth\
  functions. The return stack is used to maintain a call-chain of Forth words a\
 s they are executed at runtime. It is also used to maintain loop variables for\
  the looping control words. This can get messy to manage the return stack for \
 certain words, but this sort of code is well-commented.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Range-checks\"">
<FV>
<E_F>
<T "Range checks">
<P "html_h4">
<T "The following four macros are used to check the stack ranges. The first two\
  are intended for use in your own ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "if" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "while" italic >
<E_F>
<T " statements. The last two are more generally used throughout the code to ch\
 eck the ranges and return an appropriate ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Retcode." italic >
<E_F>
<P "Normal">
<T "CKSP(e, min, max)       # check data stack\nCKRETSP(e, min, max)    # check\
  return stack\nIFCKSP(e, min, max)     # check & return error\nIFCKRETSP(e, mi\
 n, max)  # check & return error">
<P "html_preformatted">
<T "These are used to increment and decrement the respective stack pointers. Ra\
 nges are not checked. They are used by the other macros and are generally not \
 used directly.">
<P "Normal">
<T "BUMPSP(e)      # increment data stack ptr by one\nDROPSP(e)      # decremen\
 t data stack ptr by one\nBUMP_RETSP(e)  # increment return stack ptr\nDROP_RET\
 SP(e)  # decrement return stack ptr">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"Push-and-Pop\"">
<FV>
<E_F>
<T "Push & Pop">
<P "html_h4">
<T "These are used to access the top element of the stacks (a ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " ). Ranges are not checked.">
<P "Normal">
<T "TOP(e)   # get Cell currently on top of data stack\nRTOP(e)  # get Cell on \
 top of return stack">
<P "html_preformatted">
<T "These are used to get to a specific (nth) element on the stack without chec\
 king to see if it is in range. The topmost element on the stack is numbered ze\
 ro (0), the element below it is one (1), and so on.">
<P "Normal">
<T "STACK(e, n)   # get nth element on data stack">
<P "html_preformatted">
<T "These push a value on top of the data stack without checking for a range er\
 ror. The second form is used to cast a pointer value into a pointer-sized inte\
 ger before pushing it on the stack. It is generally used to eliminate warnings\
  from some compilers.">
<P "Normal">
<T "PUSH(e, val)   # push val on top of data stack\nPUSHP(e, val)  # push val a\
 fter casting it from a pointer">
<P "html_preformatted">
<T "These simply drop the stack, either by one element, or by a count (n). Rang\
 es are not checked.">
<P "Normal">
<T "DROP(e)       # drop the top element on the data stack\nDROPN(e, n)   # dro\
 p the top n elements on the stack">
<P "html_preformatted">
<T "These pop the top of the stack into the specified variable. The second form\
  allows inserting a typecast to cast the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " to a pointer such as a ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Byte*" italic >
<E_F>
<T " . The first assumes the variable is of type ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " . The last allows casting to any integer type. The first two may be overri\
 dden by custom macros to handle 64-bit to 32-bit (and 32 to 64) pointer transl\
 ations.">
<P "Normal">
<T "POP(e, var)               # var = TOP(e); DROP(e);\nPOPT(e, var, ptrtype)  \
    # var = (ptrtype)TOP(e); DROP(e);\nPOPTYPE(e, var, inttype)  # var = (intty\
 pe)TOP(e); DROP(e);">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"Return-stack\"">
<FV>
<E_F>
<T "Return stack">
<P "html_h4">
<T "These do everything the above five macros do, only they operate on the retu\
 rn stack.">
<P "Normal">
<T "RSTACK(e, n)\nRPUSH(e, val)\nRDROP(e)\nRDROPN(e, n)\nRPOP(e, var)">
<P "html_preformatted">
<T "Memory">
<P "html_h2">
<T "Memory is handled in as much a C fashion as possible. That is, except to mi\
 mic certain Forth behaviors, SmartFirmware uses ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "free" italic >
<E_F>
<T " to manage memory. Simple versions of these routines are provided in ">
<T "stdlib.c" italic >
<T " that allocate and free from a large fixed-size chunk of memory. An additio\
 nal routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_malloc" italic >
<E_F>
<T " is used to initialize the memory pool used by ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "free" italic >
<E_F>
<T " . This version of ">
<T "malloc" italic >
<T " may be used if there is no suitable ">
<T "malloc" italic >
<T " available in the runtime environment of a target or compiler.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Initializing\"">
<FV>
<E_F>
<T "Initializing">
<P "html_h4">
<T "At start-up, the routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_initialize" italic >
<E_F>
<T " is called to do any machine-dependent setup. This routine, once it has set\
 up and initialized any appropriate hardware, calls ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_malloc" italic >
<E_F>
<T " with a chunk of memory to be used for the malloc pool, the size of which w\
 as defined by the macro ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MALLOC_POOL" italic >
<E_F>
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "<defs.h" italic >
<E_F>
<T " >.">
<P "Normal">
<T "Once ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " is ready, then an ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Environ" italic >
<E_F>
<T " is created for the Forth world. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_environ" italic >
<E_F>
<T " is used to initialize an ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Environ" italic >
<E_F>
<T " , which in turn calls ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " to allocate a pool of ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MEM_SIZE" italic >
<E_F>
<T " bytes for the Forth world. This macro is defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "<defs.h>" italic >
<E_F>
<T " , and the call to ">
<T "init_environ" italic >
<T " is in ">
<T "main.c" italic >
<T ".">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Allocating\"">
<FV>
<E_F>
<T "Allocating">
<P "html_h4">
<T "All the basic data structures (">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Entry, Table, Package, Instance, and Environ" italic >
<E_F>
<T " ) are allocated and freed by appropriately named routines in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "table.c" italic >
<E_F>
<T " . The externs for these routines are also in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " . Objects are always allocated from the heap and not the stack to keep thi\
 ngs simple, must always be created with ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "new_object" italic >
<E_F>
<T " , and freed with ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "delete_object" italic >
<E_F>
<T " .">
<P "Normal">
<T "Temporary string buffers are frequently placed on the stack for convenience\
 . Other objects are simply ">
<T "malloc" italic >
<T "-ed and ">
<T "free" italic >
<T "-d as needed.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Debugging\"">
<FV>
<E_F>
<T "Debugging">
<P "html_h4">
<T "If the macro DEBUG_MALLOC is defined, the malloc code will switch on additi\
 onal memory debugging code which does simple checks to catch overruning the he\
 ad or tail of ">
<T "malloc" italic >
<T "-ed objects, and verifying that ">
<T "free" italic >
<T "-d blocks are not used and that ">
<T "malloc" italic >
<T "-ed objects are initialized before use.">
<P "Normal">
<T "Strings">
<P "html_h2">
<T "The OpenFirmware specification requires handling at least the Pascal and Fo\
 rth style strings. Implementing SmartFirmware in C also requires handling C st\
 rings in a reasonably seamless fashion.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"String-types\"">
<FV>
<E_F>
<T "String types">
<P "html_h4">
<T "There are three sorts of strings managed within the SmartFirmware software.\
  There are C strings, Pascal strings, and Forth strings. C strings (">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Byte*" italic >
<E_F>
<T " ) are null-terminated arrays of characters. Pascal strings (">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "uByte*" italic >
<E_F>
<T " ) use the first byte of the string array to store the length and are thus \
 limited to 255 bytes in most implementations. Forth strings are two separate a\
 rray and length values (">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Byte*, Int" italic >
<E_F>
<T " ) and are managed as such.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Pascal-strings\"">
<FV>
<E_F>
<T "Pascal strings">
<P "html_h4">
<T "SmartFirmware uses the Pascal string as its internal canonical form when st\
 oring a string in a data structure. When using a string in a function, it is c\
 onverted to a Forth string using the routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "setstrlen" italic >
<E_F>
<T " defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "table.c" italic >
<E_F>
<T " , which takes a string in any of the three forms and returns a string adju\
 sted to be in Forth style, with the actual length returned in another paramete\
 r.">
<P "Normal">
<T "Forth strings">
<P "html_h4">
<T "Forth strings are then passed to most other C routines. If it takes both a \
 ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Byte*" italic >
<E_F>
<T " and an ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Int" italic >
<E_F>
<T " parameter, it usually expects a Forth string. Routines taking both argumen\
 ts always call ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "setstrlen" italic >
<E_F>
<T " in case the strings are in C or Pascal form.">
<P "Normal">
<T "This makes it very easy to pass in C strings or Pascal strings by using the\
  length field set to one of two magic negative values, as defined by the macro\
 s ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "CSTR" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "PSTR" italic >
<E_F>
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " . Anytime a C string is passed to a routine, simply pass in a length of">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "CSTR" italic >
<E_F>
<T " and ">
<T "setstrlen" italic >
<T " takes it from there.">
<P "Normal">
<T "Copying strings">
<P "html_h4">
<T "The routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "lstrdup" italic >
<E_F>
<T " , (also defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "table.c" italic >
<E_F>
<T " ) with its associated macros ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "cstrdup" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "pstrdup" italic >
<E_F>
<T " , allow creating and copying any form of string using ">
<T "malloc" italic >
<T ". ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "lstrdup" italic >
<E_F>
<T " is used when the type of string is unknown but a length parameter is avail\
 able. Otherwise, the type of string determines the right macro to use: ">
<T "cstrdup" italic >
<T " to copy C strings, and ">
<T "pstrdup" italic >
<T " to copy Pascal strings. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "lstrdup" italic >
<E_F>
<T " always returns a null-terminated Pascal string allocated using ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " , so it may be freed by passing the pointer to ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "free" italic >
<E_F>
<T " . The returned pointer plus one is always a null-terminated C string.">
<P "Normal">
<T "Fcodes">
<P "html_h2">
<T "The predefined fcode values from the OpenFirmware specification are also us\
 ed as the internal \"compiled\" form within SmartFirmware. This eliminates any\
  machine-dependent compilers, debuggers, and so forth, and also uses less memo\
 ry but at some cost in performance. However, since this code is intended only \
 to boot machines, and most commonly RISC machines, it is extremely unlikely th\
 at any performance loss will be a serious problem.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Execution-tokens\"">
<FV>
<E_F>
<T "Execution tokens">
<P "html_h4">
<T "The internal execution token of a Forth word is usually the same as the fco\
 des generated by an OpenFirmware tokenizer. Unfortunately, there is no provisi\
 on made in the OpenFirmware specification to generate Fcodes on-the-fly for an\
 y newly created words. The vendor-specific fcode range is too small and has to\
  be reset whenever a new Fcode program is loaded from a device.">
<P "Normal">
<T "SmartFirmware allocates Fcodes that are well outside the fcode range specif\
 ied by OpenFirmware, specifically values 0x1000 and greater. These are then en\
 coded into the compiled form in a manner which allows easy decoding while rema\
 ining compliant to the OpenFirmware specification by using the vendor-specific\
  0x60 range as an \"escape\" value.">
<P "Normal">
<T "The array ">
<T "xtoks" italic >
<T " in the ">
<T "Environ" italic >
<T " struct maintains the list of currently defined execution tokens. Each elem\
 ent points to an ">
<T "Entry" italic >
<T " defining a Forth word or method. The index of that element in ">
<T "xtoks" italic >
<T " is also its execution-token value minus 0x1000. Each ">
<T "Entry" italic >
<T " also stores its own execution token value.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Initial-values\"">
<FV>
<E_F>
<T "Initial values">
<P "html_h4">
<T "None of this is generally visible to the programmer except when initializin\
 g Forth words using arrays of the ">
<T "Initentry" italic >
<T " struct. If an fcode is explicitly specified in an ">
<T "Initentry" italic >
<T " for a word, that value is used as the execution token of that word. Otherw\
 ise">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "INVALID_FCODE" italic >
<E_F>
<T " must be specified and a new execution token greater than or equal to 0x100\
 0 is automatically generated (and never reused).">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Tokenizing\"">
<FV>
<E_F>
<T "Tokenizing">
<P "html_h4">
<T "The vendor-specific 0x60 and 0x70 fcode ranges are used internally to mark \
 certain control words for tokenizing. These are generally no-ops at runtime, b\
 ut are needed as place-holders to calculate offsets and ranges when tokenizing\
 .">
<P "Normal">
<T "All vendor-specific ranges are only used internally in memory and are never\
  written out by the tokenizer. Fcode programs generated by the SmartFirmware t\
 okenizer are completely compatible with other vendors' implementations of Open\
 Firmware.">
<P "Normal">
<E_F>
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_34" evenHeader:Inherit firstHeader:Inherit evenFo\
 oter:Inherit sectNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:0>
<S_F fieldType:3>
<T "series \"main\"">
<FV>
<T "3. ">
<E_F>
<S_F fieldType:6 date:908505750 docType:200 appType:1 outDated
<start_eval_value>
<S_F fieldType:17>
<T "hyper_target \"Machine-dependencies\"">
<FV>
<E_F>
<T "Machine dependencies">
<P "html_h1" level:0 >
<T "A new port should be managed simply by copying and modifying ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " from some existing port. Some samples for these machine-dependent files ma\
 y be found under the ">
<T "unix, i386, " italic >
<T "and ">
<T "bebox" italic >
<T " subdirectories.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"machdep.h\"">
<FV>
<E_F>
<T "machdep.h">
<P "html_h2">
<T "This file contains all the types and definitions required to properly descr\
 ibe the target host. They must all be specified, and the correct types for the\
  required word-widths must be selected. Most will probably not need to be chan\
 ged. The file is well-commented and more up-to-date than this document, so onl\
 y the more important portions are covered here.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Macros\"">
<FV>
<E_F>
<T "Macros">
<P "html_h4" level:0 >
<T "Macros that control the switching on of certain features may be defined wit\
 hin ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h" italic >
<E_F>
<T " or may be added to the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Makefile" italic >
<E_F>
<T " --whichever is more convenient. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "LITTLE_ENDIAN" italic >
<E_F>
<T " must be defined if your system does not do it for you. The default is big-\
 endian, such as for the Motorola 680x0 processors.">
<P "Normal" level:0 >
<T "The amount of memory to be used by the SmartFirmware image is also defined \
 here with ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MALLOC_POOL" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MEM_SIZE" italic >
<E_F>
<T ". All memory including that for the Forth environment is allocated out of t\
 he ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MALLOC_POOL" italic >
<E_F>
<T " , so it must be large enough to allocate ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MEM_SIZE" italic >
<E_F>
<T " as well as all other macros. The defaults are defined as fractions of the \
 total ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MALLOC_POOL" italic >
<E_F>
<T ".">
<P "Normal" level:0 >
<T "The default values for the various stack sizes are safe to change to larger\
  values but be careful when making them smaller. Some of the other macros are \
 already at their minimum value as specified in the OpenFirmware standard, so t\
 hey should only be increased if necessary.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Integral-types\"">
<FV>
<E_F>
<T "Integral types">
<P "html_h4" level:0 >
<T "A set of typedefs define the word sizes for the target host and the sizes u\
 sed by the Forth environment. Typically, only the former needs to be ported to\
  a host, with some caveats as follow.">
<P "Normal" level:0 >
<T "A ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " and a ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Ptr" italic >
<E_F>
<T " must both be large enough to hold a pointer of any type.">
<P "Normal" level:0 >
<T "DoubleNums require 64-bit support from the target compiler. If the compiler\
  supports 64-bit integers, the macro ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "__LONGLONG" italic >
<E_F>
<T " must be defined to that type (usually ">
<T "long long" italic >
<T "). This macro may be defined in CFLAGS in the ">
<T "Makefile" italic >
<T " or at the top of ">
<T "machdep.h." italic >
<P "Normal" level:0 >
<T "The various ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "*_SIZE" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "*_MASK" italic >
<E_F>
<T " macros must be defined correctly. Unfortunately, there is no easy way to r\
 eliably extract this information from a C compiler or standard header files, s\
 o this must be done by hand.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Fonts\"">
<FV>
<E_F>
<T "Fonts">
<P "html_h4" level:0 >
<T "Finally there are some macros that describe the built-in default system fon\
 t. These should only be changed if either of the shipped fonts are not going t\
 o be used. If so, at least all the printable ASCII characters must be included\
  in the font, from '  ' (space) to '">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "~" bold >
<E_F>
<T " ' (tilde). 8-bit characters may also be included if desired.">
<P "Normal" level:0 >
<T "The OpenFirmware specification requires that the first scan-line of a font \
 glyphs' bitmap be all zeros, and that the last scan-line must not be included \
 in the bitmap, but is instead assumed to be all zeros. All this affects FONT_H\
 EIGHT, which SmartFirmware uses as the real height of the font including the v\
 irtual bottom row of zeros.">
<P "Normal" level:0 >
<T "A struct \"eself\" may be created if the port needs additional data stored \
 within the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Environ" italic >
<E_F>
<T " struct defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " . This field may be initialized and filled in when needed by the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_init_args" italic >
<E_F>
<T " routine described below.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"machdep.c\"">
<FV>
<E_F>
<T "machdep.c">
<P "html_h2">
<T "This file contains code that must be ported to the target host, such as cod\
 e to access registers, memory tests, non-volatile RAM, timers, and so on. The \
 key routines that must be ported are named ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_*" italic >
<E_F>
<T " . There are some other Forth words in this file, but they are unlikely to \
 need to be modified. It is also well commented, so the following notes serve o\
 nly as an addendum rather than a replacement for ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " .">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Memory-initialization\"">
<FV>
<E_F>
<T "Memory initialization">
<P "html_h4" level:0 >
<T "The first routine to port is ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_initialize" italic >
<E_F>
<T " since it must first initialize ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " so that the rest of SmartFirmware can be initialized. The default version \
 simply creates an enormous static block of memory, which should work if the ta\
 rget C compiler's runtime environment supports large static blocks of memory. \
 (This block does not have to be initialized--">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_malloc" italic >
<E_F>
<T " will take care of that.)">
<P "Normal" level:0 >
<T "The globals ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "g_machine_memory" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "g_machine_memory_size" italic >
<E_F>
<T " must also be initialized to the start of RAM and the amount of real RAM in\
  the machine. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_malloc" italic >
<E_F>
<T " is called with only a portion of this memory (">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MALLOC_POOL" italic >
<E_F>
<T " defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "<defs.h>" italic >
<E_F>
<T " ), to leave the rest available for the client interface.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Debug-output\"">
<FV>
<E_F>
<T "Debug output">
<P "html_h4" level:0 >
<T "The ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "dprintf" italic >
<E_F>
<T " routine is useful to bring up a port of SmartFirmware. It is typically def\
 ined to use the failsafe I/O routines defined later in the file. The failsafe \
 I/O routines typically use a serial port for I/O, such as for the i386 and BeB\
 ox ports.">
<P "Normal" level:0 >
<T "failsafe_read" italic >
<T " and ">
<T "failsafe_write" italic >
<T " routines should also be provided, so that if a console device cannot be ac\
 cessed for some reason, at least the error messages won't get dropped in the b\
 it-bucket. These simply use a hard-wired serial port for fall-back I/O in the \
 i386 and BeBox ports, and stdio under Unix.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Memory-and-IO-access\"">
<FV>
<E_F>
<T "Memory and I/O access">
<P "html_h4" level:0 >
<T "The memory and I/O access routines are required to get/set unaligned words \
 from memory. Similar routines are used to access device registers perhaps thro\
 ugh I/O space. The generic versions shipped with the default ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " may ben sufficient for most needs, but they should be checked to be sure. \
 The versions for the i386 and BeBox ports may be more instructive.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Timers\"">
<FV>
<E_F>
<T "Timers">
<P "html_h4" level:0 >
<T "The timing routines in SmartFirmware use ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_gettime" italic >
<E_F>
<T " to do the real work. If the target compiler has a version of the standard \
 Unix function">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "gettimeoday" italic >
<E_F>
<T " in its runtime library, this routine will most likely not need to be modif\
 ied. Otherwise, some other method must be used.">
<P "Normal" level:0 >
<T "It is possible to bring up a new port without having to manage timers and i\
 nterrupts at all. Simply defined the routine ">
<T "u_sleep" italic >
<T " to be a simple timed loop, and enough of SmartFirmware will run to bring u\
 p the port. Then the proper timer code can be turned on once ">
<T "dprintf" italic >
<T " is available to debug it.">
<P "Normal" level:0 >
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_gettime" italic >
<E_F>
<T " is used when pausing for a specified time and for handling alarms by using\
  polling loops. Real timer interrupts could be used, but SmartFirmware is not \
 interrupt-safe, so some method of synchronizing interrupt tasks would still ne\
 ed to be used. If real interrupts are necessary, some of the routines that use\
  ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_gettime" italic >
<E_F>
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " may also need to be modified.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Device-probing\"">
<FV>
<E_F>
<T "Device probing">
<P "html_h4" level:0 >
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_probe_all" italic >
<E_F>
<T " is used to probe the hardware at start-up before a prompt would be display\
 ed. This will almost certainly need to be customized. One of the things it may\
  do is identify a console device. The i386 and BeBox ports probe for both a PC\
 I and an ISA bus.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Binary-images\"">
<FV>
<E_F>
<T "Binary images">
<P "html_h4" level:0 >
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_init_program" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_go" italic >
<E_F>
<T " are used to setup and launch a machine-dependent binary image. The default\
 s assume that the image is simply a pointer to the start of a C function and c\
 an simply be called using a C pointer-to-function. This code may in turn call \
 the plug-in binary image loader defined under the ">
<T "fs" italic >
<T " subdirectory by using the ">
<T "exec_is_exec" italic >
<T " and ">
<T "exec_load" italic >
<T " routines. The actual binary images supported are listed here in the global\
  variable ">
<T "g_exec_list." italic >
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Client-interface-callback\"">
<FV>
<E_F>
<T "Client-interface callback">
<P "html_h4" level:0 >
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_callback" italic >
<E_F>
<T " is used for client-interface callbacks. The default assumes that the callb\
 ack is simply a pointer to a C function and calls it. This does not need to be\
  ported if the client-interface will not be used.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Built-in-words-and-packages\"">
<FV>
<E_F>
<T "Built-in words and packages">
<P "html_h4" level:0 >
<T "This file also contains several global lists which are used to configure th\
 e modules and packages to be linked into the final image. These lists are call\
 ed ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_list" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "install_list" italic >
<E_F>
<T " , for a list of pointers to ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Initentry*" italic >
<E_F>
<T " tables and a list of pointers to initialization ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Commands" italic >
<E_F>
<T " .">
<P "Normal" level:0 >
<T "Each module that wishes to install a set of words into the global Forth dic\
 tionary creates an initialization list at the bottom of the file (see ">
<T "funcs.c" italic >
<T " or ">
<T "devies.c" italic >
<T " for an example). Each package that needs more complex initialization creat\
 es a function that does the work. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " determines which of these will actually be linked into the final image. Th\
 is process is described in more detail in ">
<S_F fieldType:16 editable
<start_eval_value>
<T "Creating new words">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"Creating-new-words\" -pass \"\" -text \"Cre\
 ating new words\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "Creating new words" underline color:"HtmlLinkDefault@" >
<E_F>
<T ".">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Built-in-drivers\"">
<FV>
<E_F>
<T "Built-in drivers">
<P "html_h4" level:0 >
<T "Drivers for built-in PCI devices may also be specified using the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "pci_drivers" italic >
<E_F>
<T " global list. This is used by pci.c when probing the PCI bus. Built-in ISA \
 drivers are handled similarly by defining the devices in the global ">
<T "isa_devices." italic >
<T " Built-in filesystem support may be specified by the global ">
<T "g_filesys." italic >
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Non-volatile-RAM\"">
<FV>
<E_F>
<T "Non-volatile RAM">
<P "html_h4" level:0 >
<T "Non-volatile memory (NVRAM) is managed here by routines that read a static \
 array to initialize or use to set default values. The sample code has code tha\
 t ignores all writes. This should be sufficient to bootstrap a preliminary por\
 t of SmartFirmware then adding full NVRAM support later. A static array should\
  still be used as a fall-back in case NVRAM is inaccessible or corrupt.">
<P "Normal" level:0 >
<T "The initial definitions for \"input-device\" and \"output-device\" in NVRAM\
  are important when bringing up a new port of SmartFirmware. They should first\
  be defined as \"/failsafe\" to bring up a console using the fall-back failsaf\
 e I/O routines. (This driver is defined in the file ">
<T "failsafe.c." italic >
<T ") Once devices are properly probed and visible to the system in the device \
 tree, then these definitions may be changed to the standard \"keyboard\" and \\
 "screen\" aliases, with the actual devices for the aliases possibly being sele\
 cted by ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_probe_all" italic >
<E_F>
<T " .">
<P "Normal" level:0 >
<T "The routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_init_args" italic >
<E_F>
<T " is called from ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "main()" italic >
<E_F>
<T " once the Forth environment has been created and initialized. At this point\
  Forth is ready to run but no devices have been probed. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_init_args" italic >
<E_F>
<T " is passed the arguments that were passed to ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "main" italic >
<E_F>
<T " if they are useful for a particular port. It may initialize the \"self\" f\
 ield of its ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Environ" italic >
<E_F>
<T " *parameter if desired.">
<P "Normal" level:0 >
<end_eval_value>
>
*LINK /cgt/src/bin/of/docs/SFChapter3.aw
<T "link \"/cgt/src/bin/of/docs/SFChapter3.aw\" -docType \"200\" -appType \"Wor\
 ds_\"">
<FV>
<S_F fieldType:17>
<T "hyper_target \"Machine-dependencies\"">
<FV>
<E_F>
<T "Machine dependencies">
<P "html_h1">
<T "A new port should be managed simply by copying and modifying ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " from some existing port. Some samples for these machine-dependent files ma\
 y be found under the ">
<T "unix, i386, " italic >
<T "and ">
<T "bebox" italic >
<T " subdirectories.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"machdep.h\"">
<FV>
<E_F>
<T "machdep.h">
<P "html_h2">
<T "This file contains all the types and definitions required to properly descr\
 ibe the target host. They must all be specified, and the correct types for the\
  required word-widths must be selected. Most will probably not need to be chan\
 ged. The file is well-commented and more up-to-date than this document, so onl\
 y the more important portions are covered here.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Macros\"">
<FV>
<E_F>
<T "Macros">
<P "html_h4">
<T "Macros that control the switching on of certain features may be defined wit\
 hin ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.h" italic >
<E_F>
<T " or may be added to the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Makefile" italic >
<E_F>
<T " --whichever is more convenient. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "LITTLE_ENDIAN" italic >
<E_F>
<T " must be defined if your system does not do it for you. The default is big-\
 endian, such as for the Motorola 680x0 processors.">
<P "Normal">
<T "The amount of memory to be used by the SmartFirmware image is also defined \
 here with ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MALLOC_POOL" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MEM_SIZE" italic >
<E_F>
<T ". All memory including that for the Forth environment is allocated out of t\
 he ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MALLOC_POOL" italic >
<E_F>
<T " , so it must be large enough to allocate ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MEM_SIZE" italic >
<E_F>
<T " as well as all other macros. The defaults are defined as fractions of the \
 total ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MALLOC_POOL" italic >
<E_F>
<T ".">
<P "Normal">
<T "The default values for the various stack sizes are safe to change to larger\
  values but be careful when making them smaller. Some of the other macros are \
 already at their minimum value as specified in the OpenFirmware standard, so t\
 hey should only be increased if necessary.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Integral-types\"">
<FV>
<E_F>
<T "Integral types">
<P "html_h4">
<T "A set of typedefs define the word sizes for the target host and the sizes u\
 sed by the Forth environment. Typically, only the former needs to be ported to\
  a host, with some caveats as follow.">
<P "Normal">
<T "A ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Cell" italic >
<E_F>
<T " and a ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Ptr" italic >
<E_F>
<T " must both be large enough to hold a pointer of any type.">
<P "Normal">
<T "DoubleNums require 64-bit support from the target compiler. If the compiler\
  supports 64-bit integers, the macro ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "__LONGLONG" italic >
<E_F>
<T " must be defined to that type (usually ">
<T "long long" italic >
<T "). This macro may be defined in CFLAGS in the ">
<T "Makefile" italic >
<T " or at the top of ">
<T "machdep.h." italic >
<P "Normal">
<T "The various ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "*_SIZE" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "*_MASK" italic >
<E_F>
<T " macros must be defined correctly. Unfortunately, there is no easy way to r\
 eliably extract this information from a C compiler or standard header files, s\
 o this must be done by hand.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Fonts\"">
<FV>
<E_F>
<T "Fonts">
<P "html_h4">
<T "Finally there are some macros that describe the built-in default system fon\
 t. These should only be changed if either of the shipped fonts are not going t\
 o be used. If so, at least all the printable ASCII characters must be included\
  in the font, from '  ' (space) to '">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "~" bold >
<E_F>
<T " ' (tilde). 8-bit characters may also be included if desired.">
<P "Normal">
<T "The OpenFirmware specification requires that the first scan-line of a font \
 glyphs' bitmap be all zeros, and that the last scan-line must not be included \
 in the bitmap, but is instead assumed to be all zeros. All this affects FONT_H\
 EIGHT, which SmartFirmware uses as the real height of the font including the v\
 irtual bottom row of zeros.">
<P "Normal">
<T "A struct \"eself\" may be created if the port needs additional data stored \
 within the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Environ" italic >
<E_F>
<T " struct defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " . This field may be initialized and filled in when needed by the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_init_args" italic >
<E_F>
<T " routine described below.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"machdep.c\"">
<FV>
<E_F>
<T "machdep.c">
<P "html_h2">
<T "This file contains code that must be ported to the target host, such as cod\
 e to access registers, memory tests, non-volatile RAM, timers, and so on. The \
 key routines that must be ported are named ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_*" italic >
<E_F>
<T " . There are some other Forth words in this file, but they are unlikely to \
 need to be modified. It is also well commented, so the following notes serve o\
 nly as an addendum rather than a replacement for ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " .">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Memory-initialization\"">
<FV>
<E_F>
<T "Memory initialization">
<P "html_h4">
<T "The first routine to port is ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_initialize" italic >
<E_F>
<T " since it must first initialize ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "malloc" italic >
<E_F>
<T " so that the rest of SmartFirmware can be initialized. The default version \
 simply creates an enormous static block of memory, which should work if the ta\
 rget C compiler's runtime environment supports large static blocks of memory. \
 (This block does not have to be initialized--">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_malloc" italic >
<E_F>
<T " will take care of that.)">
<P "Normal">
<T "The globals ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "g_machine_memory" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "g_machine_memory_size" italic >
<E_F>
<T " must also be initialized to the start of RAM and the amount of real RAM in\
  the machine. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_malloc" italic >
<E_F>
<T " is called with only a portion of this memory (">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "MALLOC_POOL" italic >
<E_F>
<T " defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "<defs.h>" italic >
<E_F>
<T " ), to leave the rest available for the client interface.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Debug-output\"">
<FV>
<E_F>
<T "Debug output">
<P "html_h4">
<T "The ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "dprintf" italic >
<E_F>
<T " routine is useful to bring up a port of SmartFirmware. It is typically def\
 ined to use the failsafe I/O routines defined later in the file. The failsafe \
 I/O routines typically use a serial port for I/O, such as for the i386 and BeB\
 ox ports.">
<P "Normal">
<T "failsafe_read" italic >
<T " and ">
<T "failsafe_write" italic >
<T " routines should also be provided, so that if a console device cannot be ac\
 cessed for some reason, at least the error messages won't get dropped in the b\
 it-bucket. These simply use a hard-wired serial port for fall-back I/O in the \
 i386 and BeBox ports, and stdio under Unix.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Memory-and-IO-access\"">
<FV>
<E_F>
<T "Memory and I/O access">
<P "html_h4">
<T "The memory and I/O access routines are required to get/set unaligned words \
 from memory. Similar routines are used to access device registers perhaps thro\
 ugh I/O space. The generic versions shipped with the default ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " may ben sufficient for most needs, but they should be checked to be sure. \
 The versions for the i386 and BeBox ports may be more instructive.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Timers\"">
<FV>
<E_F>
<T "Timers">
<P "html_h4">
<T "The timing routines in SmartFirmware use ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_gettime" italic >
<E_F>
<T " to do the real work. If the target compiler has a version of the standard \
 Unix function">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "gettimeoday" italic >
<E_F>
<T " in its runtime library, this routine will most likely not need to be modif\
 ied. Otherwise, some other method must be used.">
<P "Normal">
<T "It is possible to bring up a new port without having to manage timers and i\
 nterrupts at all. Simply defined the routine ">
<T "u_sleep" italic >
<T " to be a simple timed loop, and enough of SmartFirmware will run to bring u\
 p the port. Then the proper timer code can be turned on once ">
<T "dprintf" italic >
<T " is available to debug it.">
<P "Normal">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_gettime" italic >
<E_F>
<T " is used when pausing for a specified time and for handling alarms by using\
  polling loops. Real timer interrupts could be used, but SmartFirmware is not \
 interrupt-safe, so some method of synchronizing interrupt tasks would still ne\
 ed to be used. If real interrupts are necessary, some of the routines that use\
  ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_gettime" italic >
<E_F>
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " may also need to be modified.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Device-probing\"">
<FV>
<E_F>
<T "Device probing">
<P "html_h4">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_probe_all" italic >
<E_F>
<T " is used to probe the hardware at start-up before a prompt would be display\
 ed. This will almost certainly need to be customized. One of the things it may\
  do is identify a console device. The i386 and BeBox ports probe for both a PC\
 I and an ISA bus.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Binary-images\"">
<FV>
<E_F>
<T "Binary images">
<P "html_h4">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_init_program" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_go" italic >
<E_F>
<T " are used to setup and launch a machine-dependent binary image. The default\
 s assume that the image is simply a pointer to the start of a C function and c\
 an simply be called using a C pointer-to-function. This code may in turn call \
 the plug-in binary image loader defined under the ">
<T "fs" italic >
<T " subdirectory by using the ">
<T "exec_is_exec" italic >
<T " and ">
<T "exec_load" italic >
<T " routines. The actual binary images supported are listed here in the global\
  variable ">
<T "g_exec_list." italic >
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Client-interface-callback\"">
<FV>
<E_F>
<T "Client-interface callback">
<P "html_h4">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_callback" italic >
<E_F>
<T " is used for client-interface callbacks. The default assumes that the callb\
 ack is simply a pointer to a C function and calls it. This does not need to be\
  ported if the client-interface will not be used.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Built-in-words-and-packages\"">
<FV>
<E_F>
<T "Built-in words and packages">
<P "html_h4">
<T "This file also contains several global lists which are used to configure th\
 e modules and packages to be linked into the final image. These lists are call\
 ed ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_list" italic >
<E_F>
<T " and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "install_list" italic >
<E_F>
<T " , for a list of pointers to ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Initentry*" italic >
<E_F>
<T " tables and a list of pointers to initialization ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Commands" italic >
<E_F>
<T " .">
<P "Normal">
<T "Each module that wishes to install a set of words into the global Forth dic\
 tionary creates an initialization list at the bottom of the file (see ">
<T "funcs.c" italic >
<T " or ">
<T "devies.c" italic >
<T " for an example). Each package that needs more complex initialization creat\
 es a function that does the work. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T " determines which of these will actually be linked into the final image. Th\
 is process is described in more detail in ">
<S_F fieldType:16 editable
<start_eval_value>
<T "Creating new words">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"Creating-new-words\" -pass \"\" -text \"Cre\
 ating new words\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "Creating new words" underline color:"HtmlLinkDefault@" >
<E_F>
<T ".">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Built-in-drivers\"">
<FV>
<E_F>
<T "Built-in drivers">
<P "html_h4">
<T "Drivers for built-in PCI devices may also be specified using the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "pci_drivers" italic >
<E_F>
<T " global list. This is used by pci.c when probing the PCI bus. Built-in ISA \
 drivers are handled similarly by defining the devices in the global ">
<T "isa_devices." italic >
<T " Built-in filesystem support may be specified by the global ">
<T "g_filesys." italic >
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Non-volatile-RAM\"">
<FV>
<E_F>
<T "Non-volatile RAM">
<P "html_h4">
<T "Non-volatile memory (NVRAM) is managed here by routines that read a static \
 array to initialize or use to set default values. The sample code has code tha\
 t ignores all writes. This should be sufficient to bootstrap a preliminary por\
 t of SmartFirmware then adding full NVRAM support later. A static array should\
  still be used as a fall-back in case NVRAM is inaccessible or corrupt.">
<P "Normal">
<T "The initial definitions for \"input-device\" and \"output-device\" in NVRAM\
  are important when bringing up a new port of SmartFirmware. They should first\
  be defined as \"/failsafe\" to bring up a console using the fall-back failsaf\
 e I/O routines. (This driver is defined in the file ">
<T "failsafe.c." italic >
<T ") Once devices are properly probed and visible to the system in the device \
 tree, then these definitions may be changed to the standard \"keyboard\" and \\
 "screen\" aliases, with the actual devices for the aliases possibly being sele\
 cted by ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_probe_all" italic >
<E_F>
<T " .">
<P "Normal">
<T "The routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_init_args" italic >
<E_F>
<T " is called from ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "main()" italic >
<E_F>
<T " once the Forth environment has been created and initialized. At this point\
  Forth is ready to run but no devices have been probed. ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machine_init_args" italic >
<E_F>
<T " is passed the arguments that were passed to ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "main" italic >
<E_F>
<T " if they are useful for a particular port. It may initialize the \"self\" f\
 ield of its ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Environ" italic >
<E_F>
<T " *parameter if desired.">
<P "Normal">
<E_F>
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_30" evenHeader:Inherit firstHeader:Inherit evenFo\
 oter:Inherit sectNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:0>
<S_F fieldType:3>
<T "series \"main\"">
<FV>
<T "4. ">
<E_F>
<S_F fieldType:6 date:908505765 docType:200 appType:1 outDated
<start_eval_value>
<S_F fieldType:17>
<T "hyper_target \"Creating-new-words\"">
<FV>
<E_F>
<T "Creating new words">
<P "html_h1">
<T "This chapter describes how to create new Forth words and packages and insta\
 ll them into SmartFirmware.">
<P "Normal">
<S_F fieldType:17>
<T "hyper_target \"Words\"">
<FV>
<E_F>
<T "Words">
<P "html_h2">
<T "A word is a Forth executable object, usually a C function or a Forth/FCode \
 routine. First we will implement a sample word in C, and show how to put it in\
 to SmartFirmware.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Declaring \"">
<FV>
<E_F>
<T "Declaring">
<P "html_h4">
<T "A file named ">
<T "hello.c" italic >
<T " is created and contains the following:">
<P "Normal">
<T "#include \"defs.h\"\n^ka\nC(hello)\n{\n    cprintf(e, \"Hello, world!\\n\")\
 ;\n    return NO_ERROR;\n}">
<P "html_preformatted">
<T "This declares and defines a local static Forth ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Command" italic >
<E_F>
<T " . A ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Command" italic >
<E_F>
<T " must always return an appropriate ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Retcode" italic >
<E_F>
<T " , in this case ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "NO_ERROR" italic >
<E_F>
<T " . The macro \"">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "C" bold >
<E_F>
<T "\" is used to declare the function, which will be named ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "f_hello" italic >
<E_F>
<T " . All these types and macros are defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " .">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Initentry\"">
<FV>
<E_F>
<T "Initentry">
<P "html_h4">
<T "To enter this word in SmartFirmware's global dictionary, it must be first p\
 ut into an initialization list (composed of ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Initentry" italic >
<E_F>
<T " objects).">
<P "Normal">
<T "const Initentry init_hello[] =\n{\n    { \"hello\", f_hello, INVALID_FCODE \
 },\n    { NULL, NULL }\n};">
<P "html_preformatted">
<T "This list must always end with the \"NULL, NULL\" combination which properl\
 y terminates the list. The Forth world will know this function as the string \\
 "hello\". It will call the routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "f_hello" italic >
<E_F>
<T " whenever the word \"hello\" is invoked.">
<P "Normal">
<T "The ">
<T "INVALID_FCODE" italic >
<T " value tells the SmartFirmware initialization code that this routine does n\
 ot have a pre-defined FCode value in the OpenFirmware specification, so automa\
 tically generate an arbitrary value at runtime that is safely out of the pre-d\
 efined ranges in the specification.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"init_list\"">
<FV>
<E_F>
<T "init_list">
<P "html_h4">
<T "The last thing to do is add init_hello to the global list-of-init-lists in \
 ">
<T "machdep.c." italic >
<T " Look for the code that begins with ">
<T "extern Initentry" italic >
<T " in that file. Our ">
<T "init_hello" italic >
<T " will be added to the end of that list, and also inside the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_list" italic >
<E_F>
<T " global.">
<P "Normal">
<T "...\n/* bunch of other extern Initentrys here */\nextern const Initentry in\
 it_display[];\nextern const Initentry init_hello[];    /* add this line */\n^k\
 a\nconst Initentry* init_list[] =\n{\n    ...\n    init_display,\n    init_hel\
 lo,   /* and add this line */\n    NULL          /* must be NULL terminated! *\
 /\n};">
<P "html_preformatted">
<T "Now re-compile ">
<T "machdep.c " italic >
<T "and relink SmartFirmware, start it up, and type \"hello\" at the prompt. It\
  should respond with \"Hello, world!\".">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"More-Initentry\"">
<FV>
<E_F>
<T "More Initentry">
<P "html_h4">
<T "An ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Initentry" italic >
<E_F>
<T " can contain other types of words. Here is a way to create a word as a stri\
 ng of Forth commands:">
<P "Normal">
<T "const Initentry init_hello[] =\n{\n    { \"hello\", f_hello, INVALID_FCODE \
 },\n    { \"hello2\", (Command)\".\\\" Hello, world!\\\" cr\",\n            IN\
 VALID_FCODE, F_NONE, T_FORTH\n            HELP(\"(--) display hello message\")\
 \n            },\n    { NULL, NULL }\n};">
<P "html_preformatted">
<T "Recompile ">
<T "hello.c" italic >
<T ", relink, and now invoking \"hello2\" will do the same thing as \"hello\". \
 Notice that machdep.c does not need to be recompiled.">
<P "Normal">
<T "There are more involved forms of the various arguments to an ">
<T "Initentry" italic >
<T ", used for special compilation words, pointers to fields of C structures, a\
 nd constants. Browse some of the SmartFirmware sources to see the different wa\
 ys that a word can be created, should you need anything more complex than the \
 above two forms.">
<P "Normal">
<T "The ">
<T "HELP" italic >
<T " macro inserts a message to be displayed by the ">
<T "help" italic >
<T " command for the ">
<T "hello2" italic >
<T " word. This help may be turned off and on using the macro ">
<T "DETAILED_HELP" italic >
<T " in ">
<T "machdep.h" italic >
<T ". Detailed help messages take up more data space so if memory is tight, it \
 may be turned off. Note that there must be no preceding comma before invoking \
 the ">
<T "HELP" italic >
<T " macro. It automatically inserts a comma if ">
<T "DETAILED_HELP" italic >
<T " is on.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Packages\"">
<FV>
<E_F>
<T "Packages">
<P "html_h2">
<T "A package can be a special-function subroutine library such as ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "deblock.c" italic >
<E_F>
<T " , or it can be a bus or device driver, such as ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "pci.c" italic >
<E_F>
<T " . The simplest packages to study are ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "disklbl.c" italic >
<E_F>
<T " (for finding and managing disk labels and partitions, if any) and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "failsafe.c" italic >
<E_F>
<T " (for faking a console and keyboard using fail-safe I/O routines in ">
<T "machdep.c" italic >
<T ").">
<P "Normal">
<T "Packages may be written in Forth or may be embedded as FCode on a plug-in c\
 ard. The ">
<S_F fieldType:16 editable
<start_eval_value>
<T "User Manual">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"SmartFirmware-User-Manual\" -pass \"\" -tex\
 t \"User Manual\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "User Manual" underline color:"HtmlLinkDefault@" >
<E_F>
<T " describes more about how OpenFirmware devices trees, paths, and packages i\
 nteract. The OpenFirmware specification should be consulted for the final word\
  in these matters.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"struct-self\"">
<FV>
<E_F>
<T "struct self">
<P "html_h4">
<T "One important C idiom that the C packages use is defining a ">
<T "struct self " italic >
<T "at the top of the file. The field ">
<T "struct self *self" italic >
<T " is declared within ">
<T "Instance" italic >
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " but is never explicitly defined. Each package can create and manage its ow\
 n ">
<T "struct self " italic >
<T "without worrying about some other package's definition. This allows C code \
 to easily access instance-specific variables without having to go through the \
 Forth environment. This does mean that a package cannot directly access anothe\
 r package's private C variables, but that's probably a good thing anyway.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Methods\"">
<FV>
<E_F>
<T "Methods">
<P "html_h4">
<T "Methods are declared and used for packages pretty much as other Forth words\
 . The only difference is that these words are package-specific and are not ins\
 talled in the global dictionary but rather in the specific package's own priva\
 te dictionary. These are then called methods of the package.">
<P "Normal">
<T "A package should always have an ">
<T "open" italic >
<T " and ">
<T "close" italic >
<T " method. Empty stubs are fine, but they should always return ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "NO_ERROR" italic >
<E_F>
<T " . ">
<T "open" italic >
<T " must also push ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "FTRUE" italic >
<E_F>
<T " on the top of the data stack.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Initialization\"">
<FV>
<E_F>
<T "Initialization">
<P "html_h4">
<T "A package is also initialized differently from plain-vanilla Forth words. B\
 ecause a package is always created relative to a parent at runtime, a C functi\
 on must be used to initialize the package. This C routine must create the new \
 ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Package" italic >
<E_F>
<T " object, and initialize its method table. Typically it will also allocate a\
 nd initialize its ">
<T "Self" italic >
<T " struct.">
<P "Normal">
<T "For instance, in disklbl.c, first the C methods are placed into an Initentr\
 y list to be used later.">
<P "Normal">
<T "static const Initentry disklabel_methods[] =\n{\n    { \"open\", f_open, IN\
 VALID_FCODE },\n    ...\n    { NULL, NULL }\n};\n^ka\nCC(install_disklabel)\n{\
 \n    Package *pkg = new_pkg_name(e->packages,\n            \"disk-label\");\n\
 ^ka\n    return init_entries(e, pkg->dict, disklabel_methods);\n}">
<P "html_preformatted">
<T "The routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "install_disklabel" italic >
<E_F>
<T " is then entered into a global list in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T ".">
<P "Normal">
<T "EC(install_disklabel);    /* declare it */\n...\nconst Command install_list\
 [] =\n{\n    ...\n    install_disklabel,    /* and insert it at the end */\n  \
   NULL\n};">
<P "html_preformatted">
<T "The ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "install_disklabel" italic >
<E_F>
<T " routine must call ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "new_pkg_name" italic >
<E_F>
<T " to create the new package with the specified parent (in this case the node\
  \"/packages\") and then call ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_entries" italic >
<E_F>
<T " to initialize the new package's dictionary. Additional package-specific in\
 itialization could be done here, but note that the ">
<T "open" italic >
<T " method is responsible for all instance-specific initialization.">
<P "Normal">
<end_eval_value>
>
*LINK /cgt/src/bin/of/docs/SFChapter4.aw
<T "link \"/cgt/src/bin/of/docs/SFChapter4.aw\" -docType \"200\" -appType \"Wor\
 ds_\"">
<FV>
<S_F fieldType:17>
<T "hyper_target \"Creating-new-words\"">
<FV>
<E_F>
<T "Creating new words">
<P "html_h1">
<T "This chapter describes how to create new Forth words and packages and insta\
 ll them into SmartFirmware.">
<P "Normal">
<S_F fieldType:17>
<T "hyper_target \"Words\"">
<FV>
<E_F>
<T "Words">
<P "html_h2">
<T "A word is a Forth executable object, usually a C function or a Forth/FCode \
 routine. First we will implement a sample word in C, and show how to put it in\
 to SmartFirmware.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Declaring \"">
<FV>
<E_F>
<T "Declaring">
<P "html_h4">
<T "A file named ">
<T "hello.c" italic >
<T " is created and contains the following:">
<P "Normal">
<T "#include \"defs.h\"\n^ka\nC(hello)\n{\n    cprintf(e, \"Hello, world!\\n\")\
 ;\n    return NO_ERROR;\n}">
<P "html_preformatted">
<T "This declares and defines a local static Forth ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Command" italic >
<E_F>
<T " . A ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Command" italic >
<E_F>
<T " must always return an appropriate ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Retcode" italic >
<E_F>
<T " , in this case ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "NO_ERROR" italic >
<E_F>
<T " . The macro \"">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "C" bold >
<E_F>
<T "\" is used to declare the function, which will be named ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "f_hello" italic >
<E_F>
<T " . All these types and macros are defined in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " .">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Initentry\"">
<FV>
<E_F>
<T "Initentry">
<P "html_h4">
<T "To enter this word in SmartFirmware's global dictionary, it must be first p\
 ut into an initialization list (composed of ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Initentry" italic >
<E_F>
<T " objects).">
<P "Normal">
<T "const Initentry init_hello[] =\n{\n    { \"hello\", f_hello, INVALID_FCODE \
 },\n    { NULL, NULL }\n};">
<P "html_preformatted">
<T "This list must always end with the \"NULL, NULL\" combination which properl\
 y terminates the list. The Forth world will know this function as the string \\
 "hello\". It will call the routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "f_hello" italic >
<E_F>
<T " whenever the word \"hello\" is invoked.">
<P "Normal">
<T "The ">
<T "INVALID_FCODE" italic >
<T " value tells the SmartFirmware initialization code that this routine does n\
 ot have a pre-defined FCode value in the OpenFirmware specification, so automa\
 tically generate an arbitrary value at runtime that is safely out of the pre-d\
 efined ranges in the specification.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"init_list\"">
<FV>
<E_F>
<T "init_list">
<P "html_h4">
<T "The last thing to do is add init_hello to the global list-of-init-lists in \
 ">
<T "machdep.c." italic >
<T " Look for the code that begins with ">
<T "extern Initentry" italic >
<T " in that file. Our ">
<T "init_hello" italic >
<T " will be added to the end of that list, and also inside the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_list" italic >
<E_F>
<T " global.">
<P "Normal">
<T "...\n/* bunch of other extern Initentrys here */\nextern const Initentry in\
 it_display[];\nextern const Initentry init_hello[];    /* add this line */\n^k\
 a\nconst Initentry* init_list[] =\n{\n    ...\n    init_display,\n    init_hel\
 lo,   /* and add this line */\n    NULL          /* must be NULL terminated! *\
 /\n};">
<P "html_preformatted">
<T "Now re-compile ">
<T "machdep.c " italic >
<T "and relink SmartFirmware, start it up, and type \"hello\" at the prompt. It\
  should respond with \"Hello, world!\".">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"More-Initentry\"">
<FV>
<E_F>
<T "More Initentry">
<P "html_h4">
<T "An ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Initentry" italic >
<E_F>
<T " can contain other types of words. Here is a way to create a word as a stri\
 ng of Forth commands:">
<P "Normal">
<T "const Initentry init_hello[] =\n{\n    { \"hello\", f_hello, INVALID_FCODE \
 },\n    { \"hello2\", (Command)\".\\\" Hello, world!\\\" cr\",\n            IN\
 VALID_FCODE, F_NONE, T_FORTH\n            HELP(\"(--) display hello message\")\
 \n            },\n    { NULL, NULL }\n};">
<P "html_preformatted">
<T "Recompile ">
<T "hello.c" italic >
<T ", relink, and now invoking \"hello2\" will do the same thing as \"hello\". \
 Notice that machdep.c does not need to be recompiled.">
<P "Normal">
<T "There are more involved forms of the various arguments to an ">
<T "Initentry" italic >
<T ", used for special compilation words, pointers to fields of C structures, a\
 nd constants. Browse some of the SmartFirmware sources to see the different wa\
 ys that a word can be created, should you need anything more complex than the \
 above two forms.">
<P "Normal">
<T "The ">
<T "HELP" italic >
<T " macro inserts a message to be displayed by the ">
<T "help" italic >
<T " command for the ">
<T "hello2" italic >
<T " word. This help may be turned off and on using the macro ">
<T "DETAILED_HELP" italic >
<T " in ">
<T "machdep.h" italic >
<T ". Detailed help messages take up more data space so if memory is tight, it \
 may be turned off. Note that there must be no preceding comma before invoking \
 the ">
<T "HELP" italic >
<T " macro. It automatically inserts a comma if ">
<T "DETAILED_HELP" italic >
<T " is on.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Packages\"">
<FV>
<E_F>
<T "Packages">
<P "html_h2">
<T "A package can be a special-function subroutine library such as ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "deblock.c" italic >
<E_F>
<T " , or it can be a bus or device driver, such as ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "pci.c" italic >
<E_F>
<T " . The simplest packages to study are ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "disklbl.c" italic >
<E_F>
<T " (for finding and managing disk labels and partitions, if any) and ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "failsafe.c" italic >
<E_F>
<T " (for faking a console and keyboard using fail-safe I/O routines in ">
<T "machdep.c" italic >
<T ").">
<P "Normal">
<T "Packages may be written in Forth or may be embedded as FCode on a plug-in c\
 ard. The ">
<S_F fieldType:16 editable
<start_eval_value>
<T "User Manual">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"SmartFirmware-User-Manual\" -pass \"\" -tex\
 t \"User Manual\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "User Manual" underline color:"HtmlLinkDefault@" >
<E_F>
<T " describes more about how OpenFirmware devices trees, paths, and packages i\
 nteract. The OpenFirmware specification should be consulted for the final word\
  in these matters.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"struct-self\"">
<FV>
<E_F>
<T "struct self">
<P "html_h4">
<T "One important C idiom that the C packages use is defining a ">
<T "struct self " italic >
<T "at the top of the file. The field ">
<T "struct self *self" italic >
<T " is declared within ">
<T "Instance" italic >
<T " in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "defs.h" italic >
<E_F>
<T " but is never explicitly defined. Each package can create and manage its ow\
 n ">
<T "struct self " italic >
<T "without worrying about some other package's definition. This allows C code \
 to easily access instance-specific variables without having to go through the \
 Forth environment. This does mean that a package cannot directly access anothe\
 r package's private C variables, but that's probably a good thing anyway.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Methods\"">
<FV>
<E_F>
<T "Methods">
<P "html_h4">
<T "Methods are declared and used for packages pretty much as other Forth words\
 . The only difference is that these words are package-specific and are not ins\
 talled in the global dictionary but rather in the specific package's own priva\
 te dictionary. These are then called methods of the package.">
<P "Normal">
<T "A package should always have an ">
<T "open" italic >
<T " and ">
<T "close" italic >
<T " method. Empty stubs are fine, but they should always return ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "NO_ERROR" italic >
<E_F>
<T " . ">
<T "open" italic >
<T " must also push ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "FTRUE" italic >
<E_F>
<T " on the top of the data stack.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Initialization\"">
<FV>
<E_F>
<T "Initialization">
<P "html_h4">
<T "A package is also initialized differently from plain-vanilla Forth words. B\
 ecause a package is always created relative to a parent at runtime, a C functi\
 on must be used to initialize the package. This C routine must create the new \
 ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Package" italic >
<E_F>
<T " object, and initialize its method table. Typically it will also allocate a\
 nd initialize its ">
<T "Self" italic >
<T " struct.">
<P "Normal">
<T "For instance, in disklbl.c, first the C methods are placed into an Initentr\
 y list to be used later.">
<P "Normal">
<T "static const Initentry disklabel_methods[] =\n{\n    { \"open\", f_open, IN\
 VALID_FCODE },\n    ...\n    { NULL, NULL }\n};\n^ka\nCC(install_disklabel)\n{\
 \n    Package *pkg = new_pkg_name(e->packages,\n            \"disk-label\");\n\
 ^ka\n    return init_entries(e, pkg->dict, disklabel_methods);\n}">
<P "html_preformatted">
<T "The routine ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "install_disklabel" italic >
<E_F>
<T " is then entered into a global list in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "machdep.c" italic >
<E_F>
<T ".">
<P "Normal">
<T "EC(install_disklabel);    /* declare it */\n...\nconst Command install_list\
 [] =\n{\n    ...\n    install_disklabel,    /* and insert it at the end */\n  \
   NULL\n};">
<P "html_preformatted">
<T "The ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "install_disklabel" italic >
<E_F>
<T " routine must call ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "new_pkg_name" italic >
<E_F>
<T " to create the new package with the specified parent (in this case the node\
  \"/packages\") and then call ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "init_entries" italic >
<E_F>
<T " to initialize the new package's dictionary. Additional package-specific in\
 itialization could be done here, but note that the ">
<T "open" italic >
<T " method is responsible for all instance-specific initialization.">
<P "Normal">
<E_F>
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_31" evenHeader:Inherit firstHeader:Inherit evenFo\
 oter:Inherit sectNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:0>
<S_F fieldType:3>
<T "series \"main\"">
<FV>
<T "5. ">
<E_F>
<S_F fieldType:6 date:908505780 docType:200 appType:1 outDated
<start_eval_value>
<S_F fieldType:27 editable>
<T "html_tag -text \"<!-- This file created 7/5/1997 2:38 PM by Claris Home Pag\
 e version 2.0-->\" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<META NAME=GENERATOR CONTENT=\\\"Claris Home Page 2.0\\\">\
 \" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<X-SAS-WINDOW TOP=44 BOTTOM=744 LEFT=338 RIGHT=868>\" -tex\
 tStyle \"html_unknown_text\"">
<FV>
<E_F>
<T "Compiling, Running, Etc.">
<P "html_h1" level:0 >
<T "This chapter describes how to compile and run SmartFirmware.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Building\"">
<FV>
<E_F>
<T "Building">
<P "html_h2">
<T "The usual way to build SmartFirmware is using the included Unix">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Makefile" italic >
<E_F>
<T " . It builds SmartFirmware on a variety of Unix systems, including FreeBSD,\
  NetBSD on Alpha, Solaris on the Sparc, and under BeOS on either Macintosh or \
 BeBox. Most configurations will require either modifying the Makefile to selec\
 t the appropriate macro definitions for CFLAGS and the like.">
<P "Normal" level:0 >
<T "New targets">
<P "html_h4" level:0 >
<T "Each target port or platform is placed in a subdirectory. Each has its own \
 ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Makefile" italic >
<E_F>
<T " that refers to common files or machine-specific files as needed. Some impl\
 ementations of ">
<T "make" italic >
<T " are unable to handle the relative paths to common source files. For these \
 systems, the common files may simply be linked into the platform's subdirector\
 y before building. Or the BSD make may simply be ported to the target platform\
 .">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Macintosh\"">
<FV>
<E_F>
<T "Macintosh">
<P "html_h4" level:0 >
<T "For the Macintosh, a CodeWarrior project file is included named ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "mw-project.hqx" italic >
<E_F>
<T " . Simply decode it on a Mac to create the SmartFirmware project file and t\
 he Mac resource file, open the project file, then simply select the Make menu \
 to build a Mac version of SmartFirmware.">
<P "Normal" level:0 >
<T "The Mac version uses an off-screen PixMap and the SmartFirmware 8-bit displ\
 ay package in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "fb.c" italic >
<E_F>
<T " rather than using the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "stdio.c" italic >
<E_F>
<T " interface. This allows the display code to be exercised and tested before \
 being burned into a ROM. However, since the off-screen PixMap is blitted to th\
 e Mac window every time a character is displayed, performance is lousy since w\
 e try to remain reasonably Mac-friendly by calling ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "WaitNextEvent" italic >
<E_F>
<T " .">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"BeOS\"">
<FV>
<E_F>
<T "BeOS">
<P "html_h4" level:0 >
<T "Building under the BeOS requires the unlimited Metrowerks linker. The file \
 ">
<T "BeOS.proj " italic >
<T "is a Metrowerks project files and ">
<T "BeOS.rsrc" italic >
<T " is the resources for the project. The ">
<T "Makefile" italic >
<T " may also be used if the BSD ">
<T "make" italic >
<T " has been ported or uploaded to the BeOS.">
<P "Normal" level:0 >
<T "This version of SmartFirmware uses an off-screen bitmap and uses the displa\
 y package rather than more Unix-like stdio interface. SmartFirmware proper run\
 s as a separate thread to closely mimic the behavior of an embedded system. A \
 separate thread is responsible for keyboard and screen I/O.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Running\"">
<FV>
<E_F>
<T "Running">
<P "html_h2">
<T "Running the Unix SmartFirmware on a Unix-like system is simply typing ">
<T "of" italic >
<T " at the prompt. The unix SmartFirmware initializes its fake devices, create\
 s a dummy console and keyboard device attached to stdout and stdin (respective\
 ly), and enters a standard Forth command eval loop.">
<P "Normal" level:0 >
<T "On the Mac, double-click the application \"OpenFirmware\" to launch it. Aft\
 er that, it's pretty much like the Unix implementation, except there is no way\
  to pass in any command-line arguments so everything must be run from inside t\
 he Forth environment. The BeOS port is similar to the Mac version.">
<P "Normal" level:0 >
<T "Running other versions of SmartFirmware depends upon each port. The FreeBSD\
  i386 port runs by using the FreeBSD boot-loader to setup 32-bit protected mod\
 e, and thus may be launched instead of the kernel. Other ports may be placed i\
 nto ROM and may be launched simply by powering up a VME graphics card, or boot\
 ed off of a floppy.">
<P "Normal" level:0 >
<T "^ka">
<S_F fieldType:17 editable>
<T "hyper_target \"Tokenizing\"">
<FV>
<E_F>
<T "Tokenizing">
<P "html_h2">
<S_F fieldType:17 editable>
<T "hyper_target \"Command-line\"">
<FV>
<E_F>
<T "Command line">
<P "html_h4" level:0 >
<T "Under Unix, \"of\" takes several command-line arguments. The first allows r\
 unning an arbitrary Forth or Fcode file on the local host:">
<P "Normal" level:0 >
<T "$ of -file forth-or-fcode-file">
<P "html_preformatted" level:0 >
<T "The second form runs just the tokenizer:">
<P "Normal" level:0 >
<T "$ of -tokenize tokenizer-source-file">
<P "html_preformatted" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Forth-prompt\"">
<FV>
<E_F>
<T "Forth prompt">
<P "html_h4" level:0 >
<T "Both of these commands may be run from within the Forth environment (which \
 is the only way to run them on the Mac or BeOS). To load a file:">
<P "Normal" level:0 >
<T "ok load-file forth-or-fcode-file">
<P "html_preformatted" level:0 >
<T "To tokenize a file:">
<P "Normal" level:0 >
<T "ok tokenize tokenizer-source-file">
<P "html_preformatted" level:0 >
<T "The tokenizer source file should begin and end with the tokenizer words ">
<T "fcode-version2" italic >
<T " and ">
<T "fcode-end" italic >
<T ", as the OpenFirmware errata now requires.">
<P "Normal" level:0 >
<T "Detokenizing">
<P "html_h2">
<T "SmartFirmware also supports detokenizing an Fcode file. This is essentially\
  an Fcode disassembler and is useful for debugging. To run it at the Unix prom\
 pt:">
<P "Normal" level:0 >
<T "$ of -detokenize fcode-file">
<P "html_preformatted" level:0 >
<T "From within SmartFirmware do this:">
<P "Normal" level:0 >
<T "ok detok fcode-file">
<P "html_preformatted" level:0 >
<T "The output is rather verbose and probably somewhat cryptic. We apologize fo\
 r any inconvenience. It's easiest to look through the sources to see what the \
 various values mean.">
<P "Normal" level:0 >
<end_eval_value>
>
*LINK /cgt/src/bin/of/docs/SFChapter5.aw
<T "link \"/cgt/src/bin/of/docs/SFChapter5.aw\" -docType \"200\" -appType \"Wor\
 ds_\"">
<FV>
<S_F fieldType:17>
<T "hyper_target \"Compiling-Running-Etc\"">
<FV>
<E_F>
<T "Compiling, Running, Etc.">
<P "html_h1">
<T "This chapter describes how to compile and run SmartFirmware.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Building\"">
<FV>
<E_F>
<T "Building">
<P "html_h2">
<T "The usual way to build SmartFirmware is using the included Unix">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Makefile" italic >
<E_F>
<T " . It builds SmartFirmware on a variety of Unix systems, including FreeBSD,\
  NetBSD on Alpha, Solaris on the Sparc, and under BeOS on either Macintosh or \
 BeBox. Most configurations will require either modifying the Makefile to selec\
 t the appropriate macro definitions for CFLAGS and the like.">
<P "Normal">
<S_F fieldType:17>
<T "hyper_target \"New-targets\"">
<FV>
<E_F>
<T "New targets">
<P "html_h4">
<T "Each target port or platform is placed in a subdirectory. Each has its own \
 ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "Makefile" italic >
<E_F>
<T " that refers to common files or machine-specific files as needed. Some impl\
 ementations of ">
<T "make" italic >
<T " are unable to handle the relative paths to common source files. For these \
 systems, the common files may simply be linked into the platform's subdirector\
 y before building. Or the BSD make may simply be ported to the target platform\
 .">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Macintosh\"">
<FV>
<E_F>
<T "Macintosh">
<P "html_h4">
<T "For the Macintosh, a CodeWarrior project file is included named ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "mw-project.hqx" italic >
<E_F>
<T " . Simply decode it on a Mac to create the SmartFirmware project file and t\
 he Mac resource file, open the project file, then simply select the Make menu \
 to build a Mac version of SmartFirmware.">
<P "Normal">
<T "The Mac version uses an off-screen PixMap and the SmartFirmware 8-bit displ\
 ay package in ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "fb.c" italic >
<E_F>
<T " rather than using the ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "stdio.c" italic >
<E_F>
<T " interface. This allows the display code to be exercised and tested before \
 being burned into a ROM. However, since the off-screen PixMap is blitted to th\
 e Mac window every time a character is displayed, performance is lousy since w\
 e try to remain reasonably Mac-friendly by calling ">
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_citation_text\"">
<FV>
<T "WaitNextEvent" italic >
<E_F>
<T " .">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"BeOS\"">
<FV>
<E_F>
<T "BeOS">
<P "html_h4">
<T "Building under the BeOS requires the unlimited Metrowerks linker. The file \
 ">
<T "BeOS.proj " italic >
<T "is a Metrowerks project files and ">
<T "BeOS.rsrc" italic >
<T " is the resources for the project. The ">
<T "Makefile" italic >
<T " may also be used if the BSD ">
<T "make" italic >
<T " has been ported or uploaded to the BeOS.">
<P "Normal">
<T "This version of SmartFirmware uses an off-screen bitmap and uses the displa\
 y package rather than more Unix-like stdio interface. SmartFirmware proper run\
 s as a separate thread to closely mimic the behavior of an embedded system. A \
 separate thread is responsible for keyboard and screen I/O.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Running\"">
<FV>
<E_F>
<T "Running">
<P "html_h2">
<T "Running the Unix SmartFirmware on a Unix-like system is simply typing ">
<T "of" italic >
<T " at the prompt. The unix SmartFirmware initializes its fake devices, create\
 s a dummy console and keyboard device attached to stdout and stdin (respective\
 ly), and enters a standard Forth command eval loop.">
<P "Normal">
<T "On the Mac, double-click the application \"OpenFirmware\" to launch it. Aft\
 er that, it's pretty much like the Unix implementation, except there is no way\
  to pass in any command-line arguments so everything must be run from inside t\
 he Forth environment. The BeOS port is similar to the Mac version.">
<P "Normal">
<T "Running other versions of SmartFirmware depends upon each port. The FreeBSD\
  i386 port runs by using the FreeBSD boot-loader to setup 32-bit protected mod\
 e, and thus may be launched instead of the kernel. Other ports may be placed i\
 nto ROM and may be launched simply by powering up a VME graphics card, or boot\
 ed off of a floppy.">
<P "Normal">
<T "Tokenizing">
<P "html_h2">
<S_F fieldType:17 editable>
<T "hyper_target \"Command-line\"">
<FV>
<E_F>
<T "Command line">
<P "html_h4">
<T "Under Unix, \"of\" takes several command-line arguments. The first allows r\
 unning an arbitrary Forth or Fcode file on the local host:">
<P "Normal">
<T "$ of -file forth-or-fcode-file">
<P "html_preformatted">
<T "The second form runs just the tokenizer:">
<P "Normal">
<T "$ of -tokenize tokenizer-source-file">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"Forth-prompt\"">
<FV>
<E_F>
<T "Forth prompt">
<P "html_h4">
<T "Both of these commands may be run from within the Forth environment (which \
 is the only way to run them on the Mac or BeOS). To load a file:">
<P "Normal">
<T "ok load-file forth-or-fcode-file">
<P "html_preformatted">
<T "To tokenize a file:">
<P "Normal">
<T "ok tokenize tokenizer-source-file">
<P "html_preformatted">
<T "The tokenizer source file should begin and end with the tokenizer words ">
<T "fcode-version2" italic >
<T " and ">
<T "fcode-end" italic >
<T ", as the OpenFirmware errata now requires.">
<P "Normal">
<T "Detokenizing">
<P "html_h2">
<T "SmartFirmware also supports detokenizing an Fcode file. This is essentially\
  an Fcode disassembler and is useful for debugging. To run it at the Unix prom\
 pt:">
<P "Normal">
<T "$ of -detokenize fcode-file">
<P "html_preformatted">
<T "From within SmartFirmware do this:">
<P "Normal">
<T "ok detok fcode-file">
<P "html_preformatted">
<T "The output is rather verbose and probably somewhat cryptic. We apologize fo\
 r any inconvenience. It's easiest to look through the sources to see what the \
 various values mean.">
<P "Normal">
<E_F>
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_32" evenHeader:Inherit firstHeader:Inherit evenFo\
 oter:Inherit sectNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:0>
<S_F fieldType:3>
<T "series \"main\"">
<FV>
<T "6. ">
<E_F>
<S_F fieldType:6 date:908505797 docType:200 appType:1 outDated
<start_eval_value>
<S_F fieldType:27 editable>
<T "html_tag -text \"<!-- This file created 5/30/98 10:52 PM by Claris Home Pag\
 e version 2.0-->\" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<META NAME=GENERATOR CONTENT=\\\"Claris Home Page 2.0\\\">\
 \" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<X-SAS-WINDOW TOP=42 BOTTOM=477 LEFT=4 RIGHT=534>\" -textS\
 tyle \"html_unknown_text\"">
<FV>
<E_F>
<T "Plug-in executable images">
<P "html_h1" level:0 >
<T "The plug-in layer is a non-standard interface to more easily support a vari\
 ety of executable image formats instead of writing custom loaders for each tar\
 get platform. The ">
<S_F fieldType:16 editable
<start_eval_value>
<T "source files">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"Executable-loader-files\" -pass \"SFChapter\
 2.html\" -text \"source files\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "source files" underline color:"HtmlLinkDefault@" >
<E_F>
<T " of the plug-in executable layer are located under the ">
<T "exe" italic >
<T " subdirectory.">
<P "Normal" level:0 >
<T "The plug-in executable layer sits above the low-lever device loader code an\
 d below the user-level ">
<T "load" italic >
<T " command. After an image is loaded from a disk or over the network, it is t\
 hen checked to see if a plug-in supports the image format, and if so, it may b\
 e executed.">
<P "Normal" level:0 >
<T "^kaInterface">
<P "html_h2">
<T "The interface to the plug-in executable layer is through the routines liste\
 d in ">
<T "exe.h" italic >
<T ":">
<P "Normal" level:0 >
<T "extern Bool exec_is_exec(Environ *e);\nextern Retcode exec_load(Environ *e)\
 ;\nextern Bool exec_length(Environ *e, uInt *len);\nextern Sym_table *exec_loa\
 d_symbols(Environ *e);\nvoid exec_free_symbols(Environ *e, Sym_table *tab);\ne\
 xtern Sym_ent *exec_sym2addr(Environ *e, Sym_table *tab,\n        Byte *sym, I\
 nt slen);\nextern Sym_ent *exec_addr2sym(Environ *e, Sym_table *tab,\n        \
 uLong addr);">
<P "html_preformatted" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Calling-plug-in-routines\"">
<FV>
<E_F>
<T "Calling plug-in routines">
<P "html_h4" level:0 >
<T "The callers of these routines are in the platform-dependent ">
<T "machdep.c" italic >
<T " file:">
<P "Normal" level:0 >
<T "CC(machine_init_program)^aj/* (--) */\n{\n^aj/* see if we have some support\
 ed executable image */\n^ajif (exec_is_exec(e))\n^aj{\n^aj^ajexec_free_symbols\
 (e, e->loadsyms);\n^aj^aje->loadsyms = exec_load_symbols(e);\n^aj^ajreturn NO_\
 ERROR;\n^aj}\n^ka\n^ajreturn E_BAD_IMAGE;\n}">
<P "html_preformatted" level:0 >
<T "The exec_is_exec routine simply iterates through the list of built-in suppo\
 rted formats to identify the image at e->load.">
<P "Normal" level:0 >
<T "CC(machine_go)^aj^aj^aj^aj/* (--) */\n{\n^ajRetcode ret;\n^ka\n^ajif (exec_\
 is_exec(e))^aj^aj/* sanity check */\n^aj{\n^aj^ajret = exec_load(e);\n^ka\n^aj\
 ^ajif (ret == NO_ERROR)\n^aj^aj{\n^aj^aj^ajexec_free_symbols(e, e->loadsyms);\\
 n^aj^aj^aje->loadsyms = exec_load_symbols(e);\n^aj^aj}\n^ka\n^aj^aj/* machine-\
 dependent launch through e->entrypoint */\n^aj}\n^ajelse\n^aj^ajret = E_BAD_IM\
 AGE;\n^ka\n^ajreturn ret;\n}">
<P "html_preformatted" level:0 >
<T "This code may additionally include custom loaders if desired, but it will g\
 enerally be easier to create a custom plug-in executable module as described b\
 elow.">
<P "Normal" level:0 >
<T "(The ">
<T "machine_init_load" italic >
<T " routine must correctly point ">
<T "e->load" italic >
<T " to a large area of free memory where it is safe to load an image.)">
<P "Normal" level:0 >
<T "Describing built-in formats">
<P "html_h4" level:0 >
<T "The ">
<T "machdep.c" italic >
<T " file must also list the image formats that are supported:">
<P "Normal" level:0 >
<T "extern Exec_entry exec_fcode;\nextern Exec_entry exec_forth;\nextern Exec_e\
 ntry exec_coff;\nextern Exec_entry exec_elf;\nextern Exec_entry exec_elf64;\ne\
 xtern Exec_entry exec_gzip;\n^ka\nExec_entry *g_exec_list[] = \n{\n^aj&exec_fc\
 ode,\n^aj&exec_forth,\n^aj&exec_coff,\n^aj&exec_elf,\n^aj&exec_elf64,\n^aj&exe\
 c_gzip,\n^ajNULL\n};">
<P "html_preformatted" level:0 >
<T "Each ">
<T "Exec_entry" italic >
<T " is defined in a separate file that supports that image format. In the exam\
 ple above, this platform will support Fcode, Forth, COFF and ELF format images\
 . The plug-in layer iterates through all supported images to first identify a \
 supported image and then load it.">
<P "Normal" level:0 >
<T "Supplied image formats">
<P "html_h2">
<T "Fcode and Forth images may be supported by any platform.">
<P "Normal" level:0 >
<T "The ">
<T "coff.c" italic >
<T " plug-in requires that the macros ">
<T "COFF_MAGIC_0" italic >
<T " and ">
<T "COFF_MAGIC_1" italic >
<T " be defined in the platform's ">
<T "machdep.h" italic >
<T " file. These determine the correct magic number values of the image as gene\
 rated by your platform's linker. Please see the file ">
<T "exe/coff.c" italic >
<T " for more details.">
<P "Normal" level:0 >
<T "elf.c" italic >
<T " also requires identifying the correct machine for the target by defining "\
 >
<T "ELF_OUR_MACHINE" italic >
<T " to the correct value in ">
<T "machdep.h" italic >
<T ". Please see the file ">
<T "exe/elf.c" italic >
<T " for more details.">
<P "Normal" level:0 >
<T "The files ">
<T "dumpcoff.c" italic >
<T " and ">
<T "dumpelf.c" italic >
<T " are included to display the contents of their respective binary images on \
 stdout, and also display their respective magic numbers. Compile these files u\
 sing your native host's compiler to build the programs ">
<T "dumpcoff" italic >
<T " and ">
<T "dumpelf" italic >
<T " respectively, then run them on a sample image.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Sample-Forth-image-format\"">
<FV>
<E_F>
<T "Sample Forth image format">
<P "html_h2">
<T "The file ">
<T "loadfc.c" italic >
<T " includes code for loading Forth and Fcode \"images\" following an OpenFirm\
 ware Recommended Practice document. The Forth image loader is a good outline f\
 or creating custom image loaders. A loader begins with these include files:">
<P "Normal" level:0 >
<T "#include \"defs.h\"\n#include \"exe.h\"">
<P "html_preformatted" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"is_exec-function\"">
<FV>
<E_F>
<T "is_exec function">
<P "html_h4" level:0 >
<T "Each loader has two entry points. One routine determines if the image point\
 ed to is an executable of the correct type or not:">
<P "Normal" level:0 >
<T "static Bool\nforth_is_exec(Environ *e, uByte *load, uInt loadlen)\n{\n^ajif\
  (loadlen > 2 && load[0] == '\\\\' && load[1] == ' ')\n^aj^ajreturn TRUE;\n^ka\
 \n^ajreturn FALSE;\n}">
<P "html_preformatted" level:0 >
<T "The entry point is passed a pointer to the image loaded into memory and its\
  length. This pointer is typically e->load but may not necessarily be so. An i\
 mage loader should look for some magic bytes and possible verify a checksum to\
  insure the image is of the supported type.">
<P "Normal" level:0 >
<T "The Forth ">
<T "is_exec" italic >
<T " routine looks for the first characters of the image to be the beginning of\
  a Forth text comment and if so, assumes it is a Forth image. It could also ch\
 eck that the rest of the image is all only ASCII characters if desired.">
<P "Normal" level:0 >
<T "Return ">
<T "TRUE" italic >
<T " if the image is the correct format and loadable and ">
<T "FALSE" italic >
<T " if not.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"load-function\"">
<FV>
<E_F>
<T "load function">
<P "html_h4" level:0 >
<T "The second entry actually loads the image and returns the entrypoint into t\
 he image:">
<P "Normal" level:0 >
<T "/* run the Forth image - loading makes no sense for Forth\n */\nstatic Retc\
 ode\nforth_load(Environ *e, uByte *load, uInt loadlen, uInt *entrypoint)\n{\n^\
 aj*entrypoint = -1;\n^ajreturn interp_text(e, (Byte*)load, (Int)loadlen);\n}">
<P "html_preformatted" level:0 >
<T "This routine interprets the Forth text at the load address directly rather \
 than return an entrypoint into the image. The entrypoint ">
<T "-1" bold >
<T " tells the caller that there is nothing more to do here.">
<P "Normal" level:0 >
<T "An image loader may copy portions of the image into some other piece of all\
 ocated memory, perform relocation and other patching operations, then return a\
  pointer to the entrypoint in the new image. It may simply assume that the tar\
 get memory is safely outside of the SmartFirmware's address space and directly\
  copy portions of the image straight to where it needs to be. Please see the "\
 >
<T "coff.c" italic >
<T " and ">
<T "elf.c " italic >
<T "files for details.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Exec_entry\"">
<FV>
<E_F>
<T "Exec_entry">
<P "html_h4" level:0 >
<T "Last the entry points are listed in an ">
<T "Exec_entry" italic >
<T " structure along with a name to identify this loader:">
<P "Normal" level:0 >
<T "const Exec_entry exec_forth =\n{\n^aj\"Forth\",\n^ajforth_is_exec,\n^ajfort\
 h_load\n};">
<P "html_preformatted" level:0 >
<T "Add a reference to this entry point in machdep.c's g_exec_list, and SmartFi\
 rmware now understands the new image format.">
<P "Normal" level:0 >
<end_eval_value>
>
*LINK /cgt/src/bin/of/docs/SFChapter6.aw
<T "link \"/cgt/src/bin/of/docs/SFChapter6.aw\" -docType \"200\" -appType \"Wor\
 ds_\"">
<FV>
<S_F fieldType:17>
<T "hyper_target \"Plug-in-executable-images\"">
<FV>
<E_F>
<T "Plug-in executable images">
<P "html_h1">
<T "The plug-in layer is a non-standard interface to more easily support a vari\
 ety of executable image formats instead of writing custom loaders for each tar\
 get platform. The ">
<S_F fieldType:16 editable
<start_eval_value>
<T "source files">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"Executable-loader-files\" -pass \"SFChapter\
 2.html\" -text \"source files\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "source files" underline color:"HtmlLinkDefault@" >
<E_F>
<T " of the plug-in executable layer are located under the ">
<T "exe" italic >
<T " subdirectory.">
<P "Normal">
<T "The plug-in executable layer sits above the low-lever device loader code an\
 d below the user-level ">
<T "load" italic >
<T " command. After an image is loaded from a disk or over the network, it is t\
 hen checked to see if a plug-in supports the image format, and if so, it may b\
 e executed.">
<P "Normal">
<S_F fieldType:17>
<T "hyper_target \"Interface\"">
<FV>
<E_F>
<T "Interface">
<P "html_h2">
<T "The interface to the plug-in executable layer is through the routines liste\
 d in ">
<T "exe.h" italic >
<T ":">
<P "Normal">
<T "extern Bool exec_is_exec(Environ *e);\nextern Retcode exec_load(Environ *e)\
 ;\nextern Bool exec_length(Environ *e, uInt *len);\nextern Sym_table *exec_loa\
 d_symbols(Environ *e);\nvoid exec_free_symbols(Environ *e, Sym_table *tab);\ne\
 xtern Sym_ent *exec_sym2addr(Environ *e, Sym_table *tab,\n        Byte *sym, I\
 nt slen);\nextern Sym_ent *exec_addr2sym(Environ *e, Sym_table *tab,\n        \
 uLong addr);">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"Calling-plug-in-routines\"">
<FV>
<E_F>
<T "Calling plug-in routines">
<P "html_h4">
<T "The callers of these routines are in the platform-dependent ">
<T "machdep.c" italic >
<T " file:">
<P "Normal">
<T "CC(machine_init_program)^aj/* (--) */\n{\n^aj/* see if we have some support\
 ed executable image */\n^ajif (exec_is_exec(e))\n^aj{\n^aj^ajexec_free_symbols\
 (e, e->loadsyms);\n^aj^aje->loadsyms = exec_load_symbols(e);\n^aj^ajreturn NO_\
 ERROR;\n^aj}\n^ka\n^ajreturn E_BAD_IMAGE;\n}">
<P "html_preformatted">
<T "The exec_is_exec routine simply iterates through the list of built-in suppo\
 rted formats to identify the image at e->load.">
<P "Normal">
<T "CC(machine_go)^aj^aj^aj^aj/* (--) */\n{\n^ajRetcode ret;\n^ka\n^ajif (exec_\
 is_exec(e))^aj^aj/* sanity check */\n^aj{\n^aj^ajret = exec_load(e);\n^ka\n^aj\
 ^ajif (ret == NO_ERROR)\n^aj^aj{\n^aj^aj^ajexec_free_symbols(e, e->loadsyms);\\
 n^aj^aj^aje->loadsyms = exec_load_symbols(e);\n^aj^aj}\n^ka\n^aj^aj/* machine-\
 dependent launch through e->entrypoint */\n^aj}\n^ajelse\n^aj^ajret = E_BAD_IM\
 AGE;\n^ka\n^ajreturn ret;\n}">
<P "html_preformatted">
<T "This code may additionally include custom loaders if desired, but it will g\
 enerally be easier to create a custom plug-in executable module as described b\
 elow.">
<P "Normal">
<T "(The ">
<T "machine_init_load" italic >
<T " routine must correctly point ">
<T "e->load" italic >
<T " to a large area of free memory where it is safe to load an image.)">
<P "Normal">
<T "Describing built-in formats">
<P "html_h4">
<T "The ">
<T "machdep.c" italic >
<T " file must also list the image formats that are supported:">
<P "Normal">
<T "extern Exec_entry exec_fcode;\nextern Exec_entry exec_forth;\nextern Exec_e\
 ntry exec_coff;\nextern Exec_entry exec_elf;\nextern Exec_entry exec_elf64;\ne\
 xtern Exec_entry exec_gzip;\n^ka\nExec_entry *g_exec_list[] = \n{\n^aj&exec_fc\
 ode,\n^aj&exec_forth,\n^aj&exec_coff,\n^aj&exec_elf,\n^aj&exec_elf64,\n^aj&exe\
 c_gzip,\n^ajNULL\n};">
<P "html_preformatted">
<T "Each ">
<T "Exec_entry" italic >
<T " is defined in a separate file that supports that image format. In the exam\
 ple above, this platform will support Fcode, Forth, COFF and ELF format images\
 . The plug-in layer iterates through all supported images to first identify a \
 supported image and then load it.">
<P "Normal">
<T "Supplied image formats">
<P "html_h2">
<T "Fcode and Forth images may be supported by any platform.">
<P "Normal">
<T "The ">
<T "coff.c" italic >
<T " plug-in requires that the macros ">
<T "COFF_MAGIC_0" italic >
<T " and ">
<T "COFF_MAGIC_1" italic >
<T " be defined in the platform's ">
<T "machdep.h" italic >
<T " file. These determine the correct magic number values of the image as gene\
 rated by your platform's linker. Please see the file ">
<T "exe/coff.c" italic >
<T " for more details.">
<P "Normal">
<T "elf.c" italic >
<T " also requires identifying the correct machine for the target by defining "\
 >
<T "ELF_OUR_MACHINE" italic >
<T " to the correct value in ">
<T "machdep.h" italic >
<T ". Please see the file ">
<T "exe/elf.c" italic >
<T " for more details.">
<P "Normal">
<T "The files ">
<T "dumpcoff.c" italic >
<T " and ">
<T "dumpelf.c" italic >
<T " are included to display the contents of their respective binary images on \
 stdout, and also display their respective magic numbers. Compile these files u\
 sing your native host's compiler to build the programs ">
<T "dumpcoff" italic >
<T " and ">
<T "dumpelf" italic >
<T " respectively, then run them on a sample image.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Sample-Forth-image-format\"">
<FV>
<E_F>
<T "Sample Forth image format">
<P "html_h2">
<T "The file ">
<T "loadfc.c" italic >
<T " includes code for loading Forth and Fcode \"images\" following an OpenFirm\
 ware Recommended Practice document. The Forth image loader is a good outline f\
 or creating custom image loaders. A loader begins with these include files:">
<P "Normal">
<T "#include \"defs.h\"\n#include \"exe.h\"">
<P "html_preformatted">
<S_F fieldType:17 editable>
<T "hyper_target \"is_exec-function\"">
<FV>
<E_F>
<T "is_exec function">
<P "html_h4">
<T "Each loader has two entry points. One routine determines if the image point\
 ed to is an executable of the correct type or not:">
<P "Normal">
<T "static Bool\nforth_is_exec(Environ *e, uByte *load, uInt loadlen)\n{\n^ajif\
  (loadlen > 2 && load[0] == '\\\\' && load[1] == ' ')\n^aj^ajreturn TRUE;\n^ka\
 \n^ajreturn FALSE;\n}">
<P "html_preformatted">
<T "The entry point is passed a pointer to the image loaded into memory and its\
  length. This pointer is typically e->load but may not necessarily be so. An i\
 mage loader should look for some magic bytes and possible verify a checksum to\
  insure the image is of the supported type.">
<P "Normal">
<T "The Forth ">
<T "is_exec" italic >
<T " routine looks for the first characters of the image to be the beginning of\
  a Forth text comment and if so, assumes it is a Forth image. It could also ch\
 eck that the rest of the image is all only ASCII characters if desired.">
<P "Normal">
<T "Return ">
<T "TRUE" italic >
<T " if the image is the correct format and loadable and ">
<T "FALSE" italic >
<T " if not.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"load-function\"">
<FV>
<E_F>
<T "load function">
<P "html_h4">
<T "The second entry actually loads the image and returns the entrypoint into t\
 he image:">
<P "Normal">
<T "/* run the Forth image - loading makes no sense for Forth\n */\nstatic Retc\
 ode\nforth_load(Environ *e, uByte *load, uInt loadlen, uInt *entrypoint)\n{\n^\
 aj*entrypoint = -1;\n^ajreturn interp_text(e, (Byte*)load, (Int)loadlen);\n}">
<P "html_preformatted">
<T "This routine interprets the Forth text at the load address directly rather \
 than return an entrypoint into the image. The entrypoint ">
<T "-1" bold >
<T " tells the caller that there is nothing more to do here.">
<P "Normal">
<T "An image loader may copy portions of the image into some other piece of all\
 ocated memory, perform relocation and other patching operations, then return a\
  pointer to the entrypoint in the new image. It may simply assume that the tar\
 get memory is safely outside of the SmartFirmware's address space and directly\
  copy portions of the image straight to where it needs to be. Please see the "\
 >
<T "coff.c" italic >
<T " and ">
<T "elf.c " italic >
<T "files for details.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Exec_entry\"">
<FV>
<E_F>
<T "Exec_entry">
<P "html_h4">
<T "Last the entry points are listed in an ">
<T "Exec_entry" italic >
<T " structure along with a name to identify this loader:">
<P "Normal">
<T "const Exec_entry exec_forth =\n{\n^aj\"Forth\",\n^ajforth_is_exec,\n^ajfort\
 h_load\n};">
<P "html_preformatted">
<T "Add a reference to this entry point in machdep.c's g_exec_list, and SmartFi\
 rmware now understands the new image format.">
<P "Normal">
<E_F>
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_35" evenHeader:Inherit firstHeader:Inherit evenFo\
 oter:Inherit sectNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:0>
<S_F fieldType:3>
<T "series \"main\"">
<FV>
<T "7. ">
<E_F>
<S_F fieldType:6 date:908505810 docType:200 appType:1 outDated
<start_eval_value>
<S_F fieldType:27 editable>
<T "html_tag -text \"<!-- This file created 12/26/1997 11:29 AM by Claris Home \
 Page version 2.0-->\" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<META NAME=GENERATOR CONTENT=\\\"Claris Home Page 2.0\\\">\
 \" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<X-SAS-WINDOW TOP=46 BOTTOM=766 LEFT=50 RIGHT=580>\" -text\
 Style \"html_unknown_text\"">
<FV>
<E_F>
<T "Plug-in filesystem">
<P "html_h1" level:0 >
<T "The plug-in filesystem code is a non-standard extension to OpenFirmware tha\
 t permits listing and loading files within filesystems on random-access media.\
  The ">
<S_F fieldType:16 editable
<start_eval_value>
<T "source files">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"Filesystem-files\" -pass \"SFChapter2.html\\
 " -text \"source files\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "source files" underline color:"HtmlLinkDefault@" >
<E_F>
<T " of this layer are located under the ">
<T "fs" italic >
<T " subdirectory.">
<P "Normal" level:0 >
<T "The plug-in filesystem works above the device-driver layer of code and belo\
 w the SmartFirmware ">
<T "disk-label" italic >
<T " package.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"How-it-works\"">
<FV>
<E_F>
<T "How it works">
<P "html_h2">
<T "When the SmartFirmware disk-label package (implemented in file disklbl.c) i\
 s opened by a disk device, it automatically inserts a new method into the disk\
  device named ">
<T "list-files" italic >
<T ". This hook allows the filesystem layer to be used to display the contents \
 of filesystems rather than simply loading them.">
<P "Normal" level:0 >
<T "Otherwise, the disk-label package simply calls the file-system hooks define\
 d in fs.c to do the work. These hooks iterate through the built-in supported f\
 ilesystems and try to identify various partition and filesystems on a drive.">
<P "Normal" level:0 >
<P "Normal" level:0 >
<T "A user-level command ">
<T "list-files" italic >
<T " is also added which behaves much as the user-level ">
<T "load" italic >
<T " Forth command but which also takes an optional directory string argument. \
 The ">
<T "list-files " italic >
<T "command then calls the">
<T " list-files" italic >
<T " method on the device just as the ">
<T "load" italic >
<T " command calls the ">
<T "load" italic >
<T " method.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"list-files\"">
<FV>
<E_F>
<T "list-files device-path:[partition,...] [filesys-path]">
<P "html_h4" level:0 >
<T "List files under a specified device possibly under an optional directory na\
 me.">
<P "html_blockquote" level:0 >
<T "Examples:">
<P "html_blockquote" level:0 >
<T "ok ">
<T "list-files /pci/scsi/disk@3" bold >
<T "\nDOS partition 0: fat12 (0x1)\nDOS partition 1: bsd (0xA5)\nDOS partition \
 2: unused (0x0)\nDOS partition 3: unused (0x0)\nok ">
<T "list-files /pci/scsi/disk@3:0" bold >
<T "\n Volume is DOS\nIO.SYS          33430\nMSDOS.SYS       37394\nCOMMAND.COM\
      47845\n[DOS]\nCONFIG.SYS      71\nAUTOEXEC.BAT    81\n...\nok ">
<T "list-files /pci/scsi/disk@3:1" bold >
<T "\nBSD partition a: ffs (7)\nBSD partition b: swap (1)\nBSD partition c: unu\
 sed (0)\nBSD partition d: unused (0)\n...\nok ">
<T "list-files /pci/scsi/disk@3:1,a" bold >
<T "\n[.]\n[..]\n[dev]\n[usr]\nkernel\n[root]\n[var]\n...\nok ">
<T "list-files /pci/scsi/disk@3:1,a /root" bold >
<T "\n[.]\n[..]\n.profile\n.exrc\nmbox\n.Xdefaults\n...\nok ">
<T "boot /pci/scsi/disk@3:1,a /kernel -s\n..." bold >
<P "html_preformatted" level:0 >
<T "Partitions">
<P "html_h4" level:0 >
<T "Disk partitions are simply viewed as directories in this scheme, only with \
 short names and no subdirectories. This allows easy nesting of partitions and \
 filesystems mostly to support x86 systems. For instance, the example above den\
 otes a DOS partition ">
<T "1" bold >
<T " that contains a BSD root partition ">
<T "a" bold >
<T " that in turn contains a BSD filesystem under which we are interested in th\
 e contents of ">
<T "/dir" bold >
<T ".">
<P "Normal" level:0 >
<T "Typically partitions should be noted in a comma-separated list after the de\
 vice name and a colon. File path names are usually indicated after a space as \
 part of the option arguments to a device. Beware of back-slashes for DOS path \
 names followed by a space as Forth may see it as a comment.">
<P "Normal" level:0 >
<T "Interface">
<P "html_h2">
<T "The ">
<T "g_filesys" italic >
<T " list must be defined in the target ">
<T "machdep.c" italic >
<T " file to list all supported built-in filesystems:">
<P "Normal" level:0 >
<T "extern Filesys g_dos_partition;\nextern Filesys g_dos_fat;\nextern Filesys \
 g_bsd_partition;\nextern Filesys g_bsd_ufs;\nextern Filesys g_iso9660_fs;\n^ka\
 \nFilesys *g_filesys[] =\n{\n^aj&g_dos_partition,\n^aj&g_dos_fat,\n#if defined\
 (__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)\n^aj&g_bsd_partit\
 ion,\n^aj&g_bsd_ufs,\n#endif\n     &g_iso9660_fs,\n^ajNULL\n};">
<P "html_preformatted" level:0 >
<T "Additional filesystem and partition schemes may be created and added to the\
  list.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"filesys-entry\"">
<FV>
<E_F>
<T "filesys entry">
<P "html_h4" level:0 >
<T "There is only one entry point to each particular filesystem. This is throug\
 h the single ">
<T "action" italic >
<T " function defined as follows:">
<P "Normal" level:0 >
<T "Retcode (*action)(Environ *e, Filesys_action what, Instance *disk,\n       \
  Byte *path, uLong loc, uByte *buf, uInt size,\n        uByte *retbuf, uLong *\
 val);">
<P "html_preformatted" level:0 >
<T "The simplest filesystem code to explore is in the files ">
<T "dospart.c" italic >
<T " and">
<T "bsdpart.c " italic >
<T "which handles the DOS and BSD partition schemes respectively. The actual fi\
 lesystem code is in ">
<T "dosfat.c" italic >
<T " and ">
<T "bsdufs.c" italic >
<T " and are considerably more complex, especially since much code has been cop\
 ied and modified from freely available software.">
<P "Normal" level:0 >
<T "The ">
<T "action" italic >
<T " routine is called with either one of ">
<T "FS_PROBE" italic >
<T ", ">
<T "FS_LIST" italic >
<T ", or ">
<T "FS_LOAD" italic >
<T " Filesys_action values to probe for a filesystem, list files within a files\
 ystem, or load a file from a filesystem respectively.">
<P "Normal" level:0 >
<T "The rest of the arguments are an opened instance to the ">
<T "disk" italic >
<T " device, a comma-separated list of ">
<T "path" italic >
<T " names, the location ">
<T "loc" italic >
<T " at which this filesystem must begin its operation on the disk, a DMA-safe \
 buffer ">
<T "buf" italic >
<T " to use for reading data from the disk, the ">
<T "size" italic >
<T " of the buffer (at least as large as the disk's reported block size), and a\
  return buffer ">
<T "retbuf" italic >
<T " and its optional length ">
<T "val" italic >
<T " to return any loaded data.">
<P "Normal" level:0 >
<T "The ">
<T "retbuf" italic >
<T " is also used to return a comma-separated list of probed partitions that is\
  subsequently stored as a property ">
<T "partition-types" italic >
<T " in the disk package. This list is generated in the order the filesystems a\
 re identified.">
<P "Normal" level:0 >
<T "As a filesystem probes, lists, or loads from a device, it must use the ">
<T "path" italic >
<T " argument to determine if it needs to forward those actions to sub-partitio\
 ns. It must first identify a partition or directory name to the first comma in\
  the ">
<T "path" italic >
<T ". If there is still something left to do, it must forward the request to th\
 e generic filesystem layer and let it probe, list, or load from any sub-partit\
 ions, after suitably adjusting the ">
<T "loc" italic >
<T " parameter.">
<P "Normal" level:0 >
<end_eval_value>
>
*LINK /cgt/src/bin/of/docs/SFChapter7.aw
<T "link \"/cgt/src/bin/of/docs/SFChapter7.aw\" -docType \"200\" -appType \"Wor\
 ds_\"">
<FV>
<S_F fieldType:17>
<T "hyper_target \"Plug-in-filesystem\"">
<FV>
<E_F>
<T "Plug-in filesystem">
<P "html_h1">
<T "The plug-in filesystem code is a non-standard extension to OpenFirmware tha\
 t permits listing and loading files within filesystems on random-access media.\
  The ">
<S_F fieldType:16 editable
<start_eval_value>
<T "source files">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"Filesystem-files\" -pass \"\" -text \"sourc\
 e files\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "source files" underline color:"HtmlLinkDefault@" >
<E_F>
<T " of this layer are located under the ">
<T "fs" italic >
<T " subdirectory.">
<P "Normal">
<T "The plug-in filesystem works above the device-driver layer of code and belo\
 w the SmartFirmware ">
<T "disk-label" italic >
<T " package.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"How-it-works\"">
<FV>
<E_F>
<T "How it works">
<P "html_h2">
<T "When the SmartFirmware disk-label package (implemented in file disklbl.c) i\
 s opened by a disk device, it automatically inserts a new method into the disk\
  device named ">
<T "list-files" italic >
<T ". This hook allows the filesystem layer to be used to display the contents \
 of filesystems rather than simply loading them.">
<P "Normal">
<T "Otherwise, the disk-label package simply calls the file-system hooks define\
 d in fs.c to do the work. These hooks iterate through the built-in supported f\
 ilesystems and try to identify various partition and filesystems on a drive.">
<P "Normal">
<P "Normal">
<T "A user-level command ">
<T "list-files" italic >
<T " is also added which behaves much as the user-level ">
<T "load" italic >
<T " Forth command but which also takes an optional directory string argument. \
 The ">
<T "list-files " italic >
<T "command then calls the">
<T " list-files" italic >
<T " method on the device just as the ">
<T "load" italic >
<T " command calls the ">
<T "load" italic >
<T " method.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"list-files\"">
<FV>
<E_F>
<T "list-files device-path:[partition,...] [filesys-path]">
<P "html_h4">
<T "List files under a specified device possibly under an optional directory na\
 me.">
<P "html_blockquote">
<T "Examples:">
<P "html_blockquote">
<T "ok ">
<T "list-files /pci/scsi/disk@3" bold >
<T "\nDOS partition 0: fat12 (0x1)\nDOS partition 1: bsd (0xA5)\nDOS partition \
 2: unused (0x0)\nDOS partition 3: unused (0x0)\nok ">
<T "list-files /pci/scsi/disk@3:0" bold >
<T "\n Volume is DOS\nIO.SYS          33430\nMSDOS.SYS       37394\nCOMMAND.COM\
      47845\n[DOS]\nCONFIG.SYS      71\nAUTOEXEC.BAT    81\n...\nok ">
<T "list-files /pci/scsi/disk@3:1" bold >
<T "\nBSD partition a: ffs (7)\nBSD partition b: swap (1)\nBSD partition c: unu\
 sed (0)\nBSD partition d: unused (0)\n...\nok ">
<T "list-files /pci/scsi/disk@3:1,a" bold >
<T "\n[.]\n[..]\n[dev]\n[usr]\nkernel\n[root]\n[var]\n...\nok ">
<T "list-files /pci/scsi/disk@3:1,a /root" bold >
<T "\n[.]\n[..]\n.profile\n.exrc\nmbox\n.Xdefaults\n...\nok ">
<T "boot /pci/scsi/disk@3:1,a /kernel -s\n..." bold >
<P "html_preformatted">
<T "Partitions">
<P "html_h4">
<T "Disk partitions are simply viewed as directories in this scheme, only with \
 short names and no subdirectories. This allows easy nesting of partitions and \
 filesystems mostly to support x86 systems. For instance, the example above den\
 otes a DOS partition ">
<T "1" bold >
<T " that contains a BSD root partition ">
<T "a" bold >
<T " that in turn contains a BSD filesystem under which we are interested in th\
 e contents of ">
<T "/dir" bold >
<T ".">
<P "Normal">
<T "Typically partitions should be noted in a comma-separated list after the de\
 vice name and a colon. File path names are usually indicated after a space as \
 part of the option arguments to a device. Beware of back-slashes for DOS path \
 names followed by a space as Forth may see it as a comment.">
<P "Normal">
<T "Interface">
<P "html_h2">
<T "The ">
<T "g_filesys" italic >
<T " list must be defined in the target ">
<T "machdep.c" italic >
<T " file to list all supported built-in filesystems:">
<P "Normal">
<T "extern Filesys g_dos_partition;\nextern Filesys g_dos_fat;\nextern Filesys \
 g_bsd_partition;\nextern Filesys g_bsd_ufs;\nextern Filesys g_iso9660_fs;\n^ka\
 \nFilesys *g_filesys[] =\n{\n^aj&g_dos_partition,\n^aj&g_dos_fat,\n#if defined\
 (__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)\n^aj&g_bsd_partit\
 ion,\n^aj&g_bsd_ufs,\n#endif\n     &g_iso9660_fs,\n^ajNULL\n};">
<P "html_preformatted">
<T "Additional filesystem and partition schemes may be created and added to the\
  list.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"filesys-entry\"">
<FV>
<E_F>
<T "filesys entry">
<P "html_h4">
<T "There is only one entry point to each particular filesystem. This is throug\
 h the single ">
<T "action" italic >
<T " function defined as follows:">
<P "Normal">
<T "Retcode (*action)(Environ *e, Filesys_action what, Instance *disk,\n       \
  Byte *path, uLong loc, uByte *buf, uInt size,\n        uByte *retbuf, uLong *\
 val);">
<P "html_preformatted">
<T "The simplest filesystem code to explore is in the files ">
<T "dospart.c" italic >
<T " and">
<T "bsdpart.c " italic >
<T "which handles the DOS and BSD partition schemes respectively. The actual fi\
 lesystem code is in ">
<T "dosfat.c" italic >
<T " and ">
<T "bsdufs.c" italic >
<T " and are considerably more complex, especially since much code has been cop\
 ied and modified from freely available software.">
<P "Normal">
<T "The ">
<T "action" italic >
<T " routine is called with either one of ">
<T "FS_PROBE" italic >
<T ", ">
<T "FS_LIST" italic >
<T ", or ">
<T "FS_LOAD" italic >
<T " Filesys_action values to probe for a filesystem, list files within a files\
 ystem, or load a file from a filesystem respectively.">
<P "Normal">
<T "The rest of the arguments are an opened instance to the ">
<T "disk" italic >
<T " device, a comma-separated list of ">
<T "path" italic >
<T " names, the location ">
<T "loc" italic >
<T " at which this filesystem must begin its operation on the disk, a DMA-safe \
 buffer ">
<T "buf" italic >
<T " to use for reading data from the disk, the ">
<T "size" italic >
<T " of the buffer (at least as large as the disk's reported block size), and a\
  return buffer ">
<T "retbuf" italic >
<T " and its optional length ">
<T "val" italic >
<T " to return any loaded data.">
<P "Normal">
<T "The ">
<T "retbuf" italic >
<T " is also used to return a comma-separated list of probed partitions that is\
  subsequently stored as a property ">
<T "partition-types" italic >
<T " in the disk package. This list is generated in the order the filesystems a\
 re identified.">
<P "Normal">
<T "As a filesystem probes, lists, or loads from a device, it must use the ">
<T "path" italic >
<T " argument to determine if it needs to forward those actions to sub-partitio\
 ns. It must first identify a partition or directory name to the first comma in\
  the ">
<T "path" italic >
<T ". If there is still something left to do, it must forward the request to th\
 e generic filesystem layer and let it probe, list, or load from any sub-partit\
 ions, after suitably adjusting the ">
<T "loc" italic >
<T " parameter.">
<P "Normal">
<E_F>
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_36" evenHeader:Inherit firstHeader:Inherit evenFo\
 oter:Inherit sectNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:0>
<S_F fieldType:3>
<T "series \"main\"">
<FV>
<T "8. ">
<E_F>
<S_F fieldType:6 date:908505826 docType:200 appType:1 outDated
<start_eval_value>
<S_F fieldType:27 editable>
<T "html_tag -text \"<!-- This file created 11/18/1997 3:57 PM by Claris Home P\
 age version 2.0-->\" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<META NAME=GENERATOR CONTENT=\\\"Claris Home Page 2.0\\\">\
 \" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<X-SAS-WINDOW TOP=38 BOTTOM=736 LEFT=166 RIGHT=696>\" -tex\
 tStyle \"html_unknown_text\"">
<FV>
<E_F>
<T "PCI-bus interface">
<P "html_h1" level:0 >
<T "The PCI bus code supports probing and initializing PCI devices. The ">
<S_F fieldType:16 editable
<start_eval_value>
<T "source files">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"PCI-files\" -pass \"SFChapter2.html\" -text\
  \"source files\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "source files" underline color:"HtmlLinkDefault@" >
<E_F>
<T " of this layer are located under the ">
<T "pci" italic >
<T " subdirectory.">
<P "Normal" level:0 >
<T "While most of the code is machine-independent, a certain amount must be cus\
 tomized to communicate with the PCI configuration registers, memory space, and\
  I/O spaces on the target system. The PCI drivers themselves are machine-indep\
 endent being written to communicate with the PCI bus layer. Finally, the targe\
 t ">
<T "machdep.c" italic >
<T " file must specify the built-in PCI devices and beginning the probe of the \
 PCI bus.">
<P "Normal" level:0 >
<T "This chapter will use the ">
<T "i386" italic >
<T " subdirectory as an example for how to write a PCI bus layer. This target r\
 uns on Intel x86 hardware using a FreeBSD boot-loader that turns on 32-bit add\
 ressing/protected mode.">
<P "Normal" level:0 >
<T "PCI-ISA bridges are detected as PCI devices and are automatically probed as\
  devices. If one is found, the ISA bus methods are installed and accessed thro\
 ugh the appropriate PCI calls. Otherwise an ISA bus interface may be explicitl\
 y added and probed as described in the ">
<S_F fieldType:16 editable
<start_eval_value>
<T "ISA chapter">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"SFChapter9.html\" -text \"ISA c\
 hapter\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "ISA chapter" underline color:"HtmlLinkDefault@" >
<E_F>
<T ".">
<P "Normal" level:0 >
<T "PCI-PCI bridges are also detected as PCI devices and automatically probed, \
 as are all devices behind them.">
<P "Normal" level:0 >
<T "Machine-dependent bus interface">
<P "html_h2">
<T "The bulk of the work to probe PCI buses and devices is handled in the file"\
 >
<T " pci.c" italic >
<T ", with interfaces to useful routines and structures in ">
<T "pci.h" italic >
<T ". This creates the /pci device node, installs the methods for the bus layer\
  as per the OpenFirmware specification, then probes the bus for all devices co\
 nnected to it and creates device nodes in the tree for all of them.">
<P "Normal" level:0 >
<T "The file">
<T " i386/pcibase.c" italic >
<T " defines the machine-dependent interface for the PCI bus. This is where PCI\
  configuration space, memory space, and I/O space are accessed, mapped, alloca\
 ted, and freed. All these functions must be defined for a target system.">
<P "Normal" level:0 >
<T "There are useful macros in pci.h to transform a PCI bus, device, function, \
 etc address into its constituent parts and back again to a 32-bit number.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_num_host_bridges\"">
<FV>
<E_F>
<T "pci_num_host_bridges">
<P "html_h3" level:0 >
<T "This must return the number of host PCI bridges in the system. There is no \
 way to determine how many PCI buses are built into a system, so this must be s\
 pecified explicitly. This does not affect PCI-PCI bridges, which are detected \
 and probed as a normal PCI device.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_config_read-pci_config_writ\"">
<FV>
<E_F>
<T "pci_config_read pci_config_write">
<P "html_h3" level:0 >
<T "These routines read and write a value from a specified address in PCI confi\
 guration space. For an x86, this is accessed through special registers in I/O \
 space using I/O instructions (defined ">
<S_F fieldType:16 editable
<start_eval_value>
<T "below">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"pci_io_read-pci_io_write\" -pass \" \" -tex\
 t \"below\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "below" underline color:"HtmlLinkDefault@" >
<E_F>
<T "). Other systems will simply memory-map configuration space at some known a\
 ddress.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_intr_ack-pci_special_cycle\"">
<FV>
<E_F>
<T "pci_intr_ack pci_special_cycle">
<P "html_h3" level:0 >
<T "These are special PCI words to implement the PCI Forth words \"intr-ack\" a\
 nd \"special-!\". They are otherwise unused by ">
<T "pci.c" italic >
<T ".">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_mem_read-pci_mem_write\"">
<FV>
<E_F>
<T "pci_mem_read pci_mem_write">
<P "html_h3" level:0 >
<T "These routines read and write a 1, 2, or 4-byte value from PCI memory space\
 . This is usually the same as the system's memory space but may not necessaril\
 y be so for 64-bit systems. Alignment issues must be handled for systems incap\
 able of byte or short access.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_mem_read64-pci_mem_write64\"">
<FV>
<E_F>
<T "pci_mem_read64 pci_mem_write64">
<P "html_h3" level:0 >
<T "These routines read and write a 1, 2, or 4-byte value from 64-bit PCI memor\
 y space. They should behave the same as pci_mem_read and pci_mem_write for 32-\
 bit addresses. The x86 does not support 64-bit addressing.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_io_read-pci_io_write\"">
<FV>
<E_F>
<T "pci_io_read pci_io_write">
<P "html_h3" level:0 >
<T "These perform 1, 2, and 4-byte reads and writes to and from PCI I/O space. \
 For an x86, this is the same as its normal I/O space using its special I/O ins\
 tructions. Most other systems will either map I/O space into memory or provide\
  special registers to peform I/O bus cycles.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_map_in-pci_map_out\"">
<FV>
<E_F>
<T "pci_map_in pci_map_out">
<P "html_h3" level:0 >
<T "These routines map a specified PCI address into and out of the system's mem\
 ory space to allow subsequent memory-mapped access to the PCI address. For an \
 x86, system memory space is the same as PCI memory space, so the pointer retur\
 ned is always the same.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_dma_alloc-pci_dma_free\"">
<FV>
<E_F>
<T "pci_dma_alloc pci_dma_free">
<P "html_h3" level:0 >
<T "These routines allocate and free a piece of memory suitable for DMA from a \
 PCI device. All memory is accessible from the PCI world on the x86, so malloc \
 is a good way to allocate memory. The memory block must be aligned for the ">
<T "DMA_PAGE_SIZE" italic >
<T ", and so to free the block, a list of globally allocated blocks must be mai\
 ntained to remember the original pointer allocated by ">
<T "malloc" italic >
<T " keyed by the virtual aligned address. Only a system memory address is retu\
 rned by these routines - it must still be mapped to a PCI device address ">
<S_F fieldType:16 editable
<start_eval_value>
<T "below">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"pci_map_in-pci_map_out\" -pass \" \" -text \
 \"below\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "below" underline color:"HtmlLinkDefault@" >
<E_F>
<T ".">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_dma_map_in-pci_dma_map_out\"">
<FV>
<E_F>
<T "pci_dma_map_in pci_dma_map_out">
<P "html_h3" level:0 >
<T "These routines convert a system memory address for a DMA block to an addres\
 s suitable for a PCI device to access. The memory must have been allocated by \
 ">
<T "pci_dma_alloc" italic >
<T " above.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_dma_sync\"">
<FV>
<E_F>
<T "pci_dma_sync">
<P "html_h3" level:0 >
<T "This routine must flush the specified DMA memory address out of cache to sy\
 nchronize a subsequent DMA operation. Otherwise the cached contents will not m\
 atch the actual data copied in using DMA. For the x86, a special instruction s\
 imply flushes the whole cache.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_init_addresses\"">
<FV>
<E_F>
<T "pci_init_addresses">
<P "html_h3" level:0 >
<T "This is called by the code in ">
<T "pci.c" italic >
<T " to initialize a structure with the memory requirements and specifications \
 for each PCI bus. The contents of the struct are defined in ">
<T "pci.h" italic >
<T ". All fields must be initialized to appropriate values to handle legacy ISA\
  I/O spaces, memory ranges, and so on. Unsupported fields should be simply set\
  to zero, as for the 64-bit entries on an x86.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pci_bus_package\"">
<FV>
<E_F>
<T "pci_bus_package">
<P "html_h3" level:0 >
<T "This is called by ">
<T "pci.c" italic >
<T " to return a pointer to a ">
<T "Package" italic >
<T " for a given host bridge number. For a system with only one host bridge, ">
<T "e->currpkg" italic >
<T " is sufficient. Other systems will need to keep a global table indexed by t\
 he host bridge number.">
<P "html_blockquote" level:0 >
<T "Driver interface">
<P "html_h2">
<T "Since PCI defines how to probe for devices, a built-in C PCI device driver \
 doesn't have to worry about it. It has to specify how to identify itself and a\
 n install routine that creates the device node and all associated properties."\
 >
<P "Normal" level:0 >
<T "Expansion ROMs on PCI devices are automatically probed for OpenFirmware Fco\
 de and executed if detected. Drivers in expansion ROMs take precedence over an\
 y built-in C drivers. If there are no drivers detected for a device, it is sti\
 ll inserted into the device tree with a generic configuration.">
<P "Normal" level:0 >
<T "Some example drivers are ">
<T "pci/pcidisp.c" italic >
<T " for generic frame-buffer display cards, ">
<T "pci/decether.c" italic >
<T " for Digital 21X4X* Ethernet chips, ">
<T "pci/ncrscsi.c" italic >
<T " for NCR/Symbios 53c8xx SCSI chips, and ">
<T "pci/pciisa.c" italic >
<T " for various PCI-ISA bridges.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Pci_driver-structure\"">
<FV>
<E_F>
<T "Pci_driver structure">
<P "html_h3" level:0 >
<T "The key code is at the bottom of the various PCI drivers to initialize a st\
 ructure ">
<T "Pci_driver" italic >
<T " defined in ">
<T "pci/pci.h" italic >
<T ". Here's an entry for an Intel PIXX3 PCI-ISA bridge from ">
<T "pci/pciisa.c" italic >
<T ":">
<P "Normal" level:0 >
<T "/* Intel 82371SB (PIXX3) PCI-ISA bridge */\nPci_driver intel_piix3_driver =\
 \n{\n^aj{ 0, 0, 0, 0, 0,\n^aj^aj0x060100, 0x8086, 0x7000, 0, 0, 0 },\n^aj{ 0, \
 0, 0, 0, 0,\n^aj^aj0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0, 0, 0 },\n^ajinstall_\
 pciisa_driver\n};">
<P "html_preformatted" level:0 >
<T "This struct is used to search for a built-in C driver when a new PCI device\
  is detected by ">
<T "pci/pci.c" italic >
<T ". The first entry is for a ">
<T "pci_device_info" italic >
<T " called \"match\", the second for a \"mask\", and the last is a pointer to \
 a C function to install the device driver.">
<P "Normal" level:0 >
<T "The ">
<T "match" italic >
<T " and ">
<T "mask" italic >
<T " fields are complementary.">
<T "match" italic >
<T " tells pci/pci.c which values are expected, and ">
<T "mask" italic >
<T " tells it which portions of the values are important. A new device's ID fie\
 lds are or-ed with ">
<T "mask" italic >
<T " and then compared to ">
<T "match" italic >
<T " to identify the device. For the PCI-ISA bridge above, the classcode, vendo\
 r ID, and device ID must match exactly to identify this chip.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Install-PCI-driver\"">
<FV>
<E_F>
<T "Install PCI driver">
<P "html_h3" level:0 >
<T "The install function for a driver must be declared using the ">
<T "PCI" italic >
<T " macro defined in ">
<T "pci/pci.h" italic >
<T " as follows:">
<P "Normal" level:0 >
<T "PCI(install_pciisa_driver) { ... }">
<P "html_preformatted" level:0 >
<T "This will pass in a pointer to the current ">
<T "Environ" italic >
<T ", a pointer to the newly created and uninitialized device ">
<T "Package" italic >
<T ", and a pointer to the ">
<T "Pci_device_info" italic >
<T " describing the chip that was just probed and successfully matched with a "\
 >
<T "Pci_driver" italic >
<T " described ">
<S_F fieldType:16 editable
<start_eval_value>
<T "above">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"Pci_driver-structure\" -pass \" \" -text \"\
 above\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "above" underline color:"HtmlLinkDefault@" >
<E_F>
<T ".">
<P "Normal" level:0 >
<T "The first thing this routine should do is call ">
<T "pci_load_reg_and_name_props" italic >
<T " to initialize the \"reg\" and \"name\" properties to reasonable values. Th\
 is may be handled explicitly if desired - ">
<T "pci_load_reg_and_name_props" italic >
<T " is only provided for convenience. It sets \"name\" to the generic name, if\
  any, and otherwise to the default \"pciN,N\" form, disables the device, probe\
 s all the BARs to initialize the \"reg\" property, adding in the expansion ROM\
  if any is detected.">
<P "Normal" level:0 >
<T "Next, the driver should initialize the \"device_type\" property if appropri\
 ate. Then any methods should be created and a copy of the ">
<T "Pci_device_info" italic >
<T " saved if needed by the methods. It is generally easier to save and access \
 this C structure rather than decode the PCI physaddr properties, but it is not\
  required.">
<P "Normal" level:0 >
<T "The driver methods simply need to perform the appropriate actions for that \
 type of device, such as open/close or read/write. They must call the various p\
 ci_dma_alloc/free, pci_dma_map_in/out, pci_dma_sync, and pci_map_in/out as app\
 ropriate to correctly translate PCI address and host addresses on any platform\
 . The ">
<T "pci/decether.c" italic >
<T " driver is a good example of how this should work. It also has to be carefu\
 l with device endian-ness as PCI devices are little-endian, but the host may n\
 ot be.">
<P "Normal" level:0 >
<T "machdep.c interface">
<P "html_h2">
<T "Finally, the PCI interface has to be hooked in through the system's ">
<T "machdep.c" italic >
<T ".">
<P "Normal" level:0 >
<T "All desired built-in PCI drivers must be explicitly specified and linked in\
  by creating a global ">
<T "pci_drivers" italic >
<T " list:">
<P "Normal" level:0 >
<T "extern Pci_driver pci_display_driver;\nextern Pci_driver digital_21x4x_driv\
 er;\nextern Pci_driver ncr_53C8xx_driver;\nextern Pci_driver intel_piix3_drive\
 r;\n...\n^ka\nconst Pci_driver *pci_drivers[] =\n{\n^aj&pci_display_driver,\n^\
 aj&digital_21x4x_driver,\n^aj&ncr_53C8xx_driver,\n^aj&intel_piix3_driver,\n^aj\
 ...\n^ajNULL\n};\n^ka">
<P "html_preformatted" level:0 >
<T "There may be more than one type of driver if needed, for instance to handle\
  different brands of PCI-ISA bridges or Ethernet devices. These drivers will o\
 nly be used if no on-board Fcode option ROM is detected on the device.">
<P "Normal" level:0 >
<T "The ">
<T "pci_install" italic >
<T " function has to be added to the global ">
<T "install_list" italic >
<T "::">
<P "Normal" level:0 >
<T "...\nEC(install_pci);\n...\n^ka\nconst Command install_list[] =\n{\n^ajinst\
 all_root,^aj/* should be first */\n^ajinstall_memory,^aj/* should be second */\
 \n^aj...\n^ajinstall_pci,\n^aj...\n^ajNULL\n};">
<P "html_preformatted" level:0 >
<T "This does not probe the PCI bus if it is detected but simply installs the P\
 CI subsystem into the resulting SmartFirmware image. Probing has to be done ex\
 plicitly in the routine ">
<T "machine_probe_all" italic >
<T ":">
<P "Normal" level:0 >
<T "CC(machine_probe_all)^aj^aj/* (--) */\n{\n^ajRetcode ret;\n^ka\n^aj...\n^ka\
 \n^aj/* point e->currpkg to the PCI bus node */\n^ajPUSH(e, \"/pci\");\n^ajPUS\
 H(e, 4);\n^ajret = execute_word(e, \"find-device\");\n^ka\n^ajif (ret == NO_ER\
 ROR)\n^aj^ajret = execute_word(e, \"probe-pci\");\n^ka\n^aj...\n^ka\n^ajreturn\
  ret;\n}">
<P "html_preformatted" level:0 >
<T "If all goes well, there should be a device tree under /pci when SmartFirmwa\
 re boots.">
<P "Normal" level:0 >
<end_eval_value>
>
*LINK /cgt/src/bin/of/docs/SFChapter8.aw
<T "link \"/cgt/src/bin/of/docs/SFChapter8.aw\" -docType \"200\" -appType \"Wor\
 ds_\"">
<FV>
<S_F fieldType:17>
<T "hyper_target \"PCI-bus-interface\"">
<FV>
<E_F>
<T "PCI-bus interface">
<P "html_h1">
<T "The PCI bus code supports probing and initializing PCI devices. The ">
<S_F fieldType:16 editable
<start_eval_value>
<T "source files">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"PCI-files\" -pass \"\" -text \"source files\
 \" -textStyle \"html_hyperlink_text\"">
<FV>
<T "source files" underline color:"HtmlLinkDefault@" >
<E_F>
<T " of this layer are located under the ">
<T "pci" italic >
<T " subdirectory.">
<P "Normal">
<T "While most of the code is machine-independent, a certain amount must be cus\
 tomized to communicate with the PCI configuration registers, memory space, and\
  I/O spaces on the target system. The PCI drivers themselves are machine-indep\
 endent being written to communicate with the PCI bus layer. Finally, the targe\
 t ">
<T "machdep.c" italic >
<T " file must specify the built-in PCI devices and beginning the probe of the \
 PCI bus.">
<P "Normal">
<T "This chapter will use the ">
<T "i386" italic >
<T " subdirectory as an example for how to write a PCI bus layer. This target r\
 uns on Intel x86 hardware using a FreeBSD boot-loader that turns on 32-bit add\
 ressing/protected mode.">
<P "Normal">
<T "PCI-ISA bridges are detected as PCI devices and are automatically probed as\
  devices. If one is found, the ISA bus methods are installed and accessed thro\
 ugh the appropriate PCI calls. Otherwise an ISA bus interface may be explicitl\
 y added and probed as described in the ">
<S_F fieldType:16 editable
<start_eval_value>
<T "ISA chapter">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"ISA-bus-interface\" -pass \"\" -text \"ISA \
 chapter\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "ISA chapter" underline color:"HtmlLinkDefault@" >
<E_F>
<T ".">
<P "Normal">
<T "PCI-PCI bridges are also detected as PCI devices and automatically probed, \
 as are all devices behind them.">
<P "Normal">
<T "Machine-dependent bus interface">
<P "html_h2">
<T "The bulk of the work to probe PCI buses and devices is handled in the file"\
 >
<T " pci.c" italic >
<T ", with interfaces to useful routines and structures in ">
<T "pci.h" italic >
<T ". This creates the /pci device node, installs the methods for the bus layer\
  as per the OpenFirmware specification, then probes the bus for all devices co\
 nnected to it and creates device nodes in the tree for all of them.">
<P "Normal">
<T "The file">
<T " i386/pcibase.c" italic >
<T " defines the machine-dependent interface for the PCI bus. This is where PCI\
  configuration space, memory space, and I/O space are accessed, mapped, alloca\
 ted, and freed. All these functions must be defined for a target system.">
<P "Normal">
<T "There are useful macros in pci.h to transform a PCI bus, device, function, \
 etc address into its constituent parts and back again to a 32-bit number.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_num_host_bridges\"">
<FV>
<E_F>
<T "pci_num_host_bridges">
<P "html_h3">
<T "This must return the number of host PCI bridges in the system. There is no \
 way to determine how many PCI buses are built into a system, so this must be s\
 pecified explicitly. This does not affect PCI-PCI bridges, which are detected \
 and probed as a normal PCI device.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_config_read-pci_config_writ\"">
<FV>
<E_F>
<T "pci_config_read pci_config_write">
<P "html_h3">
<T "These routines read and write a value from a specified address in PCI confi\
 guration space. For an x86, this is accessed through special registers in I/O \
 space using I/O instructions (defined ">
<S_F fieldType:16 editable
<start_eval_value>
<T "below">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"pci_io_read-pci_io_write\" -pass \" \" -tex\
 t \"below\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "below" underline color:"HtmlLinkDefault@" >
<E_F>
<T "). Other systems will simply memory-map configuration space at some known a\
 ddress.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_intr_ack-pci_special_cycle\"">
<FV>
<E_F>
<T "pci_intr_ack pci_special_cycle">
<P "html_h3">
<T "These are special PCI words to implement the PCI Forth words \"intr-ack\" a\
 nd \"special-!\". They are otherwise unused by pci.c.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_mem_read-pci_mem_write\"">
<FV>
<E_F>
<T "pci_mem_read pci_mem_write">
<P "html_h3">
<T "These routines read and write a 1, 2, or 4-byte value from PCI memory space\
 . This is usually the same as the system's memory space but may not necessaril\
 y be so for 64-bit systems. Alignment issues must be handled for systems incap\
 able of byte or short access.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_mem_read64-pci_mem_write64\"">
<FV>
<E_F>
<T "pci_mem_read64 pci_mem_write64">
<P "html_h3">
<T "These routines read and write a 1, 2, or 4-byte value from 64-bit PCI memor\
 y space. They should behave the same as pci_mem_read and pci_mem_write for 32-\
 bit addresses. The x86 does not support 64-bit addressing.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_io_read-pci_io_write\"">
<FV>
<E_F>
<T "pci_io_read pci_io_write">
<P "html_h3">
<T "These perform 1, 2, and 4-byte reads and writes to and from PCI I/O space. \
 For an x86, this is the same as its normal I/O space using its special I/O ins\
 tructions. Most other systems will either map I/O space into memory or provide\
  special registers to peform I/O bus cycles.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_map_in-pci_map_out\"">
<FV>
<E_F>
<T "pci_map_in pci_map_out">
<P "html_h3">
<T "These routines map a specified PCI address into and out of the system's mem\
 ory space to allow subsequent memory-mapped access to the PCI address. For an \
 x86, system memory space is the same as PCI memory space, so the pointer retur\
 ned is always the same.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_dma_alloc-pci_dma_free\"">
<FV>
<E_F>
<T "pci_dma_alloc pci_dma_free">
<P "html_h3">
<T "These routines allocate and free a piece of memory suitable for DMA from a \
 PCI device. All memory is accessible from the PCI world on the x86, so malloc \
 is a good way to allocate memory. The memory block must be aligned for the DMA\
 _PAGE_SIZE, and so to free the block, a list of globally allocated blocks must\
  be maintained to remember the original pointer allocated by malloc keyed by t\
 he virtual aligned address. Only a system memory address is returned by these \
 routines - it must still be mapped to a PCI device address ">
<S_F fieldType:16 editable
<start_eval_value>
<T "below">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"pci_map_in-pci_map_out\" -pass \" \" -text \
 \"below\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "below" underline color:"HtmlLinkDefault@" >
<E_F>
<T ".">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_dma_map_in-pci_dma_map_out\"">
<FV>
<E_F>
<T "pci_dma_map_in pci_dma_map_out">
<P "html_h3">
<T "These routines convert a system memory address for a DMA block to an addres\
 s suitable for a PCI device to access. The memory must have been allocated by \
 pci_dma_alloc above.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_dma_sync\"">
<FV>
<E_F>
<T "pci_dma_sync">
<P "html_h3">
<T "This routine must flush the specified DMA memory address out of cache to sy\
 nchronize a subsequent DMA operation. Otherwise the cached contents will not m\
 atch the actual data copied in using DMA. For the x86, a special instruction s\
 imply flushes the whole cache.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_init_addresses\"">
<FV>
<E_F>
<T "pci_init_addresses">
<P "html_h3">
<T "This is called by the code in pci.c to initialize a structure with the memo\
 ry requirements and specifications for each PCI bus. The contents of the struc\
 t are defined in pci.h. All fields must be initialized to appropriate values t\
 o handle legacy ISA I/O spaces, memory ranges, and so on. Unsupported fields s\
 hould be simply set to zero, as for the 64-bit entries on an x86.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"pci_bus_package\"">
<FV>
<E_F>
<T "pci_bus_package">
<P "html_h3">
<T "This is called by pci.c to return a pointer to a Package for a given host b\
 ridge number. For a system with only one host bridge, e->currpkg is sufficient\
 . Other systems will need to keep a global table indexed by the host bridge nu\
 mber.">
<P "html_blockquote">
<T "Driver interface">
<P "html_h2">
<T "Since PCI defines how to probe for devices, a built-in C PCI device driver \
 doesn't have to worry about it. It has to specify how to identify itself and a\
 n install routine that creates the device node and all associated properties."\
 >
<P "Normal">
<T "Expansion ROMs on PCI devices are automatically probed for OpenFirmware Fco\
 de and executed if detected. Drivers in expansion ROMs take precedence over an\
 y built-in C drivers. If there are no drivers detected for a device, it is sti\
 ll inserted into the device tree with a generic configuration.">
<P "Normal">
<T "Some example drivers are ">
<T "pci/pcidisp.c" italic >
<T " for generic frame-buffer display cards, ">
<T "pci/decether.c" italic >
<T " for Digital 21X4X* Ethernet chips, ">
<T "pci/ncrscsi.c" italic >
<T " for NCR/Symbios 53c8xx SCSI chips, and ">
<T "pci/pciisa.c" italic >
<T " for various PCI-ISA bridges.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Pci_driver-structure\"">
<FV>
<E_F>
<T "Pci_driver structure">
<P "html_h3">
<T "The key code is at the bottom of the various PCI drivers to initialize a st\
 ructure ">
<T "Pci_driver" italic >
<T " defined in ">
<T "pci/pci.h" italic >
<T ". Here's an entry for an Intel PIXX3 PCI-ISA bridge from ">
<T "pci/pciisa.c" italic >
<T ":">
<P "Normal">
<T "/* Intel 82371SB (PIXX3) PCI-ISA bridge */\nPci_driver intel_piix3_driver =\
 \n{\n^aj{ 0, 0, 0, 0, 0,\n^aj^aj0x060100, 0x8086, 0x7000, 0, 0, 0 },\n^aj{ 0, \
 0, 0, 0, 0,\n^aj^aj0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0, 0, 0 },\n^ajinstall_\
 pciisa_driver\n};">
<P "html_preformatted">
<T "This struct is used to search for a built-in C driver when a new PCI device\
  is detected by ">
<T "pci/pci.c" italic >
<T ". The first entry is for a ">
<T "pci_device_info" italic >
<T " called \"match\", the second for a \"mask\", and the last is a pointer to \
 a C function to install the device driver.">
<P "Normal">
<T "The ">
<T "match" italic >
<T " and ">
<T "mask" italic >
<T " fields are complementary.">
<T "match" italic >
<T " tells pci/pci.c which values are expected, and ">
<T "mask" italic >
<T " tells it which portions of the values are important. A new device's ID fie\
 lds are or-ed with ">
<T "mask" italic >
<T " and then compared to ">
<T "match" italic >
<T " to identify the device. For the PCI-ISA bridge above, the classcode, vendo\
 r ID, and device ID must match exactly to identify this chip.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Install-PCI-driver\"">
<FV>
<E_F>
<T "Install PCI driver">
<P "html_h3">
<T "The install function for a driver must be declared using the ">
<T "PCI" italic >
<T " macro defined in ">
<T "pci/pci.h" italic >
<T " as follows:">
<P "Normal">
<T "PCI(install_pciisa_driver) { ... }">
<P "html_preformatted">
<T "This will pass in a pointer to the current ">
<T "Environ" italic >
<T ", a pointer to the newly created and uninitialized device ">
<T "Package" italic >
<T ", and a pointer to the ">
<T "Pci_device_info" italic >
<T " describing the chip that was just probed and successfully matched with a "\
 >
<T "Pci_driver" italic >
<T " described ">
<S_F fieldType:16 editable
<start_eval_value>
<T "above">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"Pci_driver-structure\" -pass \"\" -text \"a\
 bove\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "above" underline color:"HtmlLinkDefault@" >
<E_F>
<T ".">
<P "Normal">
<T "The first thing this routine should do is call ">
<T "pci_load_reg_and_name_props" italic >
<T " to initialize the \"reg\" and \"name\" properties to reasonable values. Th\
 is may be handled explicitly if desired - ">
<T "pci_load_reg_and_name_props" italic >
<T " is only provided for convenience. It sets \"name\" to the generic name, if\
  any, and otherwise to the default \"pciN,N\" form, disables the device, probe\
 s all the BARs to initialize the \"reg\" property, adding in the expansion ROM\
  if any is detected.">
<P "Normal">
<T "Next, the driver should initialize the \"device_type\" property if appropri\
 ate. Then any methods should be created and a copy of the ">
<T "Pci_device_info" italic >
<T " saved if needed by the methods. It is generally easier to save and access \
 this C structure rather than decode the PCI physaddr properties, but it is not\
  required.">
<P "Normal">
<T "The driver methods simply need to perform the appropriate actions for that \
 type of device, such as open/close or read/write. They must call the various p\
 ci_dma_alloc/free, pci_dma_map_in/out, pci_dma_sync, and pci_map_in/out as app\
 ropriate to correctly translate PCI address and host addresses on any platform\
 . The ">
<T "pci/decether.c" italic >
<T " driver is a good example of how this should work. It also has to be carefu\
 l with device endian-ness as PCI devices are little-endian, but the host may n\
 ot be.">
<P "Normal">
<T "machdep.c interface">
<P "html_h2">
<T "Finally, the PCI interface has to be hooked in through the system's ">
<T "machdep.c" italic >
<T ".">
<P "Normal">
<T "All desired built-in PCI drivers must be explicitly specified and linked in\
  by creating a global ">
<T "pci_drivers" italic >
<T " list:">
<P "Normal">
<T "extern Pci_driver pci_display_driver;\nextern Pci_driver digital_21x4x_driv\
 er;\nextern Pci_driver ncr_53C8xx_driver;\nextern Pci_driver intel_piix3_drive\
 r;\n...\n^ka\nconst Pci_driver *pci_drivers[] =\n{\n^aj&pci_display_driver,\n^\
 aj&digital_21x4x_driver,\n^aj&ncr_53C8xx_driver,\n^aj&intel_piix3_driver,\n^aj\
 ...\n^ajNULL\n};">
<P "html_preformatted">
<T "There may be more than one type of driver if needed, for instance to handle\
  different brands of PCI-ISA bridges or Ethernet devices. These drivers will o\
 nly be used if no on-board Fcode option ROM is detected on the device.">
<P "Normal">
<T "The ">
<T "pci_install" italic >
<T " function has to be added to the global ">
<T "install_list" italic >
<T "::">
<P "Normal">
<T "...\nEC(install_pci);\n...\n^ka\nconst Command install_list[] =\n{\n^ajinst\
 all_root,^aj/* should be first */\n^ajinstall_memory,^aj/* should be second */\
 \n^aj...\n^ajinstall_pci,\n^aj...\n^ajNULL\n};">
<P "html_preformatted">
<T "This does not probe the PCI bus if it is detected but simply installs the P\
 CI subsystem into the resulting SmartFirmware image. Probing has to be done ex\
 plicitly in the routine ">
<T "machine_probe_all" italic >
<T ":">
<P "Normal">
<T "CC(machine_probe_all)^aj^aj/* (--) */\n{\n^ajRetcode ret;\n^ka\n^aj...\n^ka\
 \n^aj/* point e->currpkg to the PCI bus node */\n^ajPUSH(e, \"/pci\");\n^ajPUS\
 H(e, 4);\n^ajret = execute_word(e, \"find-device\");\n^ka\n^ajif (ret == NO_ER\
 ROR)\n^aj^ajret = execute_word(e, \"probe-pci\");\n^ka\n^aj...\n^ka\n^ajreturn\
  ret;\n}">
<P "html_preformatted">
<T "If all goes well, there should be a device tree under /pci when SmartFirmwa\
 re boots.">
<P "Normal">
<E_F>
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_37" evenHeader:Inherit firstHeader:Inherit evenFo\
 oter:Inherit sectNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:0>
<S_F fieldType:3>
<T "series \"main\"">
<FV>
<T "9. ">
<E_F>
<S_F fieldType:6 date:908505893 docType:200 appType:1 outDated
<start_eval_value>
<S_F fieldType:27 editable>
<T "html_tag -text \"<!-- This file created 11/18/1997 4:25 PM by Claris Home P\
 age version 2.0-->\" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<META NAME=GENERATOR CONTENT=\\\"Claris Home Page 2.0\\\">\
 \" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<X-SAS-WINDOW TOP=44 BOTTOM=742 LEFT=88 RIGHT=618>\" -text\
 Style \"html_unknown_text\"">
<FV>
<E_F>
<T "ISA-bus interface">
<P "html_h1" level:0 >
<T "The ISA bus code supports probing and initializing legacy ISA devices. The \
 ">
<S_F fieldType:16 editable
<start_eval_value>
<T "source files">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"ISA-files\" -pass \"SFChapter2.html\" -text\
  \"source files\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "source files" underline color:"HtmlLinkDefault@" >
<E_F>
<T " of this layer are located under the ">
<T "isa" italic >
<T " subdirectory.">
<P "Normal" level:0 >
<T "While most of the code is machine-independent, a certain amount must be cus\
 tomized to communicate with the ISA configuration registers, memory space, and\
  I/O spaces on the target system. The ISA drivers themselves are machine-indep\
 endent being written to communicate with the ISA bus layer. Finally, the targe\
 t ">
<T "machdep.c" italic >
<T " file must specify the built-in ISA devices and beginning the probe of the \
 ISA bus.">
<P "Normal" level:0 >
<T "This chapter will use the ">
<T "i386" italic >
<T " subdirectory as an example for how to write a ISA bus layer. This target r\
 uns on Intel x86 hardware using a FreeBSD boot-loader that turns on 32-bit add\
 ressing/protected mode.">
<P "Normal" level:0 >
<T "PCI-ISA bridges are detected as PCI devices and are automatically probed as\
  devices. If one is found, the ISA bus methods are installed and accessed thro\
 ugh the appropriate PCI calls as described in the ">
<S_F fieldType:16 editable
<start_eval_value>
<T "PCI chapter">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"SFChapter8.html\" -text \"PCI c\
 hapter\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "PCI chapter" underline color:"HtmlLinkDefault@" >
<E_F>
<T ". These PCI methods will override the pre-defined ISA interface and probe f\
 or ISA devices.">
<P "Normal" level:0 >
<T "The biggest assumption in this code is that there is only a single ISA bus \
 in the entire system even though there may be multiple PCI host bridges.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Machine-dependent-bus-interface\"">
<FV>
<E_F>
<T "Machine-dependent bus interface">
<P "html_h2">
<T "The ISA bus interface is managed through a set of global function pointers \
 defined in ">
<T "isa/isa.c" italic >
<T " and declared in ">
<T "isa/isa.h" italic >
<T ". These function pointers must be initialized to the appropriate routines t\
 o access the ISA bus. A PCI-ISA bridge will override these function pointers. \
 They may be explicitly intiialized for a system with only an ISA bus as in the\
  file ">
<T "i386/isabase.c" italic >
<T ".">
<P "Normal" level:0 >
<T "The various routines in the ">
<T "isabase.c" italic >
<T " file must behave pretty much like the routines of similar names in ">
<T "pcibase.c" italic >
<T ", although being much simpler.">
<P "Normal" level:0 >
<T "isa_mem_read isa_mem_write">
<P "html_h3" level:0 >
<T "Read and write 1, 2, and 4 byte quantities from/to ISA memory space.">
<P "html_blockquote" level:0 >
<T "isa_io_read isa_io_write">
<P "html_h3" level:0 >
<T "Read and write 1, 2, and 4 byte quantities from/to ISA I/O space.">
<P "html_blockquote" level:0 >
<T "isa_map_in isa_map_out">
<P "html_h3" level:0 >
<T "Map an ISA address into and out of system memory space.">
<P "html_blockquote" level:0 >
<T "isa_dma_alloc isa_dma_free">
<P "html_h3" level:0 >
<T "Allocate and free memory suiltably aligned for DMA from system memory.">
<P "html_blockquote" level:0 >
<T "isa_dma_map_in isa_dma_map_out">
<P "html_h3" level:0 >
<T "Map a system DMA address into and out of ISA space.">
<P "html_blockquote" level:0 >
<T "isa_dma_sync">
<P "html_h3" level:0 >
<T "Flush caches so that a DMA may be safely performed.">
<P "html_blockquote" level:0 >
<T "^ka">
<P "Normal" level:0 >
<T "The function ">
<T "install_isabase" italic >
<T " must explicitly set the global ISA function pointers to the routines defin\
 ed to perform these actions. ">
<T "install_isabase" italic >
<T " is called from ">
<T "machdep.c" italic >
<T "'s ">
<T "machine_probe_all" italic >
<T ".">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Driver-interface\"">
<FV>
<E_F>
<T "Driver interface">
<P "html_h2">
<T "Declaring a built-in ISA C driver is more difficult than a PCI driver since\
  every thing about the driver must be explicitly specified. The first step is \
 to fill in an ">
<T "Isa_device" italic >
<T " struct with the appropriate info. This struct is declared in ">
<T "isa/isa.h" italic >
<T ". The ">
<T "isa/kbd.c" italic >
<T " driver looks like this:">
<P "Normal" level:0 >
<T "Isa_device isa_keyboard =\n{\n^aj\"keyboard\",^aj^aj/* device name */\n^aj\\
 "keyboard\",^aj^aj/* device type */\n^ajISA_IO_ADDRESS,^aj/* I/O or memory add\
 ress? */\n^aj0x60,^aj^aj^aj/* address - physlo */\n^aj5,^aj^aj^aj/* number of \
 bytes at address */\n^aj{ 1, 0 },^aj^aj/* IRQ number and type */\n^aj{ -1, },^\
 aj^aj/* DMA info, if any */\n^aj0x0,^aj^aj^aj/* BIOS ROM address */\n^aj0, NUL\
 L, ^aj^aj/* no extra reg props */\n^ajkbd_probe,\n^ajkbd_install,\n^ajkbd_meth\
 ods\n};">
<P "html_preformatted" level:0 >
<T "The isa/isa.c probe code calls all probe function pointer for all built-in \
 ISA devices. If the probe function returns successful, then the install functi\
 on pointer is called. The methods entry points to the method table for the dev\
 ice.">
<P "Normal" level:0 >
<T "Both probe and install routines must be declared using the ">
<T "ISA" italic >
<T " macro defined in ">
<T "isa/isa.h" italic >
<T ".">
<P "Normal" level:0 >
<T "The probe function should take care when probing for itself as it is fairly\
  easy to lock up the ISA bus. Some probe functions may simply assume that a de\
 vice is present.">
<P "Normal" level:0 >
<T "The install function should allocate any additional memory it needs, set it\
 s dev->self parameter to this data, then call the ">
<T "new_isa_device" italic >
<T " function to create the device. ">
<T "new_isa_device" italic >
<T " uses the ">
<T "Isa_device" italic >
<T " info to create the new device node under the /isa node with the correct na\
 me, type, and reg properties, and to create any methods for the device. ">
<T "new_isa_device" italic >
<T " is simply for convenience and is not required.">
<P "Normal" level:0 >
<T "Multiple devices may the probe, install, and methods tables but simply have\
  different IRQs and ISA addresses. Please see ">
<T "isa/ns16550.c" italic >
<T " for an example of a serial driver for the four tradition ISA ports com1-co\
 m4.">
<P "Normal" level:0 >
<P "html_h2" level:0 >
<P "html_hr" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"machdep-interface\"">
<FV>
<E_F>
<T "machdep.c interface">
<P "Normal" level:0 >
<T "An example for how to link in an ISA bus is in ">
<T "i386/machdep.c" italic >
<T ".">
<P "Normal" level:0 >
<T "First all built-in ISA drivers must be entered into the global ">
<T "isa_devices" italic >
<T " list:">
<P "Normal" level:0 >
<T "extern Isa_device ns16550_com1;\nextern Isa_device ns16550_com2;\nextern Is\
 a_device isa_keyboard;\nextern Isa_device vga_display;\n...\n^ka\nIsa_device *\
 isa_devices[] =\n{\n^aj&ns16550_com1,\n^aj&ns16550_com2,\n^aj&isa_keyboard,\n^\
 aj&vga_display,\n^aj...\n^ajNULL\n};">
<P "html_preformatted" level:0 >
<T "Then the machine_probe_all routine must first install the ISA base routines\
  to initialize the ISA subsystem, then probe for ISA devices. Here is a simpli\
 fied example for a system with only a single ISA bus:">
<P "Normal" level:0 >
<T "CC(machine_probe_all)^aj^aj/* (--) */\n{\n^ajPackage *isa = new_package(e->\
 root);\n^ajinstall_isabase(e);^aj/* initialize ISA subsystem */\n^ajreturn ins\
 tall_isa(e, isa);^aj/* probe for devices */\n}">
<P "html_preformatted" level:0 >
<T "The ">
<T "i386/machdep.c" italic >
<T " file has a somewhat more complex machine_probe_all that will first probe f\
 or a PCI bus, and if none is found, only then initialize an ISA bus. If a PCI \
 bus is found, it assumes that a PCI-ISA bridge will also be found thus initial\
 izing the ISA subsystem and probing for ISA devices.">
<P "Normal" level:0 >
<end_eval_value>
>
*LINK /cgt/src/bin/of/docs/SFChapter9.aw
<T "link \"/cgt/src/bin/of/docs/SFChapter9.aw\" -docType \"200\" -appType \"Wor\
 ds_\"">
<FV>
<S_F fieldType:17>
<T "hyper_target \"ISA-bus-interface\"">
<FV>
<E_F>
<T "ISA-bus interface">
<P "html_h1">
<T "The ISA bus code supports probing and initializing legacy ISA devices. The \
 ">
<S_F fieldType:16 editable
<start_eval_value>
<T "source files">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"ISA-files\" -pass \"\" -text \"source files\
 \" -textStyle \"html_hyperlink_text\"">
<FV>
<T "source files" underline color:"HtmlLinkDefault@" >
<E_F>
<T " of this layer are located under the ">
<T "isa" italic >
<T " subdirectory.">
<P "Normal">
<T "While most of the code is machine-independent, a certain amount must be cus\
 tomized to communicate with the ISA configuration registers, memory space, and\
  I/O spaces on the target system. The ISA drivers themselves are machine-indep\
 endent being written to communicate with the ISA bus layer. Finally, the targe\
 t ">
<T "machdep.c" italic >
<T " file must specify the built-in ISA devices and beginning the probe of the \
 ISA bus.">
<P "Normal">
<T "This chapter will use the ">
<T "i386" italic >
<T " subdirectory as an example for how to write a ISA bus layer. This target r\
 uns on Intel x86 hardware using a FreeBSD boot-loader that turns on 32-bit add\
 ressing/protected mode.">
<P "Normal">
<T "PCI-ISA bridges are detected as PCI devices and are automatically probed as\
  devices. If one is found, the ISA bus methods are installed and accessed thro\
 ugh the appropriate PCI calls as described in the ">
<S_F fieldType:16 editable
<start_eval_value>
<T "PCI chapter">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"PCI-bus-interface\" -pass \"\" -text \"PCI \
 chapter\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "PCI chapter" underline color:"HtmlLinkDefault@" >
<E_F>
<T ". These PCI methods will override the pre-defined ISA interface and probe f\
 or ISA devices.">
<P "Normal">
<T "The biggest assumption in this code is that there is only a single ISA bus \
 in the entire system even though there may be multiple PCI host bridges.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Machine-dependent-bus-interface\"">
<FV>
<E_F>
<T "Machine-dependent bus interface">
<P "html_h2">
<T "The ISA bus interface is managed through a set of global function pointers \
 defined in ">
<T "isa/isa.c" italic >
<T " and declared in ">
<T "isa/isa.h" italic >
<T ". These function pointers must be initialized to the appropriate routines t\
 o access the ISA bus. A PCI-ISA bridge will override these function pointers. \
 They may be explicitly intiialized for a system with only an ISA bus as in the\
  file ">
<T "i386/isabase.c" italic >
<T ".">
<P "Normal">
<T "The various routines in the ">
<T "isabase.c" italic >
<T " file must behave pretty much like the routines of similar names in ">
<T "pcibase.c" italic >
<T ", although being much simpler.">
<P "Normal">
<T "isa_mem_read isa_mem_write">
<P "html_h3">
<T "Read and write 1, 2, and 4 byte quantities from/to ISA memory space.">
<P "html_blockquote">
<T "isa_io_read isa_io_write">
<P "html_h3">
<T "Read and write 1, 2, and 4 byte quantities from/to ISA I/O space.">
<P "html_blockquote">
<T "isa_map_in isa_map_out">
<P "html_h3">
<T "Map an ISA address into and out of system memory space.">
<P "html_blockquote">
<T "isa_dma_alloc isa_dma_free">
<P "html_h3">
<T "Allocate and free memory suiltably aligned for DMA from system memory.">
<P "html_blockquote">
<T "isa_dma_map_in isa_dma_map_out">
<P "html_h3">
<T "Map a system DMA address into and out of ISA space.">
<P "html_blockquote">
<T "isa_dma_sync">
<P "html_h3">
<T "Flush caches so that a DMA may be safely performed.">
<P "html_blockquote">
<T "^ka">
<P "Normal">
<T "The function ">
<T "install_isabase" italic >
<T " must explicitly set the global ISA function pointers to the routines defin\
 ed to perform these actions. ">
<T "install_isabase" italic >
<T " is called from ">
<T "machdep.c" italic >
<T "'s ">
<T "machine_probe_all" italic >
<T ".">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Driver-interface\"">
<FV>
<E_F>
<T "Driver interface">
<P "html_h2">
<T "Declaring a built-in ISA C driver is more difficult than a PCI driver since\
  every thing about the driver must be explicitly specified. The first step is \
 to fill in an ">
<T "Isa_device" italic >
<T " struct with the appropriate info. This struct is declared in ">
<T "isa/isa.h" italic >
<T ". The ">
<T "isa/kbd.c" italic >
<T " driver looks like this:">
<P "Normal">
<T "Isa_device isa_keyboard =\n{\n^aj\"keyboard\",^aj^aj/* device name */\n^aj\\
 "keyboard\",^aj^aj/* device type */\n^ajISA_IO_ADDRESS,^aj/* I/O or memory add\
 ress? */\n^aj0x60,^aj^aj^aj/* address - physlo */\n^aj5,^aj^aj^aj/* number of \
 bytes at address */\n^aj{ 1, 0 },^aj^aj/* IRQ number and type */\n^aj{ -1, },^\
 aj^aj/* DMA info, if any */\n^aj0x0,^aj^aj^aj/* BIOS ROM address */\n^aj0, NUL\
 L, ^aj^aj/* no extra reg props */\n^ajkbd_probe,\n^ajkbd_install,\n^ajkbd_meth\
 ods\n};">
<P "html_preformatted">
<T "The isa/isa.c probe code calls all probe function pointer for all built-in \
 ISA devices. If the probe function returns successful, then the install functi\
 on pointer is called. The methods entry points to the method table for the dev\
 ice.">
<P "Normal">
<T "Both probe and install routines must be declared using the ">
<T "ISA" italic >
<T " macro defined in ">
<T "isa/isa.h" italic >
<T ".">
<P "Normal">
<T "The probe function should take care when probing for itself as it is fairly\
  easy to lock up the ISA bus. Some probe functions may simply assume that a de\
 vice is present.">
<P "Normal">
<T "The install function should allocate any additional memory it needs, set it\
 s dev->self parameter to this data, then call the ">
<T "new_isa_device" italic >
<T " function to create the device. ">
<T "new_isa_device" italic >
<T " uses the ">
<T "Isa_device" italic >
<T " info to create the new device node under the /isa node with the correct na\
 me, type, and reg properties, and to create any methods for the device. ">
<T "new_isa_device" italic >
<T " is simply for convenience and is not required.">
<P "Normal">
<T "Multiple devices may the probe, install, and methods tables but simply have\
  different IRQs and ISA addresses. Please see ">
<T "isa/ns16550.c" italic >
<T " for an example of a serial driver for the four tradition ISA ports COM1^kn\
 COM4.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"machdep-interface\"">
<FV>
<E_F>
<T "machdep.c interface">
<P "html_h2">
<T "An example for how to link in an ISA bus is in ">
<T "i386/machdep.c" italic >
<T ".">
<P "Normal">
<T "First all built-in ISA drivers must be entered into the global ">
<T "isa_devices" italic >
<T " list:">
<P "Normal">
<T "extern Isa_device ns16550_com1;\nextern Isa_device ns16550_com2;\nextern Is\
 a_device isa_keyboard;\nextern Isa_device vga_display;\n...\n^ka\nIsa_device *\
 isa_devices[] =\n{\n^aj&ns16550_com1,\n^aj&ns16550_com2,\n^aj&isa_keyboard,\n^\
 aj&vga_display,\n^aj...\n^ajNULL\n};">
<P "html_preformatted">
<T "Then the machine_probe_all routine must first install the ISA base routines\
  to initialize the ISA subsystem, then probe for ISA devices. Here is a simpli\
 fied example for a system with only a single ISA bus:">
<P "Normal">
<T "CC(machine_probe_all)^aj^aj/* (--) */\n{\n^ajPackage *isa = new_package(e->\
 root);\n^ajinstall_isabase(e);^aj/* initialize ISA subsystem */\n^ajreturn ins\
 tall_isa(e, isa);^aj/* probe for devices */\n}">
<P "html_preformatted">
<T "The ">
<T "i386/machdep.c" italic >
<T " file has a somewhat more complex machine_probe_all that will first probe f\
 or a PCI bus, and if none is found, only then initialize an ISA bus. If a PCI \
 bus is found, it assumes that a PCI-ISA bridge will also be found thus initial\
 izing the ISA subsystem and probing for ISA devices.">
<P "Normal">
<E_F>
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_38" evenHeader:Inherit firstHeader:Normal "_AX_HF\
 _45" evenFooter:Inherit sectNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:\
 0>
<S_F fieldType:3>
<T "series \"main\"">
<FV>
<T "10. ">
<E_F>
<S_F fieldType:6 date:934404150 docType:200 appType:1 outDated>
*LINK /cgt/src/bin/of/docs/SFChapter10.aw
<T "link \"/cgt/src/bin/of/docs/SFChapter10.aw\" -docType \"200\" -appType \"Wo\
 rds_\"">
<FV>
<E_F>
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_46" evenHeader:Inherit firstHeader:Inherit evenFo\
 oter:Inherit sectNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:0>
<T "Appendix A:\n">
<S_F fieldType:6 date:959281608 docType:200 appType:1 outDated
<start_eval_value>
<S_F fieldType:27 editable>
<T "html_tag -text \"<!-- This file created 7/9/1997 10:42 AM by Claris Home Pa\
 ge version 2.0-->\" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<META NAME=GENERATOR CONTENT=\\\"Claris Home Page 2.0\\\">\
 \" -textStyle \"html_unknown_text\"">
<FV>
<E_F>
<S_F fieldType:27 editable>
<T "html_tag -text \"<X-SAS-WINDOW TOP=44 BOTTOM=764 LEFT=312 RIGHT=842>\" -tex\
 tStyle \"html_unknown_text\"">
<FV>
<E_F>
<T "SmartFirmware User Manual">
<P "html_h1" level:0 >
<T "This document describes the SmartFirmware User Interface, and how to use it\
  to manipulate device trees, view and set parameter values, and to control boo\
 t-up procedures.">
<P "Normal" level:0 >
<T "Basics">
<P "html_h2">
<T "SmartFirmware is an implementation of the ">
<S_F fieldType:16 editable
<start_eval_value>
<T "OpenFirmware">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"http://playground.sun.com/pub/1\
 275/home.html\" -text \"OpenFirmware\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "OpenFirmware" underline color:"HtmlLinkDefault@" >
<E_F>
<T " IEEE standard 1275-1994 plus errata changes.">
<P "Normal" level:0 >
<T "The basis of SmartFirmware is a ">
<S_F fieldType:16 editable
<start_eval_value>
<T "Forth">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"http://www.taygeta.com/forth.ht\
 ml\" -text \"Forth\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "Forth" underline color:"HtmlLinkDefault@" >
<E_F>
<T " engine. Forth is essentially a stack-based language, much like the well-kn\
 own Hewlett-Packard calculators. Forth \"words\" are names that are executed w\
 hen they are typed in at the \"ok\" prompt.">
<P "Normal" level:0 >
<T "For instance, to add two numbers, type \"3 4 +. cr\" at the prompt. This se\
 quence first pushes the number '3' then the number '4' onto the stack. The '+'\
  then pops and adds the top two stack elements and pushes the result on the st\
 ack. The \".\" pops and displays the sum on the top of the stack, namely the v\
 alue '7'. The \"cr\" simply displays a carriage-return and doesn't affect the \
 stack.">
<P "Normal" level:0 >
<T "This document expands upon the built-in \"help\" Forth word.">
<P "Normal" level:0 >
<T "Devices">
<P "html_h2">
<T "A device is a node in a tree, much as a file in a Unix file-path. A device \
 name is usually of the form \"/name@addr1,addr2:options/dev2/...\". All the po\
 rtions of a device path are machine-dependent. An example of a path is \"/duar\
 t@C0800A00/uart@1:19200,9600,8,1,N\". The \"@addr\" and \":options\" portions \
 of the name may be left out, in which case the first matching name is used (\"\
 /duart/uart\" for the previous example).">
<P "Normal" level:0 >
<T "Devices may also have aliases for convenience. For instance, the alias \"tt\
 y\" may refer to \"/duart@C0800A00/uart@0\", and may then be referred to with \
 \"tty:19200,9600,8,1,N\" with options if desired.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Displaying\"">
<FV>
<E_F>
<T "Displaying">
<P "html_h4" level:0 >
<T "Devices can be listed using the \"ls\" command from the SmartFirmware User \
 Interface. The \"dev\" or \"cd\" commands (which are synonyms) moves around th\
 e device tree. The \"pwd\" command shows the current device being accessed.">
<P "Normal" level:0 >
<T "The command \"show-devs\" lists all devices in the device tree. The command\
  \".properties\" can be used to display all property lists at any node in the \
 device tree, after using \"dev\" to first open that device.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"pwd\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "pwd" bold >
<E_F>
<P "Normal" level:0 >
<T "Print current (working) device path.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"ls\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "ls" bold >
<E_F>
<P "Normal" level:0 >
<T "Show all devices at the current point in the device tree.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"dev\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "dev <device path>" bold >
<E_F>
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"cd\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "cd <device path>" bold >
<E_F>
<P "Normal" level:0 >
<T "Change the currently open device to the one specified on the command-line. \
 The path may be relative to the current device. The path may also be the strin\
 g \"..\" to open the parent of the current device. The device will also parse \
 any optional arguments to configure the device, if any are provided.">
<P "html_blockquote" level:0 >
<T "Example: cd /duart@C0800A00:9600">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"show-devs\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "show-devs" bold >
<E_F>
<P "Normal" level:0 >
<T "Show all the devices in the device tree.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \".properties\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T ".properties" bold >
<E_F>
<P "Normal" level:0 >
<T "Show all the properties of the current device.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"words\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "words" bold >
<E_F>
<P "Normal" level:0 >
<T "Show all the methods of the current device, or all the Forth words if there\
  is no current device.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"devalias\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "devalias [name string]" bold >
<E_F>
<P "Normal" level:0 >
<T "Show all the device aliases currently defined if nothing is on the command \
 line. Otherwise, create a device alias called \"name\" with the value of \"str\
 ing\". This is handy to avoid typing in long path names again and again. Usefu\
 l in \"nvramrc\" scripts (below).">
<P "html_blockquote" level:0 >
<T "Example: devalias tty /duart@C0800A00/uart@0">
<P "html_blockquote" level:0 >
<T "Parameter settings">
<P "html_h2">
<T "Parameter settings are stored in non-volatile memory (NVRAM). They affect a\
  variety of SmartFirmware activities from bootup to running custom scripts to \
 setting the size of the display window.">
<P "Normal" level:0 >
<T "Parameters are simply string value pairs that usually have a default value \
 (stored in ROM) and an active value (stored in NVRAM). They may be displayed, \
 set, and restored using the following commands.">
<P "Normal" level:0 >
<T "The supported parameter variables are described in the ">
<S_F fieldType:16 editable
<start_eval_value>
<T "next section">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"Parameter variables\" -pass \" \" -text \"n\
 ext section\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "next section" underline color:"HtmlLinkDefault@" >
<E_F>
<T ".">
<P "Normal" level:0 >
<T "The following commands are used to manipulate NVRAM parameter settings:">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"printenv\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "printenv [var]" bold >
<E_F>
<P "Normal" level:0 >
<T "Display all parameter variables, their current values, and their default va\
 lues if no \"var\" is specified on the command-line. Otherwise just display th\
 e values for that variable.">
<P "html_blockquote" level:0 >
<T "Example: printenv diag-switch?">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"setenv\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "setenv var string value" bold >
<E_F>
<P "Normal" level:0 >
<T "Set the value of \"var\" to be \"string value\". Everything up to the end o\
 f the line, including spaces, will be stored in NVRAM.">
<P "html_blockquote" level:0 >
<T "Example: setenv diag-switch? true">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"set-default\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "set-default var" bold >
<E_F>
<P "Normal" level:0 >
<T "Set the value of \"var\" to be its default value. This is handy to restore \
 some variable whose value may have gotten scrambled for some reason.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"set-defaults\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "set-defaults" bold >
<E_F>
<P "Normal" level:0 >
<T "Set all parameter values back to their default values. This is handy if NVR\
 AM has become corrupted.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"nvedit\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvedit" bold >
<E_F>
<P "Normal" level:0 >
<T "Edit the script stored in parameter \"nvramrc\". This opens up a very simpl\
 e Emacs-style text editor with the contents of the \"nvramrc\" variable.">
<P "html_blockquote" level:0 >
<T "Type ^^C (Control-C) to exit. Most of the usual Emacs commands may be used \
 to move the cursor around, including ^^F (forward-char), ^^B (backward-char), \
 ^^N (next-line), and ^^P (previous-line).">
<P "html_blockquote" level:0 >
<T "This command does not alter the contents of \"nvramrc\" but merely edits a \
 copy in memory. See \"nvstore\", \"nvquit\", \"nvrecover\", and \"nvrun\" (bel\
 ow).">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"nvstore\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvstore" bold >
<E_F>
<P "Normal" level:0 >
<T "Stores the contents of the current \"nvedit\" buffer into the parameter var\
 iable \"nvramrc\". See \"nvedit\" (above).">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"nvquit\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvquit" bold >
<E_F>
<P "Normal" level:0 >
<T "Erase the contents of the nvedit buffer without storing it. Prompts the use\
 r to confirm before erasing the buffer. Does not alter the contents of \"nvram\
 rc\". See \"nvedit\" (above).">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"nvrecover\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvrecover" bold >
<E_F>
<P "Normal" level:0 >
<T "Attempts to recover the contents of nvedit after it has been erased. Normal\
 ly \"nvstore\" is supposed to erase the contents of the edit buffer. SmartFirm\
 ware does not do this, so nvrecover is effectively non-functional. See \"nvedi\
 t\" and \"nvstore\" (above).">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"nvrun\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvrun" bold >
<E_F>
<P "Normal" level:0 >
<T "Execute the contents of the nvedit buffer as Forth code. Handy way to make \
 sure that the \"nvramrc\" script works before committing it to NVRAM. See \"nv\
 edit\" (above).">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"nvalias\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvalias alias device" bold >
<E_F>
<P "Normal" level:0 >
<T "Add a \"devalias\" to the \"nvramrc\" script to create this alias at bootup\
 . If there is already a \"devalias\" command there, edit it to point to this n\
 ew device. Finally, run the new \"devalias\" command so the alias is available\
  for immediate use. This is a short-cut operation for most typical uses of \"n\
 vramrc\".">
<P "html_blockquote" level:0 >
<T "Example: nvalias tty /duart@C0800A00/uart@0">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"nvunalias\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvunalias alias" bold >
<E_F>
<P "Normal" level:0 >
<T "Remove the specified \"devalias\" command for creating this alias at bootup\
  from the \"nvramrc\" script, if there is one there.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Parameter-variables\"">
<FV>
<E_F>
<T "Parameter variables">
<P "html_h2">
<T "Parameter variables are manipulated by the commands described in the previo\
 us section. Most are used during bootup and are guarded by boolean parameters \
 to turn features on or off. All these variables may not be present on all syst\
 ems. For instance, if the system does not support booting, none of the boot pa\
 rameter vars would be of much use.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"diag-switch\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "diag-switch?" bold >
<E_F>
<P "Normal" level:0 >
<T "Boolean: \"true\" or \"false\". Switch on diagnostic-mode if true, which tu\
 rns on extended tests, more verbose output, and alters the boot commands below\
 .">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"secondary-diag\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "secondary-diag?" bold >
<E_F>
<P "Normal" level:0 >
<T "Boolean: \"true\" or \"false\". Switch secondary-diagnostics on or off at b\
 ootup. This is not a standard OpenFirmware parameter and controls additional c\
 omprehensive test routines for SmartFirmware.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"auto-boot\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "auto-boot?" bold >
<E_F>
<P "Normal" level:0 >
<T "Boolean: \"true\" or \"false\". If true, execute the word in \"boot-command\
 \" after the standard bootup process. Otherwise run the Forth interpreter on t\
 he console and display an \"ok\" prompt.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"auto-boot-timeout\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "auto-boot-timeout" bold >
<E_F>
<P "Normal" level:0 >
<T "Integer: number of milliseconds, usually 500. This is the amount of time to\
  wait (in milliseconds) for a key-press to abort auto-boot. This is not a stan\
 dard OpenFirmware parameter.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"boot-command\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "boot-command" bold >
<E_F>
<P "Normal" level:0 >
<T "String: usually \"boot\". The command to execute to boot the system if the \
 variable \"auto-boot?\" is true.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"boot-device\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "boot-device" bold >
<E_F>
<P "Normal" level:0 >
<T "String: usually \"disk\". The device to use to load the boot image when \"b\
 oot\" is executed. The string is usually an alias to the actual device.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"boot-file\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "boot-file" bold >
<E_F>
<P "Normal" level:0 >
<T "String: usually blank. The file to load from the \"boot-device\" when \"boo\
 t\" is executed.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"diag-device\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "diag-device" bold >
<E_F>
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"diag-file\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "diag-file" bold >
<E_F>
<P "Normal" level:0 >
<T "Like \"boot-device\" and \"boot-file\", but are used if \"diag-switch\" is \
 true when \"boot\" is executed. Typical values are \"net\" and \"diag\" respec\
 tively, where \"net\" is typically an alias to a network device.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"use-nvramrc\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "use-nvramrc?" bold >
<E_F>
<P "Normal" level:0 >
<T "Boolean: \"true\" or \"false\". If true, execute the contents of \"nvramrc\\
 " at bootup.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"nvramrc\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvramrc" bold >
<E_F>
<P "Normal" level:0 >
<T "The script to execute at bootup. This script is only executed if \"use-nvra\
 mrc?\" is set to true (below).">
<P "html_blockquote" level:0 >
<T "The normal bootup sequence is: \"probe-all install-console banner\". If an \
 \"nvramrc\" script is provided, it should perform the above three in the same \
 order to make sure that the device tree is probed and ready. If these commands\
  are not executed in the \"nvramrc\" script, then they will be executed by Sma\
 rtFirmware once the script finishes running.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"input-device\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "input-device" bold >
<E_F>
<P "Normal" level:0 >
<T "String: usually \"keyboard\". The device path to use for the console input.\
  The device \"keyboard\" is usually an alias to the actual input device determ\
 ined in some machine-dependent fashion.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"output-device\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "output-device" bold >
<E_F>
<P "Normal" level:0 >
<T "String: usually \"screen\". The device to use for console output. Again, th\
 is is usually an alias to the actual device.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"screen-#rows\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "screen-#rows" bold >
<E_F>
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"screen-#columns\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "screen-#columns" bold >
<E_F>
<P "Normal" level:0 >
<T "Integer: usually 0. The number of rows and columns desired for the console \
 output. If zero, the largest allowable number will be used depending upon the \
 font used.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"inverse-video\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "inverse-video" bold >
<E_F>
<P "Normal" level:0 >
<T "Boolean: \"true\" or \"false\". Display text on the console as black-on-whi\
 te if this parameter is true, else as white-on-black. This is not a standard O\
 penFirmware parameter.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"oem-banner\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "oem-banner?" bold >
<E_F>
<P "Normal" level:0 >
<T "Boolean: \"true\" or \"false\". If true, display the contents of \"oem-bann\
 er\" when the command \"banner\" is executed in place of the default banner st\
 ring.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"oem-banner\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "oem-banner" bold >
<E_F>
<P "Normal" level:0 >
<T "String to display when the \"banner\" command is executed, if \"oem-banner?\
 \" is set to true.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"oem-logo\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "oem-logo?" bold >
<E_F>
<P "Normal" level:0 >
<T "Boolean: \"true\" or \"false\". If true, display the bitmap in \"oem-logo\"\
  in front of the banner when the command \"banner\" is executed. Otherwise a d\
 efault logo (or no logo) will be displayed.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"oem-logo\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "oem-logo" bold >
<E_F>
<P "Normal" level:0 >
<T "Bitmap: 64x64x1 (512 bytes). The bitmap to display if \"oem-logo?\" is true\
 . The contents may be machine-dependent.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Booting\"">
<FV>
<E_F>
<T "Booting">
<P "html_h2">
<T "The bootup process is as follows, as required by the OpenFirmware standard.\
  The process is largely machine-dependent but the steps are the same for all p\
 latforms:">
<P "Normal" level:0 >
<S_F fieldType:9>
<T "glossary \"html_numliststart\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\" -set 1">
<FV>
<T "1.">
<E_F>
<T "^aj">
<E_F>
<T "Power-on self-test">
<P "html_num_list_start" level:0 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "2.">
<E_F>
<T "^aj">
<E_F>
<T "System initialization">
<P "html_num_list" level:0 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "3.">
<E_F>
<T "^aj">
<E_F>
<T "Evaluate the script \"nvramrc\" if \"use-nvramrc?\" is true.">
<P "html_num_list" level:0 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "4.">
<E_F>
<T "^aj">
<E_F>
<T "If the script was not executed or if there was no console after the script \
 finished executing, then:">
<P "html_num_list" level:0 >
<S_F fieldType:9>
<T "glossary \"html_numliststart\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\" -set 1">
<FV>
<T "1.">
<E_F>
<T "^aj">
<E_F>
<T "Execute \"probe-all\" (evaluates FCode)">
<P "html_num_list_start" level:1 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "2.">
<E_F>
<T "^aj">
<E_F>
<T "Execute \"install-console\"">
<P "html_num_list" level:1 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "3.">
<E_F>
<T "^aj">
<E_F>
<T "Execute \"banner\"">
<P "html_num_list" level:1 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "5.">
<E_F>
<T "^aj">
<E_F>
<T "Secondary diagnostics, if \"secondary-diag?\" is true, and other system-dep\
 endent initialization.">
<P "html_num_list" level:0 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "6.">
<E_F>
<T "^aj">
<E_F>
<T "Default boot if \"auto-boot?\" is true and no key is held down.">
<P "html_num_list" level:0 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "7.">
<E_F>
<T "^aj">
<E_F>
<T "Run the Forth command interpreter (if not booted)">
<P "html_num_list" level:0 >
<P "html_blockquote" level:1 >
<T "Commands for booting include:">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"boot\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "boot [device] [args]" bold >
<E_F>
<P "Normal" level:0 >
<T "Boot the specified device with arguments, if any. If args is not specified,\
  use the contents of the parameter \"boot-file\" or \"diag-file\" depending on\
  the current setting of \"diag-switch?\". If device is not specified, use \"bo\
 ot-device\" or \"diag-device\" instead. \"boot\" is the same as a \"load\" fol\
 lowed by a \"go\" (below).">
<P "html_blockquote" level:0 >
<T "Example: boot /flash pterm">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"load\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "load [device] [args]" bold >
<E_F>
<P "Normal" level:0 >
<T "As boot above, except do not actually boot, but do everything else to prepa\
 re an image for booting. Run the \"go\" command to actually boot.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"go\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "go" bold >
<E_F>
<P "Normal" level:0 >
<T "Boot the image that was prepared with \"load\" above.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"probe-all\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "probe-all" bold >
<E_F>
<P "Normal" level:0 >
<T "Probes the system for all devices and builds the device tree. Used in the \\
 "nvramrc\" script. Should only be called once at bootup.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"install-console\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "install-console" bold >
<E_F>
<P "Normal" level:0 >
<T "Selects and installs a console from the device tree, typically a screen and\
  keyboard or a serial-port. Used in the \"nvramrc\" script. Should only be cal\
 led once at bootup.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"banner\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "banner" bold >
<E_F>
<P "Normal" level:0 >
<T "Display the bootup system banner, optionally with a custom color logo. This\
  is usually called in the \"nvramrc\" script at bootup, but is safe to execute\
  multiple times.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Testing\"">
<FV>
<E_F>
<T "Testing">
<P "html_h2">
<T "It is possible to exercise some of the test methods from the Forth command \
 prompt. If the parameter variable \"diag-switch?\" is true, then more verbose \
 and more thorough tests are turned on. It may be useful to run the non-verbose\
  commands at bootup, if desired. The commands are as follows.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"test\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "test [device]" bold >
<E_F>
<P "Normal" level:0 >
<T "Test the specified device (or the currently open device if none is specifie\
 d) by executing its \"selftest\" method. This may also turn on LEDs or other i\
 ndicators that testing is in progress.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"test-all\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "test-all [device]" bold >
<E_F>
<P "Normal" level:0 >
<T "Run all \"selftest\" methods recursively at and below the specified device \
 (or \"/\" if no device is specified). This runs all tests on the requested nod\
 e, then on all its children, and their children, and so on.Typically used to r\
 un all the tests on all devices from \"/\".">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Changing-the-console\"">
<FV>
<E_F>
<T "Changing the console">
<P "html_h2">
<T "The console device used may be changed at any time, or selected during boot\
 up. To change it during bootup, the typical method is to either change the NVR\
 AM parameters \"input-device\" and \"output-device\" to the desired console de\
 vice, or add \"devalias\" commands to \"nvramrc\" to change the aliases for \"\
 screen\" and \"keyboard\" to the desired console.">
<P "Normal" level:0 >
<T "Otherwise, the console may be changed on-the-fly using the following Forth \
 words. Note that they expect their parameters on the Forth stack and not on th\
 e command-line as do most of the commands above.">
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"input\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "input (device-str str-len --)" bold >
<E_F>
<P "Normal" level:0 >
<T "Used by first pushing a string containing the desired device onto the Forth\
  stack, then executing the word \"input\". The console input will be immediate\
 ly changed unless an error occurs. Example: \" /duart/uart@0\" input">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"output\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "output (device-str str-len --)" bold >
<E_F>
<P "Normal" level:0 >
<T "Changes the current console output device.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"io\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "io (device-str str-len --)" bold >
<E_F>
<P "Normal" level:0 >
<T "Changes both the input and the output device at one time. Only useful if th\
 e device is capable of both input and output.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"Forth-variables\"">
<FV>
<E_F>
<T "Forth variables">
<P "html_h2">
<T "Forth variables may be viewed and set using standard Forth words. Some addi\
 tional variables have been added for SmartFirmware that are not part of the Op\
 enFirmware standard.">
<P "Normal" level:0 >
<T "To view a Forth variable called, say, \"lines/page\", use \".\" to display \
 the value on the top of the stack and \"cr\" to print a carriage-return:">
<P "Normal" level:0 >
<T "ok lines/page . cr">
<P "html_preformatted" level:0 >
<T "To set a Forth variable, the new value must be first pushed onto the Forth \
 stack before using the \"to\" word:">
<P "Normal" level:0 >
<T "ok -1 to lines/page">
<P "html_preformatted" level:0 >
<P "Normal" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"lines-page\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "lines/page" bold >
<E_F>
<P "Normal" level:0 >
<T "The current number of lines per page specified for automatic pagination of \
 the output. If the value is zero, no pagination is performed. If the value is \
 negative, it is subtracted from the number of lines in the display. Otherwise \
 the value specifies how many lines are to be displayed before a \"More\" promp\
 t temporarily stops the output.">
<P "html_blockquote" level:0 >
<S_F fieldType:17 editable>
<T "hyper_target \"scroll-step\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "scroll-step" bold >
<E_F>
<P "Normal" level:0 >
<T "The number of lines to scrol l the display by when at the bottom of the scr\
 een. This can speed up slower frame buffers by scrolling by 4 lines instead of\
  1, for instance.">
<P "html_blockquote" level:0 >
<P "Normal" level:0 >
<P "html_hr" justifyCenter level:0 >
<end_eval_value>
>
*LINK /cgt/src/bin/of/docs/SFUserManual.aw
<T "link \"/cgt/src/bin/of/docs/SFUserManual.aw\" -docType \"200\" -appType \"W\
 ords_\"">
<FV>
<S_F fieldType:17>
<T "hyper_target \"SmartFirmware-User-Manual\"">
<FV>
<E_F>
<T "SmartFirmware User Manual">
<P "html_h1">
<T "This document describes the SmartFirmware User Interface, and how to use it\
  to manipulate device trees, view and set parameter values, and to control boo\
 t-up procedures.">
<P "Normal">
<T "Basics">
<P "html_h2">
<T "SmartFirmware is an implementation of the ">
<S_F fieldType:16 editable
<start_eval_value>
<T "OpenFirmware">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"http://playground.sun.com/pub/1\
 275/home.html\" -text \"OpenFirmware\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "OpenFirmware" underline color:"HtmlLinkDefault@" >
<E_F>
<T " IEEE standard 1275-1994 plus errata changes.">
<P "Normal">
<T "The basis of SmartFirmware is a ">
<S_F fieldType:16 editable
<start_eval_value>
<T "Forth">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \" \" -pass \"http://www.taygeta.com/forth.ht\
 ml\" -text \"Forth\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "Forth" underline color:"HtmlLinkDefault@" >
<E_F>
<T " engine. Forth is essentially a stack-based language, much like the well-kn\
 own Hewlett-Packard calculators. Forth \"words\" are names that are executed w\
 hen they are typed in at the \"ok\" prompt.">
<P "Normal">
<T "For instance, to add two numbers, type \"3 4 +. cr\" at the prompt. This se\
 quence first pushes the number '3' then the number '4' onto the stack. The '+'\
  then pops and adds the top two stack elements and pushes the result on the st\
 ack. The \".\" pops and displays the sum on the top of the stack, namely the v\
 alue '7'. The \"cr\" simply displays a carriage-return and doesn't affect the \
 stack.">
<P "Normal">
<T "This document expands upon the built-in \"help\" Forth word.">
<P "Normal">
<T "Devices">
<P "html_h2">
<T "A device is a node in a tree, much as a file in a Unix file-path. A device \
 name is usually of the form \"/name@addr1,addr2:options/dev2/...\". All the po\
 rtions of a device path are machine-dependent. An example of a path is \"/duar\
 t@C0800A00/uart@1:19200,9600,8,1,N\". The \"@addr\" and \":options\" portions \
 of the name may be left out, in which case the first matching name is used (\"\
 /duart/uart\" for the previous example).">
<P "Normal">
<T "Devices may also have aliases for convenience. For instance, the alias \"tt\
 y\" may refer to \"/duart@C0800A00/uart@0\", and may then be referred to with \
 \"tty:19200,9600,8,1,N\" with options if desired.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Displaying\"">
<FV>
<E_F>
<T "Displaying">
<P "html_h4">
<T "Devices can be listed using the \"ls\" command from the SmartFirmware User \
 Interface. The \"dev\" or \"cd\" commands (which are synonyms) moves around th\
 e device tree. The \"pwd\" command shows the current device being accessed.">
<P "Normal">
<T "The command \"show-devs\" lists all devices in the device tree. The command\
  \".properties\" can be used to display all property lists at any node in the \
 device tree, after using \"dev\" to first open that device.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"pwd\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "pwd" bold >
<E_F>
<P "Normal">
<T "Print current (working) device path.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"ls\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "ls" bold >
<E_F>
<P "Normal">
<T "Show all devices at the current point in the device tree.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"dev\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "dev <device path>" bold >
<E_F>
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"cd\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "cd <device path>" bold >
<E_F>
<P "Normal">
<T "Change the currently open device to the one specified on the command-line. \
 The path may be relative to the current device. The path may also be the strin\
 g \"..\" to open the parent of the current device. The device will also parse \
 any optional arguments to configure the device, if any are provided.">
<P "html_blockquote">
<T "Example: cd /duart@C0800A00:9600">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"show-devs\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "show-devs" bold >
<E_F>
<P "Normal">
<T "Show all the devices in the device tree.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \".properties\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T ".properties" bold >
<E_F>
<P "Normal">
<T "Show all the properties of the current device.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"words\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "words" bold >
<E_F>
<P "Normal">
<T "Show all the methods of the current device, or all the Forth words if there\
  is no current device.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"devalias\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "devalias [name string]" bold >
<E_F>
<P "Normal">
<T "Show all the device aliases currently defined if nothing is on the command \
 line. Otherwise, create a device alias called \"name\" with the value of \"str\
 ing\". This is handy to avoid typing in long path names again and again. Usefu\
 l in \"nvramrc\" scripts (below).">
<P "html_blockquote">
<T "Example: devalias tty /duart@C0800A00/uart@0">
<P "html_blockquote">
<T "Parameter settings">
<P "html_h2">
<T "Parameter settings are stored in non-volatile memory (NVRAM). They affect a\
  variety of SmartFirmware activities from bootup to running custom scripts to \
 setting the size of the display window.">
<P "Normal">
<T "Parameters are simply string value pairs that usually have a default value \
 (stored in ROM) and an active value (stored in NVRAM). They may be displayed, \
 set, and restored using the following commands.">
<P "Normal">
<T "The supported parameter variables are described in the ">
<S_F fieldType:16 editable
<start_eval_value>
<T "next section">
<end_eval_value>
>
<T "macro \"WP_HYPERLINK@\" -pass \"Parameter-variables\" -pass \"\" -text \"ne\
 xt section\" -textStyle \"html_hyperlink_text\"">
<FV>
<T "next section" underline color:"HtmlLinkDefault@" >
<E_F>
<T ".">
<P "Normal">
<T "The following commands are used to manipulate NVRAM parameter settings:">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"printenv\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "printenv [var]" bold >
<E_F>
<P "Normal">
<T "Display all parameter variables, their current values, and their default va\
 lues if no \"var\" is specified on the command-line. Otherwise just display th\
 e values for that variable.">
<P "html_blockquote">
<T "Example: printenv diag-switch?">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"setenv\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "setenv var string value" bold >
<E_F>
<P "Normal">
<T "Set the value of \"var\" to be \"string value\". Everything up to the end o\
 f the line, including spaces, will be stored in NVRAM.">
<P "html_blockquote">
<T "Example: setenv diag-switch? true">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"set-default\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "set-default var" bold >
<E_F>
<P "Normal">
<T "Set the value of \"var\" to be its default value. This is handy to restore \
 some variable whose value may have gotten scrambled for some reason.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"set-defaults\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "set-defaults" bold >
<E_F>
<P "Normal">
<T "Set all parameter values back to their default values. This is handy if NVR\
 AM has become corrupted.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"nvedit\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvedit" bold >
<E_F>
<P "Normal">
<T "Edit the script stored in parameter \"nvramrc\". This opens up a very simpl\
 e Emacs-style text editor with the contents of the \"nvramrc\" variable.">
<P "html_blockquote">
<T "Type ^^C (Control-C) to exit. Most of the usual Emacs commands may be used \
 to move the cursor around, including ^^F (forward-char), ^^B (backward-char), \
 ^^N (next-line), and ^^P (previous-line).">
<P "html_blockquote">
<T "This command does not alter the contents of \"nvramrc\" but merely edits a \
 copy in memory. See \"nvstore\", \"nvquit\", \"nvrecover\", and \"nvrun\" (bel\
 ow).">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"nvstore\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvstore" bold >
<E_F>
<P "Normal">
<T "Stores the contents of the current \"nvedit\" buffer into the parameter var\
 iable \"nvramrc\". See \"nvedit\" (above).">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"nvquit\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvquit" bold >
<E_F>
<P "Normal">
<T "Erase the contents of the nvedit buffer without storing it. Prompts the use\
 r to confirm before erasing the buffer. Does not alter the contents of \"nvram\
 rc\". See \"nvedit\" (above).">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"nvrecover\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvrecover" bold >
<E_F>
<P "Normal">
<T "Attempts to recover the contents of nvedit after it has been erased. Normal\
 ly \"nvstore\" is supposed to erase the contents of the edit buffer. SmartFirm\
 ware does not do this, so nvrecover is effectively non-functional. See \"nvedi\
 t\" and \"nvstore\" (above).">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"nvrun\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvrun" bold >
<E_F>
<P "Normal">
<T "Execute the contents of the nvedit buffer as Forth code. Handy way to make \
 sure that the \"nvramrc\" script works before committing it to NVRAM. See \"nv\
 edit\" (above).">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"nvalias\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvalias alias device" bold >
<E_F>
<P "Normal">
<T "Add a \"devalias\" to the \"nvramrc\" script to create this alias at bootup\
 . If there is already a \"devalias\" command there, edit it to point to this n\
 ew device. Finally, run the new \"devalias\" command so the alias is available\
  for immediate use. This is a short-cut operation for most typical uses of \"n\
 vramrc\".">
<P "html_blockquote">
<T "Example: nvalias tty /duart@C0800A00/uart@0">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"nvunalias\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvunalias alias" bold >
<E_F>
<P "Normal">
<T "Remove the specified \"devalias\" command for creating this alias at bootup\
  from the \"nvramrc\" script, if there is one there.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"Parameter-variables\"">
<FV>
<E_F>
<T "Parameter variables">
<P "html_h2">
<T "Parameter variables are manipulated by the commands described in the previo\
 us section. Most are used during bootup and are guarded by boolean parameters \
 to turn features on or off. All these variables may not be present on all syst\
 ems. For instance, if the system does not support booting, none of the boot pa\
 rameter vars would be of much use.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"diag-switch\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "diag-switch?" bold >
<E_F>
<P "Normal">
<T "Boolean: \"true\" or \"false\". Switch on diagnostic-mode if true, which tu\
 rns on extended tests, more verbose output, and alters the boot commands below\
 .">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"secondary-diag\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "secondary-diag?" bold >
<E_F>
<P "Normal">
<T "Boolean: \"true\" or \"false\". Switch secondary-diagnostics on or off at b\
 ootup. This is not a standard OpenFirmware parameter and controls additional c\
 omprehensive test routines for SmartFirmware.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"auto-boot\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "auto-boot?" bold >
<E_F>
<P "Normal">
<T "Boolean: \"true\" or \"false\". If true, execute the word in \"boot-command\
 \" after the standard bootup process. Otherwise run the Forth interpreter on t\
 he console and display an \"ok\" prompt.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"auto-boot-timeout\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "auto-boot-timeout" bold >
<E_F>
<P "Normal">
<T "Integer: number of milliseconds, usually 500. This is the amount of time to\
  wait (in milliseconds) for a key-press to abort auto-boot. This is not a stan\
 dard OpenFirmware parameter.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"boot-command\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "boot-command" bold >
<E_F>
<P "Normal">
<T "String: usually \"boot\". The command to execute to boot the system if the \
 variable \"auto-boot?\" is true.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"boot-device\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "boot-device" bold >
<E_F>
<P "Normal">
<T "String: usually \"disk\". The device to use to load the boot image when \"b\
 oot\" is executed. The string is usually an alias to the actual device.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"boot-file\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "boot-file" bold >
<E_F>
<P "Normal">
<T "String: usually blank. The file to load from the \"boot-device\" when \"boo\
 t\" is executed.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"diag-device\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "diag-device" bold >
<E_F>
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"diag-file\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "diag-file" bold >
<E_F>
<P "Normal">
<T "Like \"boot-device\" and \"boot-file\", but are used if \"diag-switch\" is \
 true when \"boot\" is executed. Typical values are \"net\" and \"diag\" respec\
 tively, where \"net\" is typically an alias to a network device.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"use-nvramrc\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "use-nvramrc?" bold >
<E_F>
<P "Normal">
<T "Boolean: \"true\" or \"false\". If true, execute the contents of \"nvramrc\\
 " at bootup.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"nvramrc\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "nvramrc" bold >
<E_F>
<P "Normal">
<T "The script to execute at bootup. This script is only executed if \"use-nvra\
 mrc?\" is set to true (below).">
<P "html_blockquote">
<T "The normal bootup sequence is: \"probe-all install-console banner\". If an \
 \"nvramrc\" script is provided, it should perform the above three in the same \
 order to make sure that the device tree is probed and ready. If these commands\
  are not executed in the \"nvramrc\" script, then they will be executed by Sma\
 rtFirmware once the script finishes running.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"input-device\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "input-device" bold >
<E_F>
<P "Normal">
<T "String: usually \"keyboard\". The device path to use for the console input.\
  The device \"keyboard\" is usually an alias to the actual input device determ\
 ined in some machine-dependent fashion.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"output-device\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "output-device" bold >
<E_F>
<P "Normal">
<T "String: usually \"screen\". The device to use for console output. Again, th\
 is is usually an alias to the actual device.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"screen-#rows\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "screen-#rows" bold >
<E_F>
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"screen-#columns\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "screen-#columns" bold >
<E_F>
<P "Normal">
<T "Integer: usually 0. The number of rows and columns desired for the console \
 output. If zero, the largest allowable number will be used depending upon the \
 font used.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"inverse-video\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "inverse-video" bold >
<E_F>
<P "Normal">
<T "Boolean: \"true\" or \"false\". Display text on the console as black-on-whi\
 te if this parameter is true, else as white-on-black. This is not a standard O\
 penFirmware parameter.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"oem-banner\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "oem-banner?" bold >
<E_F>
<P "Normal">
<T "Boolean: \"true\" or \"false\". If true, display the contents of \"oem-bann\
 er\" when the command \"banner\" is executed in place of the default banner st\
 ring.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"oem-banner\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "oem-banner" bold >
<E_F>
<P "Normal">
<T "String to display when the \"banner\" command is executed, if \"oem-banner?\
 \" is set to true.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"oem-logo\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "oem-logo?" bold >
<E_F>
<P "Normal">
<T "Boolean: \"true\" or \"false\". If true, display the bitmap in \"oem-logo\"\
  in front of the banner when the command \"banner\" is executed. Otherwise a d\
 efault logo (or no logo) will be displayed.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"oem-logo\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "oem-logo" bold >
<E_F>
<P "Normal">
<T "Bitmap: 64x64x1 (512 bytes). The bitmap to display if \"oem-logo?\" is true\
 . The contents may be machine-dependent.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"Booting\"">
<FV>
<E_F>
<T "Booting">
<P "html_h2">
<T "The bootup process is as follows, as required by the OpenFirmware standard.\
  The process is largely machine-dependent but the steps are the same for all p\
 latforms:">
<P "Normal">
<S_F fieldType:9>
<T "glossary \"html_numliststart\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\" -set 1">
<FV>
<T "1.">
<E_F>
<T "^aj">
<E_F>
<T "Power-on self-test">
<P "html_num_list_start">
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "2.">
<E_F>
<T "^aj">
<E_F>
<T "System initialization">
<P "html_num_list">
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "3.">
<E_F>
<T "^aj">
<E_F>
<T "Evaluate the script \"nvramrc\" if \"use-nvramrc?\" is true.">
<P "html_num_list">
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "4.">
<E_F>
<T "^aj">
<E_F>
<T "If the script was not executed or if there was no console after the script \
 finished executing, then:">
<P "html_num_list">
<S_F fieldType:9>
<T "glossary \"html_numliststart\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\" -set 1">
<FV>
<T "1.">
<E_F>
<T "^aj">
<E_F>
<T "Execute \"probe-all\" (evaluates FCode)">
<P "html_num_list_start" level:1 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "2.">
<E_F>
<T "^aj">
<E_F>
<T "Execute \"install-console\"">
<P "html_num_list" level:1 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "3.">
<E_F>
<T "^aj">
<E_F>
<T "Execute \"banner\"">
<P "html_num_list" level:1 >
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "5.">
<E_F>
<T "^aj">
<E_F>
<T "Secondary diagnostics, if \"secondary-diag?\" is true, and other system-dep\
 endent initialization.">
<P "html_num_list">
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "6.">
<E_F>
<T "^aj">
<E_F>
<T "Default boot if \"auto-boot?\" is true and no key is held down.">
<P "html_num_list">
<S_F fieldType:9>
<T "glossary \"html_numlist\"">
<FV>
<T "^aj">
<S_F fieldType:3>
<T "series \"NumList\"">
<FV>
<T "7.">
<E_F>
<T "^aj">
<E_F>
<T "Run the Forth command interpreter (if not booted)">
<P "html_num_list">
<P "html_blockquote" level:1 >
<T "Commands for booting include:">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"boot\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "boot [device] [args]" bold >
<E_F>
<P "Normal">
<T "Boot the specified device with arguments, if any. If args is not specified,\
  use the contents of the parameter \"boot-file\" or \"diag-file\" depending on\
  the current setting of \"diag-switch?\". If device is not specified, use \"bo\
 ot-device\" or \"diag-device\" instead. \"boot\" is the same as a \"load\" fol\
 lowed by a \"go\" (below).">
<P "html_blockquote">
<T "Example: boot /flash pterm">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"load\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "load [device] [args]" bold >
<E_F>
<P "Normal">
<T "As boot above, except do not actually boot, but do everything else to prepa\
 re an image for booting. Run the \"go\" command to actually boot.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"go\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "go" bold >
<E_F>
<P "Normal">
<T "Boot the image that was prepared with \"load\" above.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"probe-all\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "probe-all" bold >
<E_F>
<P "Normal">
<T "Probes the system for all devices and builds the device tree. Used in the \\
 "nvramrc\" script. Should only be called once at bootup.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"install-console\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "install-console" bold >
<E_F>
<P "Normal">
<T "Selects and installs a console from the device tree, typically a screen and\
  keyboard or a serial-port. Used in the \"nvramrc\" script. Should only be cal\
 led once at bootup.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"banner\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "banner" bold >
<E_F>
<P "Normal">
<T "Display the bootup system banner, optionally with a custom color logo. This\
  is usually called in the \"nvramrc\" script at bootup, but is safe to execute\
  multiple times.">
<P "html_blockquote">
<P "Normal">
<T "Net-booting">
<P "html_h3">
<T "Booting over a network device is probably the most useful feature of SmartF\
 irmware. SmartFirmware supports the standard UDP/IP protocols of BOOTP, DHCP, \
 or RARP for configuring a network device, and TFTP for loading an images over \
 that network device.">
<P "Normal">
<T "The commands ``load'' and ``boot'' (described above) when used with a netwo\
 rk device accept the following optional device-specific arguments as follows:"\
 >
<P "Normal">
<T "net:[dopt,][prto,]sia,fname,cia,gia,bret,tret [args]" bold >
<P "html_preformatted" firstIndent:262 leftIndent:250  bold >
<T "``net'' may be a device alias or a device-path to an ethernet device.">
<P "html_blockquote">
<T "``dopt'' are device-specific options. SmartFirmware's builtin ethernet driv\
 ers support the strings ``promiscuous'', ``speed=10'', ``speed=100'', ``duplex\
 =full'', and ``duplex=half'', assuming the device supports the specific capabi\
 lity. The options may be in any order and must be separated by commas. Additio\
 nal options may also be supported by a specific driver.">
<P "html_blockquote">
<T " ``prto'' is optional and specifies which network boot protocol to be used.\
  SmartFirmware supports the strings ``bootp'', ``dhcp'' or ``rarp'' to force B\
 OOTP, DHCP, or RARP protocols to be used. BOOTP is the default on most platfor\
 ms (although Sparcs may use RARP).">
<P "html_blockquote">
<T "``sia'' is the server internet address in dotted octet or hexadecimal forma\
 t of the server that will be used for TFTP.">
<P "html_blockquote">
<T "``fname'' is the name of the file to be downloaded over the network using T\
 FTP.">
<P "html_blockquote">
<T "``cia'' is the internet address that SmartFirmware will use for its local (\
 client) interface address.">
<P "html_blockquote">
<T "``giadr' is the internet address of the gateway between the local interface\
  and the server if such a gateway is present.">
<P "html_blockquote">
<T "``bret'' and ``tret'' are decimal numbers and indicate the number of times \
 that retries will be sent before the BOOTP or TFTP operations fail.">
<P "html_blockquote">
<T "``args'' are the optional arguments passed to the program when it is execut\
 ed.">
<P "html_blockquote">
<T "All device arguments are optional, but the commas separating the arguments \
 are required. Any missing fields are filled in by the information returned usi\
 ng BOOTP/DHCP/RARP protocols. Thus the simplest way to boot over a network dev\
 ice is simply ``boot net''. ``boot net:,file'' boots a specific file over the \
 net.">
<P "Normal">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"Testing\"">
<FV>
<E_F>
<T "Testing">
<P "html_h2">
<T "It is possible to exercise some of the test methods from the Forth command \
 prompt. If the parameter variable \"diag-switch?\" is true, then more verbose \
 and more thorough tests are turned on. It may be useful to run the non-verbose\
  commands at bootup, if desired. The commands are as follows.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"test\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "test [device]" bold >
<E_F>
<P "Normal">
<T "Test the specified device (or the currently open device if none is specifie\
 d) by executing its \"selftest\" method. This may also turn on LEDs or other i\
 ndicators that testing is in progress.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"test-all\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "test-all [device]" bold >
<E_F>
<P "Normal">
<T "Run all \"selftest\" methods recursively at and below the specified device \
 (or \"/\" if no device is specified). This runs all tests on the requested nod\
 e, then on all its children, and their children, and so on.Typically used to r\
 un all the tests on all devices from \"/\".">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"Changing-the-console\"">
<FV>
<E_F>
<T "Changing the console">
<P "html_h2">
<T "The console device used may be changed at any time, or selected during boot\
 up. To change it during bootup, the typical method is to either change the NVR\
 AM parameters \"input-device\" and \"output-device\" to the desired console de\
 vice, or add \"devalias\" commands to \"nvramrc\" to change the aliases for \"\
 screen\" and \"keyboard\" to the desired console.">
<P "Normal">
<T "Otherwise, the console may be changed on-the-fly using the following Forth \
 words. Note that they expect their parameters on the Forth stack and not on th\
 e command-line as do most of the commands above.">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"input\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "input (device-str str-len --)" bold >
<E_F>
<P "Normal">
<T "Used by first pushing a string containing the desired device onto the Forth\
  stack, then executing the word \"input\". The console input will be immediate\
 ly changed unless an error occurs. Example: \" /duart/uart@0\" input">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"output\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "output (device-str str-len --)" bold >
<E_F>
<P "Normal">
<T "Changes the current console output device.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"io\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "io (device-str str-len --)" bold >
<E_F>
<P "Normal">
<T "Changes both the input and the output device at one time. Only useful if th\
 e device is capable of both input and output.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"Forth-variables\"">
<FV>
<E_F>
<T "Forth variables">
<P "html_h2">
<T "Forth variables may be viewed and set using standard Forth words. Some addi\
 tional variables have been added for SmartFirmware that are not part of the Op\
 enFirmware standard.">
<P "Normal">
<T "To view a Forth variable called, say, \"lines/page\", use \".\" to display \
 the value on the top of the stack and \"cr\" to print a carriage-return:">
<P "Normal">
<T "ok lines/page . cr">
<P "html_preformatted">
<T "To set a Forth variable, the new value must be first pushed onto the Forth \
 stack before using the \"to\" word:">
<P "Normal">
<T "ok -1 to lines/page">
<P "html_preformatted">
<P "Normal">
<S_F fieldType:17 editable>
<T "hyper_target \"lines-page\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "lines/page" bold >
<E_F>
<P "Normal">
<T "The current number of lines per page specified for automatic pagination of \
 the output. If the value is zero, no pagination is performed. If the value is \
 negative, it is subtracted from the number of lines in the display. Otherwise \
 the value specifies how many lines are to be displayed before a \"More\" promp\
 t temporarily stops the output.">
<P "html_blockquote">
<S_F fieldType:17 editable>
<T "hyper_target \"scroll-step\"">
<FV>
<E_F>
<S_F fieldType:29 editable>
<T "plain -textStyle \"html_strong_text\"">
<FV>
<T "scroll-step" bold >
<E_F>
<P "Normal">
<T "The number of lines to scrol l the display by when at the bottom of the scr\
 een. This can speed up slower frame buffers by scrolling by 4 lines instead of\
  1, for instance.">
<P "html_blockquote">
<E_F>
<P "Normal">
<section  odd_page pageWidth:8500 pageHeight:11000 leftMargin:1000 rightMargin:\
 1000 topMargin:1250 bottomMargin:1250 bindingMargin:0 paperSize:1 gutterWidth:\
 500 oddHeader:Normal "_AX_HF_23" evenHeader:Normal "_AX_HF_26" firstHeader:Nor\
 mal "_AX_HF_25" oddFooter:Normal "_AX_HF_29" evenFooter:Normal "_AX_HF_28" sec\
 tNumFmt:-1 sectPageSep:"-" pageNumFmt:0 pageNumCtl:0>
<end_flow>
<start_hdrftr "_AX_HF_30">
<T "Machine dependancies">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_31">
<T "Creating new words">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_32">
<T "Compiling, Running, Etc.">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_33">
<P "HdrFtr">
<end_hdrftr>
<start_hdrftr "_AX_HF_34">
<T "Basics">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_35">
<T "Plug-in executable images">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_36">
<T "Plug-in filesystem">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_37">
<T "PCI-bus interface">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_38">
<T "ISA-bus interface">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_39">
<P "HdrFtr">
<end_hdrftr>
<start_hdrftr "_AX_HF_40">
<T "SmartFirmware">
<P "HdrFtr">
<end_hdrftr>
<start_hdrftr "_AX_HF_41">
<T "Contents">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_42">
<S_F fieldType:19>
<T "page_number">
<FV>
<T "???">
<E_F>
<P "HdrFtr">
<end_hdrftr>
<start_hdrftr "_AX_HF_43">
<S_F fieldType:19>
<T "page_number">
<FV>
<T "???">
<E_F>
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_23">
<T "Appendix A: SmartFirmware User Manual">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_25">
<P "HdrFtr">
<end_hdrftr>
<start_hdrftr "_AX_HF_26">
<T "SmartFirmware">
<P "HdrFtr">
<end_hdrftr>
<start_hdrftr "_AX_HF_28">
<S_F fieldType:19>
<T "page_number">
<FV>
<T "???">
<E_F>
<P "HdrFtr">
<end_hdrftr>
<start_hdrftr "_AX_HF_29">
<S_F fieldType:19>
<T "page_number">
<FV>
<T "???">
<E_F>
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_hdrftr "_AX_HF_45">
<P "HdrFtr">
<end_hdrftr>
<start_hdrftr "_AX_HF_46">
<T "Client interface">
<P "HdrFtr" justifyRight >
<end_hdrftr>
<start_vars>
<V "Language@" 1>
<V "Style$" "empty.aw">
<V "PathName$" "/u/cgt/src/bin/of/docs/SFManual.aw">
<V "DocName$" "SFManual.aw">
<V "ReadOnly@" 0>
<V "Creator$" "Applix Words">
<V "Created$" "Release 4.30 (build 807.141.90) #17">
<V "AxCreationCodeVersion$" "Mon Sep 22 06:52:06 1997">
<V "CreationDate$" "Tue Oct 13 14:53:44 1998">
<V "CreationUser$" "parag">
<V "Updated$" "Release 4.30 (build 807.141.90) #17">
<V "AxUpdateCodeVersion$" "Mon Sep 22 06:52:06 1997">
<V "UpdateDate$" "Thu May 25 19:11:19 2000">
<V "UpdateUser$" "parag">
<V "DocWindowAttrType@" 1>
<V "DocWindowSize$" < 8494 9707>>
<V "DocIsForm@" 0>
<end_vars>
<end_document>
*END WORDS
