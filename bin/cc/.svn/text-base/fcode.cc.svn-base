/*  Copyright (c) 1992-2005 CodeGen, Inc.  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. Redistributions in any form must be accompanied by information on
 *     how to obtain complete source code for the CodeGen software and any
 *     accompanying software that uses the CodeGen software.  The source code
 *     must either be included in the distribution or be available for no
 *     more than the cost of distribution plus a nominal fee, and must be
 *     freely redistributable under reasonable conditions.  For an
 *     executable file, complete source code means the source code for all
 *     modules it contains.  It does not include source code for modules or
 *     files that typically accompany the major components of the operating
 *     system on which the executable file runs.  It does not include
 *     source code generated as output by a CodeGen compiler.
 *
 *  THIS SOFTWARE IS PROVIDED BY CODEGEN AS IS AND ANY EXPRESS OR IMPLIED
 *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  (Commercial source/binary licensing and support is also available.
 *   Please contact CodeGen for details. http://www.codegen.com/)
 */

// Copyright (c) 1992,1996-2001 by Parag Patel.  All Rights Reserved.
// $Header: /u/cgt/cvs/bin/cc/fcode.cc,v 1.73 2003/05/01 06:28:56 parag Exp $

// This file generates Fcode/Forth for an OpenFirmware environment.

#include <stddef.h>
#include <memory.h>
#include <ctype.h>
#include <pool.h>
#include <stdiox.h>
#include <stringx.h>
#include "cctype.h"
#include "ccsym.h"
#include "ccnode.h"
#include "globals.h"

#define ITOSTR(i)	integertostr(i, -16)


class StorageAllocator
{
	Integer _offset;
public:

	StorageAllocator() : _offset(g_size_t_type->ic()) { }
	Integer &offset() { return _offset; }
	void allocparam(Integer &size, int align, Integer *val);
};

class Noop_node : public Node
{
public:
	Noop_node() : Node() { }
};

static Noop_node *g_noop_node = new Noop_node;
static Symbol *g_main_sym = NULL;

// for "return" statements to clear up stack frame
static StorageAllocator *g_stkalloc;
static Symbol *g_func_sym;			// to generate Forth fields

#define g_tree_node (TreeNode*)0x01
#define g_lvaltree_node (LValueTreeNode*)0x03

static boolean g_is_func_call = FALSE;	// hack to quote non-func calls

// used to generate unique scope numbers for nested scopes in functions
static int g_scope_id = 0;

// count nested numbers of switches to generate errors for breaks
static int g_in_switch = 0;

// externs defined in ccfcode.cc:
extern Symbol_arr *g_dev_list;
extern boolean g_expand_inline;
extern boolean g_recursive;
extern boolean g_debug_syms;
extern char *g_sym_alias;


void
p(const char *fmt, ...)
{
#ifdef LIMITED
	static int count = LIMITED;

	if (strchr(fmt, '\n') && count-- == 0)
	{
		eprintf("Only %d lines of Fcode are generated by this compiler.\n",
				LIMITED);
		eprintf("Please purchase the full version without this limitation.\n");
		exit(-100);
	}
#endif

    va_list ap;
    va_start(ap, fmt);
    vfprintf(stdout, fmt, ap);
    va_end(ap);
}

const char *
us2minus(const char *str)
{
	static Charbuf buf[4];
	static int bufidx = 0;
	int len = strlen(str);
	char *ns;

	if (++bufidx >= 4)
		bufidx = 0;

	if (len >= buf[bufidx].size())
		buf[bufidx].resize(len + 1);

	ns = buf[bufidx].getarr();

	for (const char *s = str; *s; s++)
		*ns++ = (*s == '_') ?  '-' : *s;
	
	*ns = '\0';
	return strget(buf[bufidx].getarr());
}

const char *
mksymbolname(Symbol &s)
{
	const char *name = s.name();

	if (s.alias())
		name = s.alias();
	else if (s.storage() != ENUM)
		name = us2minus(name);

	if ((!g_recursive || s.storage() == STATIC) &&
			s.scope() != g_file_scope && !s.type()->isanyfunc())
	{
		Scope *scope = s.scope();

		while (scope != NULL && scope->symbol() == NULL)
			scope = scope->parent();

		if (scope != NULL)
		{
			const char *sname = scope->symbol()->alias() ? 
					scope->symbol()->alias() : scope->symbol()->name();
			return strget(xsprintf("%s$%s", us2minus(sname), name));
		}
	}

	return name;
}

// dump out struct/union types as Forth struct/fields and enums as constants
//
void
mktype(Type *t, boolean force = FALSE)
{
	if (t == NULL)
		return;

	while (t->isarr() || t->isptr())
	{
		if (t->isarr())
			t = ((Array_type*)t)->type();
		if (t->isptr())
			t = ((Pointer_type *)t)->type();
	}

	if (t->isstruct())
	{
		Struct_type *fs = (Struct_type*)t;

		if (fs->symbol() == NULL || fs->symbol()->treedone())
			return;

		if (!force && !fs->symbol()->read())
			return;

		fs->symbol()->treedone(TRUE);

		if (fs->memlist() == NULL)
			return;

		Symbol **mem = fs->memlist()->getarr();
		Integer tmp = fs->getsize();
		Integer offset(g_size_t_type->ic());

		// first go through and dump out any nested SUE types
		for (int i = 0; i < fs->memlist()->size(); i++)
			mktype(mem[i]->type(), TRUE);

		p("\nstruct \\ %s\n", fs->name());

		// now we can dump out the fields for this struct/union
		for (int i = 0; i < fs->memlist()->size(); i++)
		{
			// bitfields screw up alignment/size values for Forth fields
			if (mem[i]->type()->isbit())
			{
				tmp.assign(*mem[i]->offset());
				p("  ( %2s bitfield %s.%s )\n", ITOSTR(tmp),
					us2minus(fs->name()), mksymbolname(*mem[i]));
				continue;
			}

			tmp.assign(*mem[i]->offset());
			tmp.div(*g_min_addr_size);

			tmp.assign(mem[i]->type()->getsize());
			p("  %2s field %s.%s\n", ITOSTR(tmp),
					us2minus(fs->name()), mksymbolname(*mem[i]));
			offset.add(tmp);

			if (mem[i]->pad() && !mem[i]->pad()->isZero())
			{
				static int pad = 1;
				p("  %2s field %s.$pad%d\n", ITOSTR(*mem[i]->pad()),
						us2minus(fs->name()), pad++);
			}
		}

		p(" constant %s.$size \\ end struct\n", us2minus(fs->name()));
	}
	else if (t->isunion())
	{
		Union_type *fs = (Union_type*)t;

		if (fs->symbol() == NULL || fs->symbol()->treedone())
			return;

		if (!force && !fs->symbol()->read())
			return;

		fs->symbol()->treedone(TRUE);

		Symbol **mem = fs->memlist()->getarr();

		// first go through and dump out any nested SUE types
		for (int i = 0; i < fs->memlist()->size(); i++)
			mktype(mem[i]->type(), TRUE);

		#if 0
		p("\n\\ union %s\n", fs->name());

		for (int i = 0; i < fs->memlist()->size(); i++)
		{
			p("  0 constant %s.%s\n", 
					us2minus(fs->name()), mksymbolname(*mem[i]));
		}
		#endif
	}
	else if (t->isenum())
	{
		Enum_type *et = (Enum_type*)t;
		Integer sz = et->getsize();

		// dump out the fields for this enum as a set of consts
		for (Symbol_iter si = *et->members(); si; si++)
		{
			Symbol &mem = si();

			if (mem.treedone() || !mem.read())
				continue;

			sz.assign(*mem.enumval());
			p("  %s constant %s \\ enum %s\n", ITOSTR(sz),
					mksymbolname(mem), et->name());
			mem.treedone(TRUE);
		}
	}
}

const char *
mkfieldname(Symbol &s)
{
	if (s.scope() && s.scope()->id() > 0)
		return strget(xsprintf("%s:%d:%s", mksymbolname(*g_func_sym),
				s.scope()->id(), mksymbolname(s)));

	return strget(xsprintf("%s:%s", mksymbolname(*g_func_sym),
			mksymbolname(s)));
}

void
init_tree()
{
	if (!g_do_tree || num_errors())
		return;

	p("fcode-version2\n");

	if (g_debug_syms)
		p("headers\n\n");
	else
		p("headerless\n\n");

	p("0 value $frame \\ C stack-frame pointer\n\n");
}

void
do_tree(Symbol *sym)
{
	if (sym == NULL || !g_do_tree || num_errors())
		return;

	if (streq(sym->name(), "main"))
	{
		// save main so it is generated last
		sym->read(1);
		g_main_sym = sym;
		return;
	}

	// in case any enums just got used/read
	if (g_file_scope->has_symtab())
	{
		for (Symbol_iter si = g_file_scope->symtab(); si; si++)
		{
			Symbol &s = si();

			if (sym != &s)
				s.mktree();
		}
	}

	if (sym->treedone() || sym->storage() == ENUM || sym->parameter() ||
			(!sym->type()->isfunc() && sym->storage() != STATIC &&
				sym->scope() != g_file_scope))
	    return;

	if (g_sym_alias)
	{
		sym->alias(strget(g_sym_alias));
		strfree(g_sym_alias);
		g_sym_alias = NULL;
	}

	sym->mktree();

	if (sym->node() != NULL && !sym->is_asm() && !sym->is_inline())
	{
		// do not need the function bodies or initialization lists
		//delete sym->node();
		sym->node(g_noop_node);
	}

	if (g_dev_list)
		g_dev_list->end() = sym;
}

void
do_tree(Node *node)
{
	if (node == NULL || !g_do_tree || num_errors())
		return;

	// any global asm statements
	(void)node->mktree();
	//delete node;
}

TreeNode *
fini_tree()
{
	if (!g_do_tree || num_errors())
		return NULL;

	(void)g_file_scope->mktree();

	if (g_main_sym)
	{
		// generate tree for main as the last thing, without a func wrapper
		g_main_sym->mktree();
		//delete g_main_sym->node();
		g_main_sym->node(g_noop_node);
	}

	p("\nfcode-end\n");
	return g_tree_node;
}

// make tree for everything within this scope
TreeNode *
Scope::mktree()
{
	if (_init == NULL)
		return g_tree_node;

	// declare all local vars in sub-scopes
	for (int i = 0; i < _init->size(); i++)
	{
		if (_init->elt(i) == NULL)
			continue;

		Symbol &s = *_init->elt(i);

		if (s.storage() == TYPEDEF || s.storage() == STATIC ||
				s.parameter() || s.treedone())
			continue;

		s.mktree();

		if (s.node() != NULL)
		{
			// do not need initializers any longer
			//delete s.node();
			s.node(g_noop_node);
		}
	}

	return g_tree_node;
}

void
StorageAllocator::allocparam(Integer &size, int align, Integer *val)
{
	Integer t(_offset);
	Integer a(g_size_t_type->ic(), align);

	t.rem(a);

	if (!t.isZero())
	{
		a.sub(t);
		_offset.add(a);
	}

	if (val)
		val->assign(_offset);

	_offset.add(size);
}

// calculate local var size necessary for stack frame
void
Scope::calclocals(StorageAllocator &stkalloc)
{
	if (_symtab != NULL)		// for local var nodes
	{
		int i = 0;
		Symbol_iter si;

		// set our scope ID number for name generation
		id(g_scope_id++);

		// calculate offsets for local vars
		for (si = *_symtab; si; i++, si++)
		{
			Symbol &s = si();

			mktype(s.type());

			if (s.storage() == TYPEDEF || s.storage() == ENUM ||
					s.storage() == STATIC || s.offset() != NULL ||
					s.type()->isfunc() || s.parameter())
				continue;

			s.offset(new Integer(g_size_t_type->ic()));
			stkalloc.allocparam(s.type()->getsize(),
					s.type()->align() / g_min_addressable,
					s.offset());
		}
	}

	// forget about sub-scope overlays - makes things too complicated
	if (_children != NULL)
		for (int i = 0; i < _children->size(); i++)
			_children->elt(i)->calclocals(stkalloc);
}

// dump out stack frame vars in any scope
void
mkstackvars(Scope *sc)
{
	if (sc->has_symtab())		// for local var nodes
	{
		int i = 0;
		Symbol_iter si;

		// go through the symbol-table
		for (si = sc->symtab(); si; i++, si++)
		{
			Symbol &s = si();

			if (s.storage() == TYPEDEF || s.storage() == ENUM ||
					s.storage() == STATIC || 
					s.type()->isfunc() || s.parameter())
				continue;

			// dump field name
			if (g_recursive)
				p("  %2s field %s\n", ITOSTR(s.type()->getsize()),
						mkfieldname(s));
			else
			{
				long size;
				integertol(s.type()->getsize(), size);

				if (size <= g_size_long / g_min_addressable)
					p("variable %s\n", mksymbolname(s));
				else
					p("%x buffer: %s\n", size, mksymbolname(s));
			}
		}
	}

	// forget about sub-scope overlays - makes things too complicated
	if (sc->children() != NULL)
		for (int i = 0; i < sc->children()->size(); i++)
			mkstackvars(sc->children()->elt(i));
}

/* expect stack:
	(f.1 .. f.n addr --)	struct/array
	(val shift addr --)		bitfield
	(val addr --)			integral/pointer/anything else
 */
static void
do_set(Type &t)
{
	long size;

	if (t.isbit())
		size = ((Bitfield_type*)&t)->getwidth();
	else if (integertol(t.getsize(), size))
		size *= g_min_addressable;
	else
		size = g_size_long;

	if (t.isbit())
	{
		// shift offset must already have been pushed on the stack
		// below the lvalue pointer - 1st get the current field value
		// stack: val shift addr
		p(" dup >r ");
		// stack: val shift addr

		if (t.isvolatile() && size <= g_size_long)
			p("r");

		if (size <= g_size_char)
			p("%c@", t.isvolatile() ? 'b' : 'c');
		else if (size <= g_size_short)
			p("w@");
		else if (size <= g_size_long)
			p("l@");
		// stack: val shift org-field

		// clear out the bits we will be replacing and set them to val
		p(" over %x swap lshift invert and", (1 << size) - 1);
		// stack: val shift cleared-field
		p(" -rot swap %x and swap lshift or r>", (1 << size) - 1);
		// stack: val+field addr

		// finally ready to set the field below
	}

	if (t.isstruct())
	{
		Struct_type *fs = (Struct_type*)&t;

		if (fs->memlist() == NULL)
			return;

		Symbol **mem = fs->memlist()->getarr();

		p("\n >r");

		// pop fields off stack in reverse - last field is on top of stack
		for (int i = fs->memlist()->size() - 1; i >= 0; i--)
		{
			if (mem[i]->type()->isbit())
			{
				Bitfield_type *bt = (Bitfield_type *)mem[i]->type();
				int iwidth = bt->ic().bits();
				Integer elemoff(*mem[i]->offset());

				// push shift value for do_set
				if (iwidth <= g_size_char)
					iwidth = g_size_char;
				else if (iwidth <= g_size_short)
					iwidth = g_size_short;
				else if (iwidth <= g_size_long)
					iwidth = g_size_long;
				else if (iwidth <= g_size_longlong)
					iwidth = g_size_longlong;

				Integer w(g_size_t_type->ic(), iwidth);
				elemoff.rem(w);
				p(" %s", ITOSTR(elemoff));	// shift
				elemoff.assign(*mem[i]->offset());
				elemoff.div(*g_min_addr_size);

				if (!elemoff.isZero())
					p(" %s +", ITOSTR(elemoff));
			}
			else
				p(" r@ %s.%s\n", us2minus(fs->name()), mksymbolname(*mem[i]));

			do_set(*mem[i]->type());
		}

		p(" r> drop");
	}
	else if (t.isunion())
	{
		Union_type *ut = (Union_type*)&t;
		do_set(*ut->memlist()->elt(0)->type());
	}
	else if (t.isarr())
	{
		Array_type *at = (Array_type*)&t;

		p("\n %s 0 do dup >r", ITOSTR(at->len()));
		do_set(*at->type());
		p(" r> %s + loop drop", ITOSTR(at->type()->getsize()));
	}
	else	// integral, pointer
	{
		p(" ");

		if (t.isvolatile())
			p("r");

		if (size <= g_size_char)
			p("%c!", t.isvolatile() ? 'b' : 'c');
		else if (size <= g_size_short)
			p("w!");
		else if (size <= g_size_long)
			p("l!");
		else if (size <= g_size_longlong)
			p("x!");
	}
}

/* expect stack:
	(addr -- f.1 .. f.n)	struct/array
	(shift addr -- val)		bitfield
	(addr -- val)			integral/pointer/anything else
 */
static void
do_get(Type &t)
{
	long size;

	if (t.isbit())
		size = ((Bitfield_type*)&t)->getwidth();
	else if (integertol(t.getsize(), size))
		size *= g_min_addressable;
	else
		size = g_size_long;

	if (t.isstruct())
	{
		Struct_type *fs = (Struct_type*)&t;
		Symbol **mem = fs->memlist()->getarr();
		p("\n >r");

		// push fields on stack in order so last field ends
		// up on top of stack
		for (int i = 0; i < fs->memlist()->size(); i++)
		{
			if (mem[i]->type()->isbit())
			{
				Bitfield_type *bt = (Bitfield_type *)mem[i]->type();
				int iwidth = bt->ic().bits();
				Integer elemoff(*mem[i]->offset());

				if (iwidth <= g_size_char)
					iwidth = g_size_char;
				else if (iwidth <= g_size_short)
					iwidth = g_size_short;
				else if (iwidth <= g_size_long)
					iwidth = g_size_long;
				else if (iwidth <= g_size_longlong)
					iwidth = g_size_longlong;

				Integer w(g_size_t_type->ic(), iwidth);
				elemoff.rem(w);
				p(" %s swap", ITOSTR(elemoff));
				elemoff.div(*g_min_addr_size);

				if (!elemoff.isZero())
					p(" %s +", ITOSTR(elemoff));
			}
			else
				p(" r@ %s.%s\n", us2minus(fs->name()), mksymbolname(*mem[i]));

			do_get(*mem[i]->type());
		}

		p(" r> drop");
	}
	else if (t.isunion())
	{
		// type of union is 1st element in union
		Union_type *ut = (Union_type*)&t;
		do_get(*ut->memlist()->elt(0)->type());
	}
	else if (t.isarr())
	{
		Array_type *at = (Array_type*)&t;
		Integer &i = at->type()->getsize();

		p("\n %s", ITOSTR(at->len()));

		if (i != i.integerclass().one())
			p(" %s *", ITOSTR(i));

		p(" + %s 0 do", ITOSTR(at->len()));
		p(" %s - dup >r", ITOSTR(i));
		do_get(*at->type());
		p(" r> loop drop");
	}
	else 	// integral, pointer
	{
		p(" ");

		if (t.isvolatile())
			p("r");

		if (size <= g_size_char)
			p("%c@", t.isvolatile() ? 'b' : 'c');
		else if (size <= g_size_short)
			p("w@");
		else if (size <= g_size_long)
			p("l@");
		else if (size <= g_size_longlong)
			p("x@");
	}

	// shift offset must already have been pushed on the stack
	if (t.isbit())
		p(" swap rshift %x and", (1 << size) - 1);
}

// data to be assigned to variable is already on the stack
static void
mkassign(Symbol &s)
{
	if (!g_recursive || s.storage() == STATIC ||
			s.storage() == EXTERN || s.offset() == NULL)
		p(" %s", mksymbolname(s));
	else
		p(" $frame %s", mkfieldname(s));

	do_set(*s.type());
	p("\n");
}

static void
mkzero(Type &t)
{
	long count;

	if (t.isstruct())
	{
		Struct_type *st = (Struct_type*)&t;
		if (st->memlist() == NULL)
			return;
		count = st->memlist()->size();
	}
	else if (t.isunion())
	{
		Union_type *ut = (Union_type*)&t;
		mkzero(*ut->memlist()->elt(0)->type());
		return;
	}
	else if (t.isarr())
	{
		Array_type *at = (Array_type*)&t;
		integertol(at->len(), count);
	}
	else
	{
		count = 1;
	}

	if (count > 8)
		p(" %x 0 do 0 loop", count);
	else
		while (count-- > 0)
			p(" 0");
}

// make tree for this symbol - either global/extern/static data or function
TreeNode *
Symbol::mktree()
{
	// names which do not denote code or data
	if (_storage == TYPEDEF || _treedone)
		return NULL;

	if (_type->typeval() == T_FUNCTION)
	{
		// extern or inline functions are ignored here
		if (_node == NULL || _isasm || _isinline)
			return NULL;

		// the size of the return value from this function
		Function_type *ft = (Function_type *)_type;
		mktype(ft->retval());
		StorageAllocator stkalloc;
		g_stkalloc = &stkalloc;		// no nested funcs, so this is OK

		g_func_sym = this;
		mktype(_type);

		// setup our function parameter offsets
		if (ft->args() != NULL && _scope != NULL && _scope != g_file_scope)
		{
			for (int i = 0; i < ft->args()->size(); i++)
			{
				if (ft->args()->elt(i).storage() == DOTDOTDOT)
				{
					eprintf("Sorry, no support for varags yet.\n");
					return NULL;
				}

				Symbol &s = *_scope->init()->elt(i);
				mktype(s.type());

				// 1st arg symbols should be parameters
				if (!s.parameter())
					bug("Symbol::mktree - expected param %s in func %s",
							s.name(), name());

				if (s.offset() == NULL)
				{
					s.offset(new Integer(g_size_t_type->ic()));
					stkalloc.allocparam(s.type()->getsize(),
							s.type()->align() / g_min_addressable,
							s.offset());
				}
			}
		}

		// now figure out how big our local stack has to be
		if (_scope != NULL)
		{
			g_scope_id = 0;
			_scope->calclocals(stkalloc);
		}

		// define a Forth struct/field for all this function's variables
		if (!stkalloc.offset().isZero())
		{
			if (g_recursive)
			{
				p("\nstruct \\ %s stack-frame\n", name());
				p("   %d field %s:$prev \\ pointer to previous frame\n",
						g_size_pointer / g_min_addressable,
						mksymbolname(*this));
			}

			// generate our function parameter fields
			if (ft->args() != NULL && _scope != NULL && _scope != g_file_scope)
				for (int i = 0; i < ft->args()->size(); i++)
				{
					Symbol &s = *_scope->init()->elt(i);

					if (g_recursive)
						p("  %2s field %s\n", ITOSTR(s.type()->getsize()),
								mkfieldname(s));
					else
					{
						long size;
						integertol(s.type()->getsize(), size);

						if (size <= g_size_long / g_min_addressable)
							p("variable %s\n", mksymbolname(s));
						else
							p("%x buffer: %s\n", size, mksymbolname(s));
					}
				}

			if (_scope != NULL)
				mkstackvars(_scope);

			// save the size of our function-var struct in a handy place
			if (g_recursive)
				p("constant %s:$size \\ end stack-frame\n",
						mksymbolname(*this));
		}

		if (streq(name(), "main") || g_expand_inline)
			p("\n\\ %s\n", name());
		else
		{
			if (_storage != STATIC)
				p("\nexternal");

			p("\n\\ function %s\n: %s", _name, mksymbolname(*this));

			if (g_recursive)
				p(" recursive");

			p("\n");
		}

		// generate the function setup code
		if (!stkalloc.offset().isZero() && g_recursive)
			p(" %s:$size alloc-mem dup $frame swap ( +$prev ) l! to $frame\n",
					mksymbolname(*this)); // pushframe

		// pop the parameters from the stack into the frame
		if (ft->args() != NULL && _scope != NULL &&
				_scope != g_file_scope && ft->args()->size() > 0)
		{
			for (int i = ft->args()->size() - 1; i >= 0; i--)
			{
				if (ft->args()->elt(i).storage() == DOTDOTDOT)
					break;

				Symbol &s = *_scope->init()->elt(i);

				if (g_recursive)
					p(" $frame %s", mkfieldname(s));
				else
					p(" %s", mksymbolname(s));

				do_set(*s.type());
				p("\n");
			}

			p(" \\ saved parameters\n");
		}

		// generate the Forth for this function body
		if (_node->nodetype() == N_COMPOUND)
			_node->mktree();
		else
			_node->mkinit();

		// end of function cleanup code, if needed
		if (g_recursive && !stkalloc.offset().isZero() &&
				(ft->retval()->isvoid() || !_node->check_return()))
			p("\n $frame dup ( $prev ) l@ to $frame %s:$size free-mem",
					mksymbolname(*this));	// popframe

		if (streq(name(), "main") || g_expand_inline)
			p("\n\\ end %s\n", name());
		else
			p("\n ; \\ end %s\n", _name);

		if (_storage != STATIC)
		{
			if (g_debug_syms)
				p("headers\n\n");
			else
				p("headerless\n\n");
		}

		g_func_sym = NULL;
		g_expand_inline = FALSE;
		g_recursive = FALSE;
		g_stkalloc = NULL;
		_treedone = TRUE;
		return g_tree_node;
	}							// end of function stuff

	if (_storage == ENUM)
	{
		if (!_read)
			return NULL;

		p("%s constant %s \\ enum\n", ITOSTR(*_member->enumval()),
				mksymbolname(*this));
	}
	else if (_scope == g_file_scope || _storage == STATIC)
	{
		// data var - global, static, etc
		long size = g_size_long / g_min_addressable;

		// drop all extern variables so they pick up their Forth names
		if (_storage == EXTERN)
			return NULL;

		if (_type != NULL)
			mktype(_type);

		integertol(_type->getsize(), size);

		if (_storage != STATIC)
			p("\nexternal\n");

		if (size <= g_size_long / g_min_addressable)
			p("variable %s", mksymbolname(*this));
		else
			p("%x buffer: %s", size, mksymbolname(*this));

		if (_node && _node != g_noop_node)
		{
			_node->mkinit();
			p(" %s", mksymbolname(*this));
			do_set(*_type);
			p("\n");
		}
		else if (size <= g_size_long / g_min_addressable)
		{
			mkzero(*_type);
			p(" %s", mksymbolname(*this));
			do_set(*_type);
			p("\n");
		}
		else
		{
			p(" %s %x 0 fill\n", mksymbolname(*this), size);
		}

		if (_storage != STATIC)
		{
			if (g_debug_syms)
				p("headers\n\n");
			else
				p("headerless\n\n");
		}
	}
	else if (_storage != EXTERN)			// stack variable
	{
		// uninitialized stack var - space is already allocated
		if (_node == NULL || _node == g_noop_node)
			return g_tree_node;

		mktype(_type);

		if (_type->issu() || _type->isarr())
		{
			_node->mkinit();
			mkassign(*this);
		}
		else
		{
			_node->mktree();
			mkassign(*this);
		}
	}

	_treedone = TRUE;
	return g_tree_node;
}

// make trees from all expression and statement nodes...

TreeNode *
Node::mktree()
{
	bug("Node::mktree() should never be called for node %d", nodetype());
	return NULL;
}

TreeNode *
Expr_node::mktree()
{
	if (type() == g_unknown_type)
		return g_tree_node;

	bug("Expr_node::mktree() should never be called for node %d", nodetype());
	return NULL;
}

LValueTreeNode *
Expr_node::mklval()
{
	bug("Expr_node::mklval() should never be called for node %d", nodetype());
	return NULL;
}

TreeNode *
Node::mkinit()
{
	bug("Node::mkinit() should never be called for node %d", nodetype());
	return NULL;
}

TreeNode *
Expr_node::mkinit()
{
	if (type() == g_unknown_type)
		return g_tree_node;

	bug("Expr_node::mkinit() should never be called for node %d", nodetype());
	return NULL;
}

TreeNode *
Integer_node::mktree()
{
	p(" %s", ITOSTR(*_val));
	return g_tree_node;
}

TreeNode *
Integer_node::mkinit()
{
	p(" %s", ITOSTR(*_val));
	return g_tree_node;
}

TreeNode *
Sizeof_node::mktree()
{
	p(" %s", ITOSTR(_size));
	return g_tree_node;
}

TreeNode *
Sizeof_node::mkinit()
{
	p(" %s", ITOSTR(_size));
	return g_tree_node;
}

TreeNode *
Float_node::mktree()
{
	eprintf("Fcode floating-point is not supported\n");
	return NULL;
}

TreeNode *
Float_node::mkinit()
{
	eprintf("Fcode floating-point is not supported\n");
	return NULL;
}

TreeNode *
String_node::mktree()
{
	const char *s = _string;

	if (_wide)
	{
		eprintf("Wide-character strings are not supported.\n");
		return NULL;
	}

	p(" \" ");

	for (size_t i = 0; i < _len; s++, i++)
	{
		if (isprint(*s))
			p("%c", *s);
		else
			p("\"(%.2X)", *s);
	}

	if (_forth)		// no terminating null for Forth strings
		p("\"");
	else
		p("\"(00)\" drop");

	return g_tree_node;
}

TreeNode *
String_node::mkinit()
{
	return String_node::mktree();
}

LValueTreeNode *
String_node::mklval()
{
	String_node::mktree();
	return g_lvaltree_node;
}

LValueTreeNode *
Symbol_node::mklval()
{
	if (_sym == NULL || _sym->storage() == ENUM)
		return NULL;

	if (_sym->type()->isfunc())
		p(" ['] %s", mksymbolname(*_sym));
	else if (!g_recursive || _sym->scope() == g_file_scope ||
			_sym->storage() == STATIC || _sym->storage() == EXTERN)
		// global
		p(" %s", mksymbolname(*_sym));
	else
		// local symbol - param or var
		p(" $frame %s", mkfieldname(*_sym));

	return g_lvaltree_node;
}

TreeNode *
Symbol_node::mktree()
{
	if (_sym == NULL)
		return NULL;

	if (_sym->storage() == ENUM)
		p(" %s", _sym->name());
	else if (_sym->type()->isfunc())
	{
		if (!g_is_func_call)
			p(" [']");

		if (_sym->is_asm() || _sym->is_inline())
			_sym->node()->mktree();
		else
			p(" %s", mksymbolname(*_sym));
	}
	else if (_sym->type()->isarr() || _sym->type()->issu())
	{
		if (!g_recursive || _sym->scope() == g_file_scope ||
				_sym->storage() == STATIC || _sym->storage() == EXTERN)
			// global
			p(" %s", mksymbolname(*_sym));
		else
			// local
			p(" $frame %s", mkfieldname(*_sym));
	}
	else
	{
		long size;

		if (integertol(_type->getsize(), size))
			size *= g_min_addressable;
		else
			size = g_size_long;

		Symbol_node::mklval();
		do_get(*_type);
	}

	return g_tree_node;
}

TreeNode *
Symbol_node::mkinit()
{
	if (_sym == NULL)
		return NULL;

	p(" %s", mksymbolname(*_sym));
	return g_tree_node;
}

LValueTreeNode *
Array_ref_node::mklval()
{
	Type *t = g_unknown_type;

	if (_arr->type()->isptr())
		t = ((Pointer_type *)_arr->type())->type();
	else if (_arr->type()->isarr())
		t = ((Array_type *)_arr->type())->type();
	else
		bug("Array_ref_node::mklval: illegal type for _arr");

	_arr->mktree();

	if (_expr->is_int_expr())
	{
		Const_expr e;
		_expr->eval_const_expr(e);

		if (e.sym != NULL)
		{
			p(" %s", mksymbolname(*e.sym));

			if (e.ival != NULL && !e.ival->isZero())
				p(" %s +", ITOSTR(*e.ival));

			return g_lvaltree_node;
		}
		else if (e.isint)
		{
			e.ival->mult(t->getsize());

			if (!e.ival->isZero())
				p(" %s +", ITOSTR(*e.ival));

			return g_lvaltree_node;
		}
		else
		{
			eprintf("Fcode floating-point is not supported.\n");
			return g_lvaltree_node;
		}
	}

	_expr->mktree();

	Integer &i = t->getsize();

	if (i != i.integerclass().one())
		p(" %s *", ITOSTR(i));

	p(" +");
	return g_lvaltree_node;
}

TreeNode *
Array_ref_node::mktree()
{
	Type *t = g_unknown_type;

	if (_arr->type()->isptr())
		t = ((Pointer_type *)_arr->type())->type();
	else if (_arr->type()->isarr())
		t = ((Array_type *)_arr->type())->type();
	else
		bug("Array_ref_node::mklval: illegal type for _arr");

	Array_ref_node::mklval();

	if (!t->isarr() && !t->issu())
		do_get(*_type);

	return g_tree_node;
}

LValueTreeNode *
Func_call_node::mklval()
{
	Func_call_node::mktree();
	return g_lvaltree_node;
}

TreeNode *
Func_call_node::mktree()
{
	Type *t = _func->type();

	// put the args on the stack in reverse order
	// - we do not support var args yet
	if (_args != NULL)
		for (int i = 0; i < _args->size(); i++)
		{
			_args->elt(i)->mktree();

			if (_args->elt(i)->type()->issu() &&
					_args->elt(i)->nodetype() == N_SYMBOL)
				do_get(*_args->elt(i)->type());
		}

	if (t->isptr())
	{
		_func->mklval();
		do_get(*t);
		p(" execute");
	}
	else
	{
		boolean save_fcall = g_is_func_call;
		g_is_func_call = TRUE;
		_func->mktree();
		g_is_func_call = save_fcall;
	}

	return g_tree_node;
}

LValueTreeNode *
Struct_ref_node::mklval()
{
	if (_elem->offset() == NULL)// for union entries
		return _structref->mklval();

	if (_elem->type()->isbit())
	{
		// push shift value for do_set
		Integer elemoff(*_elem->offset());

		elemoff.rem(*g_min_addr_size);
		p(" %s", ITOSTR(elemoff));	// rshift

		elemoff.assign(*_elem->offset());
		elemoff.div(*g_min_addr_size);
		_structref->mklval();

		if (!elemoff.isZero())
			p(" %s +", ITOSTR(elemoff));
	}
	else
	{
		_structref->mklval();
		p(" %s.%s", us2minus(((Struct_type*)_structref->type())->name()),
				mksymbolname(*_elem));
	}

	return g_lvaltree_node;
}

TreeNode *
Struct_ref_node::mktree()
{
	Integer elemoff(g_size_t_type->ic());

	if (_elem->offset() == NULL)
	{
		_structref->mklval();

		if (!_elem->type()->isarr())
			do_get(*_elem->type());

		return g_tree_node;
	}

	elemoff = *_elem->offset();

	if (_elem->type()->isbit())
	{
		elemoff.rem(*g_min_addr_size);
		p(" %s", ITOSTR(elemoff));	// rshift
		elemoff.assign(*_elem->offset());

		elemoff.div(*g_min_addr_size);
		_structref->mktree();

		if (!elemoff.isZero())
			p(" %s +", ITOSTR(elemoff));

		do_get(*_elem->type());
	}
	else
	{
		_structref->mklval();
		p(" %s.%s", us2minus(((Struct_type*)_structref->type())->name()),
				mksymbolname(*_elem));

		if (!_elem->type()->isarr())
			do_get(*_elem->type());
	}

	return g_tree_node;
}

TreeNode *
Struct_ref_node::mkinit()
{
	return mktree();
}

LValueTreeNode *
Operator_node::mklval()
{
	boolean fp = _arg->type()->isfloat();

	if (fp)
	{
		eprintf("Fcode floating-point not supported.\n");
		return NULL;
	}

	switch (_token)
	{
	case '*':
		_arg->mktree();
		break;

	// not strictly lvalues, but could appear embedded within an
	// lvalue
	case '&':
		_arg->mklval();
		break;

	case INCR:
	case DECR:
		_arg->mklval();
		p(" dup");
		do_get(*_arg->type());

		if (!_prefix)
			p(" tuck");

		if (_arg->type()->isptr())
		{
			Pointer_type *pt = (Pointer_type *)_arg->type();
			p(" %s %c", ITOSTR(pt->type()->getsize()),
					_token == INCR ? '+' : '-');
		}
		else
			p(" 1 %c", _token == INCR ? '+' : '-');

		if (_prefix)
			p(" tuck");

		p(" swap");
		do_set(*_arg->type());
		break;

	default:
		bug("Operator_node::mklval(): illegal token %d", _token);
		break;
	}

	return g_lvaltree_node;
}

TreeNode *
Operator_node::mktree()
{
	boolean fp = _arg->type()->isfloat();

	if (fp)
	{
		eprintf("Fcode floating-point is not supported.\n");
		return NULL;
	}

	if (is_int_expr())
		return mkinit();

	switch (_token)
	{
	case INCR:
	case DECR:
		_arg->mklval();
		p(" dup");
		do_get(*_arg->type());

		if (!_prefix)
			p(" tuck");

		if (_arg->type()->isptr())
		{
			Pointer_type *pt = (Pointer_type *)_arg->type();
			p(" %s %c", ITOSTR(pt->type()->getsize()),
					_token == INCR ? '+' : '-');
		}
		else
			p(" 1 %c", _token == INCR ? '+' : '-');

		if (_prefix)
			p(" tuck");

		p(" swap");
		do_set(*_arg->type());
		break;

	case '&':
		if (_arg->nodetype() == N_OPERATOR &&
				((Operator_node *)_arg)->token() == '*')
			((Operator_node *)_arg)->arg()->mktree();
		else
			_arg->mklval();

		break;

	case '*':
		if (_arg->nodetype() == N_OPERATOR &&
				((Operator_node *)_arg)->token() == '&')
			((Operator_node *)_arg)->arg()->mktree();
		else if (_type->isfunc())
			_arg->mktree();
		else
		{
			Operator_node::mklval();
			do_get(*_type);
		}

		break;

	case '+':
		_arg->mktree();
		break;

	case '-':
		_arg->mktree();
		p(" negate");
		break;

	case '~':
		_arg->mktree();
		p(" invert");
		break;

	case '!':
		_arg->mktree();
		p(" 0<> invert 1 and");
		break;

	default:
		bug("Operator_node::mktree() illegal token %d", _token);
		break;
	}

	return NULL;
}

TreeNode *
Operator_node::mkinit()
{
	Const_expr e;
	eval_const_expr(e);

	if (e.sym != NULL)
	{
		p(" %s", mksymbolname(*e.sym));

		if (e.ival != NULL && !e.ival->isZero())
			p(" %s +", ITOSTR(*e.ival));
	}
	else if (e.isint)
		p(" %s", ITOSTR(*e.ival));
	else
		eprintf("Fcode floating-point is not supported.\n");

	return g_tree_node;
}

TreeNode *
New_node::mktree()
{
	return NULL;
}

TreeNode *
Delete_node::mktree()
{
	return NULL;
}

LValueTreeNode *
Operator2_node::mklval()
{
	if (!_arg1->type()->isptr() && !_arg1->type()->isarr())
		bug("Operator2_node::mklval(): expected array/pointer");

	switch (_token)
	{
	case '+':
		// TODO
		_arg1->mktree();
		_arg2->mktree();

		if (!_arg2->type()->isptr() && !_arg2->type()->isarr())
		{
			Integer &i = _arg1->type()->getsize();

			if (i != i.integerclass().one())
				p(" %s *", ITOSTR(i));
		}

		p(" +");
		break;

	case '-':
		if (_arg2->type()->isptr() || _arg2->type()->isarr())
			bug("Operator2_node::mklval(): did not expect array/pointer");

		_arg1->mktree();
		_arg2->mktree();
		p(" - %s /", ITOSTR(_arg1->type()->getsize()));
		break;

	default:
		bug("Operator2_node::mklval(): illegal token %d", _token);
		break;
	}

	return g_lvaltree_node;
}

TreeNode *
Operator2_node::mktree()
{
	if (_type->isfloat())
	{
		eprintf("Fcode floating-point is not supported.\n");
		return NULL;
	}

	if (is_int_expr())
		return mkinit();

	switch (_token)
	{
	case '*':
		_arg1->mktree();
		_arg2->mktree();
		p(" *");
		break;

	case '/':
		_arg1->mktree();
		_arg2->mktree();
		p(" /");
		break;

	case '%':
		_arg1->mktree();
		_arg2->mktree();
		p(" mod");
		break;

	case '+':
		_arg1->mktree();
		_arg2->mktree();

		if (_type->isptr() || _type->isarr())
		{
			Integer &i = ((Pointer_type *)_type)->type()->getsize();

			if (i != i.integerclass().one())
				p(" %s *", ITOSTR(i));
		}

		p(" +");
		break;

	case '-':
		_arg1->mktree();
		_arg2->mktree();

		if (_arg1->type()->isptr() || _arg1->type()->isarr())
		{
			Integer &i = ((Pointer_type *)_arg1->type())->type()->getsize();

			if (i != i.integerclass().one())
			{
				if (_arg2->type()->isptr() || _arg2->type()->isarr())
					p(" - %s /", ITOSTR(i));
				else
					p(" %s * -", ITOSTR(i));
			}

			return g_tree_node;
		}

		p(" -");
		break;

	case RSHIFT:
		// TODO
		_arg1->mktree();
		_arg2->mktree();

		if (((Int_type *)_arg1->type())->sign())
			p(" >>a");
		else
			p(" rshift");

		break;

	case LSHIFT:
		_arg1->mktree();
		_arg2->mktree();
		p(" lshift");
		break;

	case '<':
		_arg1->mktree();
		_arg2->mktree();
		p(" < 1 and");
		break;

	case '>':
		_arg1->mktree();
		_arg2->mktree();
		p(" > 1 and");
		break;

	case LESSEQ:
		_arg1->mktree();
		_arg2->mktree();
		p(" <= 1 and");
		break;

	case GREATEQ:
		_arg1->mktree();
		_arg2->mktree();
		p(" >= 1 and");
		break;

	case EQUAL:
		_arg1->mktree();
		_arg2->mktree();
		p(" = 1 and");
		break;

	case NOTEQ:
		_arg1->mktree();
		_arg2->mktree();
		p(" <> 1 and");
		break;

	case '&':
		_arg1->mktree();
		_arg2->mktree();
		p(" and");
		break;

	case '^':
		_arg1->mktree();
		_arg2->mktree();
		p(" xor");
		break;

	case '|':
		_arg1->mktree();
		_arg2->mktree();
		p(" or");
		break;

	case ANDAND:
		_arg1->mktree();
		p(" dup 0<> if drop");
		_arg2->mktree();
		p(" then");
		break;

	case OROR:
		_arg1->mktree();
		p(" dup 0= if drop");
		_arg2->mktree();
		p(" then");
		break;

	case ',':
		_arg1->mktree();

		if (!_arg1->type()->isvoid())
			p(" drop");

		_arg2->mktree();
		break;

	case '=':
		_arg2->mktree();

		if (!_arg2->type()->issu())
			p(" dup");

		_arg1->mklval();
		do_set(*_arg1->type());
		break;

	case MULTEQ:
		_arg1->mklval();
		p(" dup");
		do_get(*_arg1->type());
		_arg2->mktree();
		p(" * tuck swap");
		do_set(*_arg1->type());
		break;

	case DIVEQ:
		_arg1->mklval();
		p(" dup");
		do_get(*_arg1->type());
		_arg2->mktree();
		p(" / tuck swap");
		do_set(*_arg1->type());
		break;

	case MODEQ:
		_arg1->mklval();
		p(" dup");
		do_get(*_arg1->type());
		_arg2->mktree();
		p(" + tuck swap");
		do_set(*_arg1->type());
		break;

	case PLUSEQ:
		_arg1->mklval();
		p(" dup");
		do_get(*_arg1->type());
		_arg2->mktree();

		if (_type->isptr() || _type->isarr())
		{
			Integer &i = ((Pointer_type *)_type)->type()->getsize();

			if (i != i.integerclass().one())
				p(" %s *", ITOSTR(i));
		}

		p(" + tuck swap");
		do_set(*_arg1->type());
		break;

	case MINUSEQ:
		_arg1->mklval();
		p(" dup");
		do_get(*_arg1->type());
		_arg2->mktree();

		if (_type->isptr() || _type->isarr())
		{
			Integer &i = ((Pointer_type *)_type)->type()->getsize();

			if (i != i.integerclass().one())
				p(" %s *", ITOSTR(i));
		}

		p(" - tuck swap");
		do_set(*_arg1->type());
		break;

	case LSHIFTEQ:
		_arg1->mklval();
		p(" dup");
		do_get(*_arg1->type());
		_arg2->mktree();
		p(" lshift tuck swap");
		do_set(*_arg1->type());
		break;

	case RSHIFTEQ:
		_arg1->mklval();
		p(" dup");
		do_get(*_arg1->type());
		_arg2->mktree();

		if (((Int_type *)_arg1->type())->sign())
			p(" >>a");
		else
			p(" rshift");

		p(" tuck swap");
		do_set(*_arg1->type());
		break;

	case ANDEQ:
		_arg1->mklval();
		p(" dup");
		do_get(*_arg1->type());
		_arg2->mktree();
		p(" and tuck swap");
		do_set(*_arg1->type());
		break;

	case XOREQ:
		_arg1->mklval();
		p(" dup");
		do_get(*_arg1->type());
		_arg2->mktree();
		p(" xor tuck swap");
		do_set(*_arg1->type());
		break;

	case OREQ:
		_arg1->mklval();
		p(" dup");
		do_get(*_arg1->type());
		_arg2->mktree();
		p(" or tuck swap");
		do_set(*_arg1->type());
		break;

	default:
		bug("Operator2_node::mktree() illegal token %d", _token);
		break;
	}

	return NULL;
}

TreeNode *
Operator2_node::mkinit()
{
	Const_expr e;
	eval_const_expr(e);

	if (e.sym != NULL)
	{
		p(" %s", mksymbolname(*e.sym));

		if (e.ival != NULL && !e.ival->isZero())
			p(" %s +", ITOSTR(*e.ival));
	}
	else if (e.isint)
		p(" %s", ITOSTR(*e.ival));
	else
		eprintf("Fcode floating-point is not supported.\n");

	return g_tree_node;
}

LValueTreeNode *
Operator3_node::mklval()
{
	if (_token != '?')
		bug("Operator3_node::mktree() illegal token %d", _token);

	Operator3_node::mktree();
	return g_lvaltree_node;
}

TreeNode *
Operator3_node::mktree()
{
	if (_token != '?')
		bug("Operator3_node::mktree() illegal token %d", _token);

	_arg1->mktree();
	p(" if");
	_arg2->mktree();
	p(" else");
	_arg3->mktree();
	p(" then");
	return g_tree_node;
}

TreeNode *
Operator3_node::mkinit()
{
	Const_expr e;
	eval_const_expr(e);

	if (e.sym != NULL)
	{
		p(" %s", mksymbolname(*e.sym));

		if (e.ival != NULL && !e.ival->isZero())
			p(" %s +", ITOSTR(*e.ival));
	}
	else if (e.isint)
		p(" %s", ITOSTR(*e.ival));
	else
		eprintf("Fcode floating-point is not supported.\n");

	return g_tree_node;
}

static TreeNode *
do_cast(Expr_node *expr, Type *from, Type *to)
{
	if (to == from)
		return expr->mktree();

	boolean tsigned = TRUE;
	boolean fsigned = TRUE;
	Type_val tt = T_FLOAT;
	Type_val ft = T_FLOAT;

	if (from->isint() || from->isenum() || from->isbit())
	{
		fsigned = ((Int_type *)from)->sign();
		ft = T_INT;
	}
	else if (from->isptr() || from->isfunc())
		ft = T_POINTER;
	else if (from->isarr())
		ft = T_ARRAY;

	if (to->isint() || to->isenum())
	{
		tsigned = ((Int_type *)to)->sign();
		tt = T_INT;
	}
	else if (to->isptr() || to->isarr() || to->isfunc())
		tt = T_POINTER;
	else if (to->isvoid())
		tt = T_VOID;

	if (tt == T_FLOAT || ft == T_FLOAT)
	{
		eprintf("Fcode floating-point is not supported.\n");
		return NULL;
	}

	// cast struct pointer into substruct pointer?
	if (tt == T_POINTER && tt == ft)
	{
		Pointer_type *fp = (Pointer_type *)from;
		Pointer_type *tp = (Pointer_type *)to;
		expr->mktree();

		if (!fp->isptr() || !tp->isptr() ||
				!fp->type()->isstruct() || !tp->type()->isstruct())
			return g_tree_node;

		Struct_type *fs = (Struct_type *)fp->type();

		// look for "from" in the member list of "to"
		Symbol **mem = fs->memlist()->getarr();
		int i;

		for (i = 0; i < fs->memlist()->size(); i++)
			if (mem[i]->type() == tp && mem[i]->name()[0] == UNNAMED_CHAR)
				break;

		if (i >= fs->memlist()->size())
			bug("do_cast: autocast of struct* --> substruct* failed");

		// element is union
		if (mem[i]->offset() == NULL)
			return g_tree_node;

		// add offset struct* to make it a substruct*
		if (!mem[i]->offset()->isZero())
			p(" %s +", ITOSTR(*mem[i]->offset()));

		return g_tree_node;
	}

	if (tt == T_POINTER && ft == T_ARRAY)
	{
		expr->mklval();
		return g_tree_node;
	}

	int twidth = to->getwidth();
	int fwidth = from->getwidth();
	expr->mktree();

	if (twidth < fwidth)
	{
		Integer t(g_size_t_type->ic(), 1);

		t <<= twidth;
		t--;
		p(" %s and", ITOSTR(t));
	}
	else if (twidth > fwidth)
	{
		Integer f(g_size_t_type->ic(), 1);

		f <<= fwidth;
		f--;
		p(" %s and", ITOSTR(f));

		if (tsigned && fsigned)
		{
			f.makeone();
			f <<= fwidth - 1;
			p(" dup %s and", ITOSTR(f));

			f.makeone();
			f <<= fwidth;
			f--;
			f.complement();
			p(" if %s or then", ITOSTR(f));
		}
	}

	return g_tree_node;
}

TreeNode *
Cast_node::mktree()
{
	if (_type->isvoid())
	{
		_cast->mktree();

		if (!_cast->type()->issu())
			p(" drop");
	}
	else if (_type->isptr() && _cast->type()->isptr())
		_cast->mktree();
	else
		do_cast(_cast, _cast->type(), _type);

	return g_tree_node;
}

LValueTreeNode *
Cast_node::mklval()
{
	Cast_node::mktree();
	return g_lvaltree_node;
}

TreeNode *
Cast_node::mkinit()
{
	return _cast->mkinit();
}

static void
mk_struct_init(Struct_type *ts, Expr_arr &init, boolean isinit)
{
	int si = init.size();
	int sm = ts->memlist()->size();
	int i = 0;
	int j = 0;
	Symbol **mem = ts->memlist()->getarr();

	for (; i < si && j < sm; j++)
	{
		if (init.elt(i) == NULL)
		{
			i++;

			if (isinit)
				mkzero(*mem[j]->type());

			continue;
		}

		if (isinit)
			init.elt(i)->mkinit();
		else
			init.elt(i)->mktree();

		i++;
	}

	if (isinit)
		for (; j < sm; j++)
			mkzero(*mem[j]->type());
}

static void
mk_array_init(Array_type *ta, Expr_arr &init, boolean isinit)
{
	int i = init.size() - 1;

	if (isinit)
	{
		Integer len = ta->len();
		Integer ii(len.integerclass(), init.size());
		len.sub(ii);

		for (--len; len.isPos(); --len)
			mkzero(*ta->type());
	}

	for (; i >= 0; i--)
		if (init.elt(i) != NULL)
			isinit ? init.elt(i)->mkinit() : init.elt(i)->mktree();
		else
			mkzero(*ta->type());
}

TreeNode *
Initializer_node::mkinit()
{
	switch (_type->typeval())
	{
	case T_STRUCT:
		mk_struct_init((Struct_type *)_type, _init, TRUE);
		break;

	case T_UNION:
		_init.elt(0)->mkinit();
		break;

	case T_ARRAY:
	case T_FUNCTION:
		mk_array_init((Array_type *)_type, _init, TRUE);
		break;

	default:
		bug("Initializer_node::mkinit(): unexpected type %d", _type);
	}

	return g_tree_node;
}

TreeNode *
Initializer_node::mktree()
{
	switch (_type->typeval())
	{
	case T_STRUCT:
		mk_struct_init((Struct_type *)_type, _init, FALSE);
		break;

	case T_UNION:
		_init.elt(0)->mktree();
		break;

	case T_ARRAY:
	case T_FUNCTION:
		mk_array_init((Array_type *)_type, _init, FALSE);
		break;

	default:
		bug("Initializer_node::mkinit(): unexpected type %d", _type);
	}

	return g_tree_node;
}

TreeNode *
Label_node::mktree()
{
	eprintf("Fcode label not supported.\n");
	return NULL;
}

TreeNode *
Case_node::mktree()
{
	if (_stmt)
	{
		if (_expr1)
		{
			_expr1->mktree();
			p(" of");
		}
		else
			p(" dup of");

		_stmt->mktree();

		if (!_stmt->check_break())
			p(" endof");

		if (_expr2)
			eprintf("Fcode case range statment is not supported.\n");
	}

	return g_tree_node;
}

TreeNode *
Switch_node::mktree()
{
	_expr->mktree();
	p(" case");
	g_in_switch++;

	if (_stmt)
		_stmt->mktree();

	g_in_switch--;
	p(" endcase");
	return g_tree_node;
}

TreeNode *
Compound_node::mktree()
{
	if (_stmts == NULL)
		return NULL;

	_scope->mktree();

	for (int i = 0; i < _stmts->size(); i++)
	{
		_stmts->elt(i)->mktree();

		if (i < _stmts->size() - 1)
			p("\n");
	}

	return g_tree_node;
}

TreeNode *
If_node::mktree()
{
	_expr->mktree();
	p(" if\n");

	if (_then == g_null_node)
	    _then = NULL;

	if (_else == g_null_node)
	    _else = NULL;

	if (_then)
	    _then->mktree();

	if (_else)
	{
		p(" else\n");
		_else->mktree();
	}

	p(" then");
	return g_tree_node;
}

TreeNode *
While_node::mktree()
{
	p("\n begin");
	_expr->mktree();
	p(" while\n");
	_stmt->mktree();
	p(" repeat");
	return g_tree_node;
}

TreeNode *
Dowhile_node::mktree()
{
	p("\n begin");
	_stmt->mktree();
	p("\n");
	_expr->mktree();
	p(" while repeat");
	return g_tree_node;
}

TreeNode *
For_node::mktree()
{
	if (_expr1)
		_expr1->mktree();

	p("\n begin");

	if (_expr2)
	{
		_expr2->mktree();
		p(" while\n");
	}

	if (_stmt)
	{
		_stmt->mktree();
		p("\n");
	}

	if (_expr3)
		_expr3->mktree();

	p(" repeat");
	return g_tree_node;
}

TreeNode *
Goto_node::mktree()
{
	eprintf("Fcode goto not supported.\n");
	return NULL;
}

TreeNode *
Continue_node::mktree()
{
	eprintf("Fcode loop continue not supported.\n");
	return NULL;
}

TreeNode *
Break_node::mktree()
{
	if (!g_in_switch)
	{
		eprintf("Fcode loop break not supported.\n");
		return NULL;
	}

	/* break only supported in "switch" statements */
	p(" endof");
	return g_tree_node;
}

TreeNode *
Return_node::mktree()
{
	if (_expr)
	{
		_expr->mktree();

		if (_expr->type()->issu())
			do_get(*_expr->type());
	}

	if (g_recursive && g_stkalloc && !g_stkalloc->offset().isZero())
		p("\n $frame dup ( $prev ) l@ to $frame %s:$size free-mem",
				mksymbolname(*g_func_sym));		// popframe

	p(" exit");
	return g_tree_node;
}

TreeNode *
Asm_node::mktree()
{
	p(" %s ( asm )\n", _asmstr->string());
	return g_tree_node;
}
